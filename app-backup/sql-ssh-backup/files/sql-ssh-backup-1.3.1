#!/bin/bash
#
# sql-ssh-backup
#
# Create MySQL- or PostgreSQL-Dumps via SSH using RSA or DSA authentication (private key).
# Each database will be dumped as a single file and can be compressed optional.
#
# Copyright (c) 2011 Peter Grosse (gentoo@friiks.de)
# Copyright (c) 2010-2011 Marcel Pennewiss (opensource@pennewiss.de)
# Forschungsgemeinschaft elektronische Medien e.V. (FeM e.V.)
#
# Current Version: 1.3
# Last Modified: 2011-11-24
#
# USAGE:
#   Start sql-ssh-backup with the "-h" option to show usage/help.
#
# REQUIREMENTS:
#   ssh
#   MySQL:
#     * bzip2 (if compression enabled)
#     * mysql / mysqldump (on remote server)
#   PostgreSQL:
#     * psql / pg_dump (on remote server)
#
# INSTALLATION: 
#   Copy the shell script to a suitable location
#
# CHANGELOG:
#   v1.0 - Initial Release (2010-12-14/mysql and 2011-04-14/pgsql)
#   v1.1 - Fix Cleanup Directory (2011-06-07)
#   v1.2 - Ignore cleanup directory list if empty (2011-07-01)
#   v1.3 - merge release supporting MySQL and PostgreSQL
#
# LICENSE: GPL-2
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
##########################################################################

# show usage information
print_usage() {
  echo "SQL-SSH-Backup v1.3"
  echo "Create MySQL-/PosgreSQL-Dumps via SSH using RSA or DSA authentication (private key)."
  echo "Each database will be dumped as a single file and can be compressed optional."
  echo ""
  echo "Usage $0 [-l <ssh-login>] -s <ssh-server> -i <identity-file> [-m <mysql-host>] [-d <backup-dir>] [-e <days>] [-c] [-h]"
  echo ""
  echo " -M                  Use for MySQL-Dumps"
  echo " -P                  Use for PostgreSQL-Dumps"
  echo " -l <ssh-login>      User to log in as on the remote machine (defaul: current user)"
  echo " -s <ssh-server>     Remote machine to log in"
  echo " -i <identity-file>  File from which the identity (private key) for SSH is read"
  echo " -m <sql-host>       MySQL-/PgSQL-Host to Dump (default: localhost)"
  echo " -u <sql-user>       MySQL-/PgSQL-User (leave empty while using .my.cnf on remote server)"
  echo " -p <mysql-password> MySQL-Password (leave empty while using .my.cnf on remote server)"
  echo " -d <backup-dir>     Base-directory where dumps will be stored (default: {scriptpath}/{ssh-server})"
  echo " -e <days>           Number of days after which old dumps will be deleted"
  echo " -c                  MySQL: Use bzip2 compression - dumps will be compressed on the local machine"
  echo "                     PgSQL: Use custom dump file format, instead of save uncompressed plain SQL files"
  echo " -h                  Show this help"
  echo ""
}

# check parameters and directories
function prepare()
{
  # reset error counter
  ERROR=0

  # set databasetype if unset
  [ -z ${MYSQL} ] && MYSQL=false
  [ -z ${POSTGRESQL} ] && POSTGRESQL=false

  # disable compression (default) if unset
  [ -z ${COMPRESS} ] && COMPRESS=false

  # set SSH-user to current user if unset
  [ -z ${SSH_USER} ] && SSH_USER=$(id -u -n)
  
  # check if mysql or posgresql selected
  ( ! ${MYSQL} && ! ${POSTGRESQL} ) && echo -e "You should either select MySQL or PostgreSQL as database type.\nStart sql-ssh-backup with the "-h" option to show usage/help." && exit 1

  # check ssh identity file
  ([ -z ${SSH_IDENTITY} ] || [ ! -f ${SSH_IDENTITY} ]) && echo "SSH identity file (private key) not set or not found." && ERROR+=1

  # check if remote server is set
  [ -z ${SSH_HOST} ] && echo "Remote ssh server not set." && ERROR+=1

  # set DB-Server to localhost if unset
  [ -z ${SQL_HOST} ] && SQL_HOST=localhost

  # check if MySQL-user and -password is set
  ${MYSQL} && [ ${SQL_USER} ] && [ ${SQL_PASSWORD} ] && SQL_OPTS="--user=${SQL_USER} --password=${SQL_PASSWORD}"

  # check if PostgreSQL-user is set
  ${POSTGRESQL} && [ ${SQL_USER} ] && SQL_OPTS="--username=${SQL_USER}"

  # set Backupdirectory to default value if unset
  [ -z ${BACKUPDIR} ] && BACKUPDIR=${HOME}/${SSH_HOST}
  BACKUPDIR_ORIG=${BACKUPDIR}
  BACKUPDIR+=/$(date +%F)/

  # check number of days
  [[ ! "x${DAYS}" =~ ^x[0-9]*$ ]] && echo "Wrong number of days, use only numeric value." && ERROR+=1
  [ -z ${DAYS} ] && DAYS=90

  # BackupExtension
  BACKUPEXT="sql"

  # use custom dump format if plainfile option unset
  ${POSTGRESQL} && ${COMPRESS} && SQL_DUMP_OPTS="--format custom" && BACKUPEXT="dump"

  # check for installed SSH-Client
  which ssh > /dev/null 2>&1 || (echo "SSH not found! Skipping all backups!" >&2 && exit 1)

  # check for installed bzip2 while using mysql
  ${MYSQL} && ${COMPRESS} && (which bzip2 > /dev/null 2>&1 || (echo "bzip2 not found and compression enabled! Skipping all backups!" >&2 && exit 1))

  # abort if too man errors occured
  [ ${ERROR} -ge 1 ] && echo -e "\nToo man errors occured. Aborting..." && exit 1

  # 
  if [ -d ${BACKUPDIR} ]; then
    rm -f ${BACKUPDIR}/*
  fi
  if [ ! -d ${BACKUPDIR} ]; then
    mkdir ${BACKUPDIR} -p
    [[ $? -ne 0 ]] && echo "Can't create Backup-Directory ${BACKUPDIR}." >&2  && exit 1
  fi
}

# connection-wrapper to execute mysqldump/pgsql/pg_dump via ssh
# param[in] $1 remote command to execute
# param[in] $2 filename used to redirect stdout (optional)
function connection_wrapper()
{
  # set SSH connection options	
  SSH_OPTS="-C -i ${SSH_IDENTITY}"

  if [ -z ${2} ]; then
	  LAST_RETURN=$(ssh ${SSH_OPTS} ${SSH_USER}@${SSH_HOST} "${1}" 2>&1)
  else
	  LAST_RETURN=$( { ssh ${SSH_OPTS} ${SSH_USER}@${SSH_HOST} "${1}" >${2}; } 2>&1 )
  fi
  local ret=$?
  [[ ${ret} -eq 255 ]] && echo "SSH-Connection failed." >&2 && echo ${LAST_RETURN} >&2 && exit 255
  return ${ret}
}

# dump global objects only
function dump_globals()
{
  connection_wrapper "pg_dumpall --globals-only --host ${SQL_HOST} ${SQL_OPTS}" "${BACKUPDIR}/_globals.sql"
  local ret=$?
  [[ ${ret} -ne 0 ]] && echo "pg_dump of global database objects failed." >&2 && echo ${LAST_RETURN} >&2
  return ${ret}
  LAST_RETURN=$(tail -3 "${BACKUPDIR}/_globals.sql" | head -1 | grep -e "^-- PostgreSQL database dump complete" 2>&1)
  local ret=$?
  [[ ${ret} -ne 0 ]] && echo "Dump-Check of global database objects failed." >&2 && echo ${LAST_RETURN} >&2
  return ${ret}
}

# get full database-list
function get_databaselist()
{
  ${MYSQL} && local GET_DATABASE_LIST_COMMAND="mysql --host ${SQL_HOST} ${SQL_OPTS} -Bse 'show databases'"
  ${POSTGRESQL} && local GET_DATABASE_LIST_COMMAND="psql --host ${SQL_HOST} ${SQL_OPTS} --tuples-only --no-align --dbname postgres --command 'SELECT datname FROM pg_database WHERE datistemplate IS FALSE;'"
  connection_wrapper "${GET_DATABASE_LIST_COMMAND}" 
  [[ $? -ne 0 ]] && echo "$ret: Can't get database list:" >&2 && echo ${LAST_RETURN} >&2 && exit 1
}

# dump a database
# param[in] $1 database-name
function dump_database()
{
  ${MYSQL} && local DUMP_DATABASE_COMMAND="mysqldump --single-transaction --extended-insert --host ${SQL_HOST} ${SQL_OPTS} --no-autocommit --set-charset ${1}"
  ${POSTGRESQL} && local DUMP_DATABASE_COMMAND="pg_dump --blobs --create --encoding UTF-8 --host ${SQL_HOST} ${SQL_OPTS} ${SQL_DUMP_OPTS} ${1}"
  connection_wrapper "${DUMP_DATABASE_COMMAND}" "${BACKUPDIR}/${1}.${BACKUPEXT}"
  local ret=$?
  [[ ${ret} -ne 0 ]] && echo "Dump of database \"${1}\" failed." >&2 && echo ${LAST_RETURN} >&2
  return ${ret}
}

# check for complete database-dump
# param[in] $1 database-name
function check_database_dump()
{
  if ${MYSQL}; then
    LAST_RETURN=$(tail "${BACKUPDIR}/${1}.${BACKUPEXT}" -n 1 | grep -e "^-- Dump completed o" 2>&1)
  elif ${POSTGRESQL}; then
    ${COMPRESS} || LAST_RETURN=$(tail -3 "${BACKUPDIR}/${1}.${BACKUPEXT}" | head -1 | grep -e "^-- PostgreSQL database dump complete" 2>&1)
  fi
  local ret=$?
  [[ ${ret} -ne 0 ]] && echo "Dump-Check of database \"${1}\" failed." >&2 && echo ${LAST_RETURN} >&2
  return ${ret}
}

# compress the dump file of a single database (for mysql)
# param[in] $1 database-name
function compress_database()
{
  LAST_RETURN=$(bzip2 "${BACKUPDIR}/${1}.${BACKUPEXT}" 2>&1)
  local ret=$?
  [[ ${ret} -ne 0 ]] && echo "Compaction of database \"${1}\" failed." >&2 && echo ${LAST_RETURN} >&2
  return ${ret}
}

# check the compressed dump
# param[in] $1 database-name
function check_compressed_database()
{
  LAST_RETURN=$(bzip2 --test "${BACKUPDIR}/${1}.${BACKUPEXT}.bz2" 2>&1)
  local ret=$?
  [[ ${ret} -ne 0 ]] && echo "Test of compacted database \"${1}\" failed." >&2 && echo ${LAST_RETURN} >&2
  return ${ret}
}

# dump all databases
# param[in] $1 list of databases (IFS-seperated)
function dump_all_databases()
{
  for DATABASE in ${1}
  do
    dump_database ${DATABASE}
    [[ $? -eq 0 ]] && check_database_dump ${DATABASE}
    [[ $? -eq 0 ]] && ${MYSQL} && ${COMPRESS} && compress_database ${DATABASE}
    [[ $? -eq 0 ]] && ${MYSQL} && ${COMPRESS} && check_compressed_database ${DATABASE}
  done
}

# cleanup backup-directory
# remove all subdirectories which are older then ${DAYS} days
function cleanup()
{
  if [ -d ${BACKUPDIR_ORIG} ]; then
  	LAST_RETURN=$(find ${BACKUPDIR_ORIG}/* -type d -mtime +${DAYS} | xargs --no-run-if-empty /bin/rm -r 2>&1)
  fi
  [[ $? -ne 0 ]] && echo "Cleanup of old Backups failed:" >&2 && echo ${LAST_RETURN} >&2
}

# run main part
while getopts ":hMPl:s:i:m:u:p:d:e:c" Option; do
        case $Option in
                h )     print_usage && exit 0;;
		M )	MYSQL=true;;
		P )	POSTGRESQL=true;;
		l )	SSH_USER=${OPTARG};;
		s )	SSH_HOST=${OPTARG};;
		i )	SSH_IDENTITY=${OPTARG};;
		m )	SQL_HOST=${OPTARG};;
		u )	SQL_USER=${OPTARG};;
		p )	SQL_PASSWORD=${OPTARG};;
		d )	BACKUPDIR=${OPTARG};;
		e )	DAYS=${OPTARG};;
		c )	COMPRESS=true;;
                * )     echo -e "Unknown parameter \"-${OPTARG}\"!\n"; 
			print_usage
			exit 1
			;;
        esac
done
shift $(($OPTIND - 1)) 

prepare
${POSTGRESQL} && dump_globals
get_databaselist
dump_all_databases "${LAST_RETURN}"
cleanup
exit 0
