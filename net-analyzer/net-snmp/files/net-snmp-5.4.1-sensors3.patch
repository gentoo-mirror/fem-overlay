Source: http://cvs.fedoraproject.org/viewvc/devel/net-snmp/net-snmp-5.4.1-sensors3.patch

---

351991: Port net-snmp to lm_sensors-3.x.x
Source: upstream, svn diff -r 16736:16739
Reviewed-By: Jan Safranek <jsafrane@redhat.com>

Index: configure
===================================================================
diff -up /dev/null net-snmp-5.4.1/agent/mibgroup/hardware/sensors/dummy_sensors.c
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/agent/mibgroup/hardware/sensors/dummy_sensors.c	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1,60 @@
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include <net-snmp/agent/hardware/sensors.h>
+
+
+void netsnmp_sensor_arch_init( void ) {
+    /* Nothing to do */
+    DEBUGMSGTL(("sensors:arch", "Initialise Dummy Sensors module\n"));
+}
+
+int
+netsnmp_sensor_arch_load(netsnmp_cache *cache, void *vp) {
+    time_t now;
+    struct tm                  *tm;
+    netsnmp_sensor_info        *sp;
+
+    time(&now);
+    tm = localtime(&now);
+
+    DEBUGMSGTL(("sensors:arch", "Reload Dummy Sensors module\n"));
+
+    /* First pseudo-sensor - slowly-rising temperature */
+    sp = sensor_by_name( "minute", NETSNMP_SENSOR_TYPE_TEMPERATURE );
+    sp->value = tm->tm_min;
+    snprintf( sp->descr, 256, "Minute-based pseudo-sensor - slowly-rising temperature" );
+    sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+
+    /* Second pseudo-sensor - quickly-rising temperature */
+    sp = sensor_by_name( "second", NETSNMP_SENSOR_TYPE_TEMPERATURE );
+    sp->value = tm->tm_sec;
+    snprintf( sp->descr, 256, "Second-based pseudo-sensor - quickly-rising temperature" );
+    sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+
+    /* Third pseudo-sensor - annual fan speed */
+    sp = sensor_by_name( "year", NETSNMP_SENSOR_TYPE_RPM );
+    sp->value = tm->tm_year + 1900;
+    snprintf( sp->descr, 256, "RPM pseudo-sensor - annual fan speed" );
+    sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+
+    /* Fourth pseudo-sensor - daily voltage */
+    sp = sensor_by_name( "day", NETSNMP_SENSOR_TYPE_VOLTAGE_DC );
+    sp->value = tm->tm_mday-20;
+    snprintf( sp->descr, 256, "Day-based pseudo-sensor - positive or negative voltage" );
+    sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+
+    /* Fifth pseudo-sensor - monthly voltage */
+    sp = sensor_by_name( "month", NETSNMP_SENSOR_TYPE_VOLTAGE_DC );
+    sp->value = tm->tm_mon;
+    snprintf( sp->descr, 256, "Month-based pseudo-sensor - positive voltage" );
+    sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+
+    /* Sixth pseudo-sensor - annual daily something */
+    sp = sensor_by_name( "yday", NETSNMP_SENSOR_TYPE_OTHER );
+    sp->value = tm->tm_yday;
+    snprintf( sp->descr, 256, "Day-based pseudo-sensor - annual something" );
+    sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+
+    return 0;
+}
diff -up /dev/null net-snmp-5.4.1/agent/mibgroup/hardware/sensors/dummy_sensors.h
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/agent/mibgroup/hardware/sensors/dummy_sensors.h	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1 @@
+config_require(hardware/sensors/hw_sensors)
diff -up /dev/null net-snmp-5.4.1/agent/mibgroup/hardware/sensors.h
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/agent/mibgroup/hardware/sensors.h	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1,13 @@
+config_require(hardware/sensors/hw_sensors)
+
+#if defined(solaris)
+# if defined(HAVE_PICL_H)
+config_require(hardware/sensors/picld_sensors)
+# else
+config_require(hardware/sensors/kstat_sensors)
+# endif
+#else
+config_require(hardware/sensors/lmsensors_v3)
+#endif
+
+//config_require(hardware/sensors/dummy_sensors)
diff -up /dev/null net-snmp-5.4.1/agent/mibgroup/hardware/sensors/hw_sensors.c
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/agent/mibgroup/hardware/sensors/hw_sensors.c	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1,183 @@
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include <net-snmp/agent/hardware/sensors.h>
+
+
+extern NetsnmpCacheLoad netsnmp_sensor_arch_load;
+extern void             netsnmp_sensor_arch_init( void );
+static int  _sensor_load( void );
+static void _sensor_free( void );
+
+static int _sensorAutoUpdate = 0;   /* 0 means on-demand caching */
+static void _sensor_update_stats( unsigned int, void* );
+
+netsnmp_cache     *_sensor_cache     = NULL;
+netsnmp_container *_sensor_container = NULL;
+static int         _sensor_idx       = 0;
+
+void init_hw_sensors( void ) {
+
+    if ( _sensor_container )
+        return;   /* Already initialised */
+
+    DEBUGMSGTL(("sensors", "Initialise Hardware Sensors module\n"));
+
+    /*
+     * Define a container to hold the basic list of sensors
+     * The four LM-SENSOR-MIB containers will be created in
+     *  the relevant initialisation routine(s)
+     */
+    _sensor_container = netsnmp_container_find("sensorTable:table_container");
+    if ( NULL == _sensor_container ) {
+        snmp_log( LOG_ERR, "failed to create container for sensorTable");
+        return;
+    }
+    netsnmp_sensor_arch_init( );
+
+    /*
+     * If we're sampling the sensor information automatically,
+     *   then arrange for this to be triggered regularly.
+     *
+     * If we're not sampling these values regularly,
+     *   create a suitable cache handler instead.
+     */
+    if ( _sensorAutoUpdate ) {
+        DEBUGMSGTL(("sensors", "Reloading Hardware Sensors automatically (%d)\n",
+                               _sensorAutoUpdate));
+        snmp_alarm_register( _sensorAutoUpdate, SA_REPEAT,
+                             _sensor_update_stats, NULL );
+    }
+    else {
+        _sensor_cache = netsnmp_cache_create( 5, netsnmp_sensor_load,
+                                                 netsnmp_sensor_free, NULL, 0 );
+        DEBUGMSGTL(("sensors", "Reloading Hardware Sensors on-demand (%p)\n",
+                               _sensor_cache));
+    }
+}
+
+void shutdown_hw_sensors( void ) {
+    _sensor_free();
+}
+
+/*
+ *  Return the main sensor container
+ */
+netsnmp_container *get_sensor_container( void ) { return _sensor_container; }
+
+/*
+ *  Return the main sensor cache control structure (if defined)
+ */
+netsnmp_cache *get_sensor_cache( void ) { return _sensor_cache; }
+
+
+/*
+ * Wrapper routine for automatically updating sensor statistics
+ */
+void
+_sensor_update_stats( unsigned int clientreg, void *data )
+{
+    _sensor_free();
+    _sensor_load();
+}
+
+/*
+ * Wrapper routine for re-loading sensor statistics on demand
+ */
+int
+netsnmp_sensor_load( netsnmp_cache *cache, void *data )
+{
+    return _sensor_load();
+}
+
+/*
+ * Wrapper routine for releasing expired sensor statistics
+ */
+void
+netsnmp_sensor_free( netsnmp_cache *cache, void *data )
+{
+    _sensor_free();
+}
+
+
+/*
+ * Architecture-independent processing of loading sensor statistics
+ */
+static int
+_sensor_load( void )
+{
+    netsnmp_sensor_arch_load( NULL, NULL );
+}
+
+/*
+ * Architecture-independent release of sensor statistics
+ */
+static void
+_sensor_free( void )
+{
+    netsnmp_sensor_info *sp;
+
+    for (sp = CONTAINER_FIRST( _sensor_container );
+         sp;
+         sp = CONTAINER_NEXT(  _sensor_container, sp )) {
+
+         sp->flags &= ~ NETSNMP_SENSOR_FLAG_ACTIVE;
+    }
+}
+
+
+/*
+ * Retrieve a sensor entry by name,
+ *  or (optionally) insert a new one into the container
+ */
+netsnmp_sensor_info *
+sensor_by_name( char *name, int create_type )
+{
+    netsnmp_sensor_info *sp;
+
+    DEBUGMSGTL(("sensors:name", "Get sensor entry (%s)\n", name));
+
+    /*
+     *  Look through the list for a matching entry
+     */
+        /* .. or use a secondary index container ?? */
+    for (sp = CONTAINER_FIRST( _sensor_container );
+         sp;
+         sp = CONTAINER_NEXT(  _sensor_container, sp )) {
+
+        if ( !strcmp( name, sp->name ))
+            return sp;
+    }
+
+    /*
+     * Not found...
+     */
+    if ( create_type == NETSNMP_SENSOR_FIND_EXIST ) {
+        DEBUGMSGTL(("sensors:name", "No such sensor entry\n"));
+        return NULL;
+    }
+
+    /*
+     * ... so let's create a new one, using the type supplied
+     */
+    sp = SNMP_MALLOC_TYPEDEF( netsnmp_sensor_info );
+    if ( sp ) {
+        strcpy( sp->name, name );
+        sp->type = create_type;
+        /*
+         * Set up the index value.
+         *  
+         * All this trouble, just for a simple integer.
+         * Surely there must be a better way?
+         */
+        sp->idx.len  = 1;
+        sp->idx.oids = SNMP_MALLOC_TYPEDEF( oid );
+        sp->idx.oids[0] = ++_sensor_idx;
+    }
+
+    DEBUGMSGTL(("sensors:name", "Create sensor entry (type = %d, index = %d\n",
+                                 create_type, _sensor_idx));
+    CONTAINER_INSERT( _sensor_container, sp );
+    return sp;
+}
+
diff -up /dev/null net-snmp-5.4.1/agent/mibgroup/hardware/sensors/hw_sensors.h
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/agent/mibgroup/hardware/sensors/hw_sensors.h	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1 @@
+void init_hw_sensors( void );
diff -up /dev/null net-snmp-5.4.1/agent/mibgroup/hardware/sensors/kstat_sensors.c
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/agent/mibgroup/hardware/sensors/kstat_sensors.c	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1,161 @@
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include <net-snmp/agent/hardware/sensors.h>
+
+#include "util_funcs.h"
+#include <time.h>
+
+#include <kstat.h>
+#include </usr/platform/sun4u/include/sys/envctrl.h>
+
+void netsnmp_sensor_arch_init( void ) {
+    DEBUGMSGTL(("sensors:arch", "Initialise KStat Sensors module\n"));
+}
+
+
+int
+netsnmp_sensor_arch_load(netsnmp_cache *cache, void *vp) {
+    netsnmp_sensor_info        *sp;
+
+    int         i;
+    const char *fantypes[]={"CPU","PWR","AFB"};
+    char        name[ 256 ];
+
+    kstat_ctl_t    *kc;
+    kstat_t        *kp;
+    envctrl_fan_t  *fan_info;
+    envctrl_ps_t   *power_info;
+    envctrl_encl_t *enc_info;
+
+
+    DEBUGMSGTL(("sensors:arch", "Reload KStat Sensors module\n"));
+
+    kc = kstat_open();
+    if ( kc == 0) {
+        DEBUGMSGTL(("sensors:arch", "Couldn't open kstat\n"));
+        return 1;
+    }
+    
+
+    /*
+     * Retrieve fan information
+     */
+    kp = kstat_lookup( kc, ENVCTRL_MODULE_NAME, 0, ENVCTRL_KSTAT_FANSTAT);
+    if (( kp == 0 ) || (kstat_read( kc, kp, 0 ) == -1 )) {
+        DEBUGMSGTL(("sensors:arch", "No fan information\n"));
+    } else {
+        fan_info = (envctrl_fan_t *)kp->ks_data;        
+        for (i=0; i<kp->ks_ndata; i++) {
+            memset( name, 0, 256 );
+            snprintf( name, 255, "%s%d", fantypes[fan_info->type], fan_info->instance );
+
+            sp = sensor_by_name( name, NETSNMP_SENSOR_TYPE_RPM );
+            if ( sp ) {
+                sp->value = fan_info->fanspeed;
+                sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+                snprintf( sp->descr, 255, "fan type %s number %d",
+                          fantypes[fan_info->type], fan_info->instance );
+            }
+    
+            fan_info++;
+        }
+    }
+
+
+    /*
+     * Retrieve Power Supply information
+     */
+    kp = kstat_lookup( kc, ENVCTRL_MODULE_NAME, 0, ENVCTRL_KSTAT_PSNAME);
+    if (( kp == 0 ) || (kstat_read( kc, kp, 0 ) == -1 )) {
+        DEBUGMSGTL(("sensors:arch", "No PSU information\n"));
+    } else {
+        power_info = (envctrl_ps_t *)kp->ks_data;        
+        for (i=0; i<kp->ks_ndata; i++) {
+            memset( name, 0, 256 );
+            snprintf( name, 255, "PSU%d", power_info->instance );
+
+            sp = sensor_by_name( name, NETSNMP_SENSOR_TYPE_TEMPERATURE);
+            if ( sp ) {
+                sp->value = power_info->ps_tempr;
+                sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+                snprintf( sp->descr, 255, "power supply %d", power_info->instance );
+            }
+    
+            power_info++;
+        }
+    }
+
+
+    /*
+     * Retrieve Enclosure information
+     */
+    kp = kstat_lookup( kc, ENVCTRL_MODULE_NAME, 0, ENVCTRL_KSTAT_ENCL);
+    if (( kp == 0 ) || (kstat_read( kc, kp, 0 ) == -1 )) {
+        DEBUGMSGTL(("sensors:arch", "No enclosure information\n"));
+    } else {
+        enc_info = (envctrl_encl_t *)kp->ks_data;        
+        for (i=0; i<kp->ks_ndata; i++) {
+            /*
+             * The enclosure information covers several different types of sensor
+             */
+            switch ( enc_info->type ) {
+            case ENVCTRL_ENCL_FSP:
+                DEBUGMSGTL(("sensors:arch:detail", "Enclosure Front Panel\n"));
+                sp = sensor_by_name( "FSP", NETSNMP_SENSOR_TYPE_OTHER);
+                if ( sp ) {
+                    sp->value = enc_info->value;
+                    sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+                }
+                break;
+                
+            case ENVCTRL_ENCL_AMBTEMPR:
+                DEBUGMSGTL(("sensors:arch:detail", "Enclosure Ambient Temperature\n"));
+                sp = sensor_by_name( "Ambient", NETSNMP_SENSOR_TYPE_TEMPERATURE);
+                if ( sp ) {
+                    sp->value = enc_info->value;
+                    sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+                }
+                break;
+
+            case ENVCTRL_ENCL_CPUTEMPR:
+                DEBUGMSGTL(("sensors:arch:detail", "Enclosure CPU Temperature\n"));
+                memset( name, 0, 256 );
+                snprintf( name, 255, "CPU%d", enc_info->instance );
+                sp = sensor_by_name( name, NETSNMP_SENSOR_TYPE_TEMPERATURE);
+                if ( sp ) {
+                    sp->value = enc_info->value;
+                    sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+                    snprintf( sp->descr, 255, "CPU%d temperature", enc_info->instance );
+                }
+                break;
+
+            case ENVCTRL_ENCL_BACKPLANE4:
+                DEBUGMSGTL(("sensors:arch:detail", "Enclosure Backplane4\n"));
+                sp = sensor_by_name( "Backplane4", NETSNMP_SENSOR_TYPE_OTHER);
+                if ( sp ) {
+                    sp->value = enc_info->value;
+                    sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+                }
+                break;
+                
+            case ENVCTRL_ENCL_BACKPLANE8:
+                DEBUGMSGTL(("sensors:arch:detail", "Enclosure Backplane4\n"));
+                sp = sensor_by_name( "Backplane4", NETSNMP_SENSOR_TYPE_OTHER);
+                if ( sp ) {
+                    sp->value = enc_info->value;
+                    sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+                }
+                break;
+
+            default:    
+                DEBUGMSGTL(("sensors:arch:detail", "Unrecognised Enclosure entry (%d)n",
+                                                    enc_info->type));
+            }
+
+            enc_info++;
+        }
+    }
+
+    return 0;
+}
diff -up /dev/null net-snmp-5.4.1/agent/mibgroup/hardware/sensors/kstat_sensors.h
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/agent/mibgroup/hardware/sensors/kstat_sensors.h	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1 @@
+config_require(hardware/sensors/hw_sensors)
diff -up /dev/null net-snmp-5.4.1/agent/mibgroup/hardware/sensors/lmsensors_v2.c
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/agent/mibgroup/hardware/sensors/lmsensors_v2.c	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1,75 @@
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include <net-snmp/agent/hardware/sensors.h>
+
+#include "util_funcs.h"
+#include <time.h>
+#include <sensors/sensors.h>
+
+void netsnmp_sensor_arch_init( void ) {
+    FILE *fp = fopen("/etc/sensors.conf", "r");
+    DEBUGMSGTL(("sensors:arch", "Initialise LM Sensors module\n"));
+    sensors_init( fp );
+}
+
+int
+netsnmp_sensor_arch_load(netsnmp_cache *cache, void *vp) {
+    netsnmp_sensor_info        *sp;
+    const sensors_chip_name    *chip;
+    const sensors_feature_data *data;
+    int             chip_nr = 0;
+
+    DEBUGMSGTL(("sensors:arch", "Reload LM Sensors module\n"));
+    while ((chip = sensors_get_detected_chips(&chip_nr))) {
+	int             a = 0;
+	int             b = 0;
+
+        while ((data = sensors_get_all_features(*chip, &a, &b))) {
+            DEBUGMSGTL(("sensors:arch:detail", "get_all_features (%d, %d)\n", a, b));
+            char           *label = NULL;
+            double          val;
+            int             type = NETSNMP_SENSOR_TYPE_OTHER;
+
+            if ((data->mode & SENSORS_MODE_R) &&
+                (data->mapping == SENSORS_NO_MAPPING) &&
+                !sensors_get_label(*chip, data->number, &label) &&
+                !sensors_get_feature(*chip, data->number, &val)) {
+
+                DEBUGMSGTL(("sensors:arch:detail", "%s = %f\n", label, val));
+                /*
+                 * Determine the type of sensor from the description.
+                 *
+                 * If the text being looked for below is not in the label of a
+                 * given sensor (e.g., the temp1 sensor has been labeled 'CPU'
+                 * rather than 'CPU temp') it will be categorised as OTHER.
+                 */
+                if (strstr(label, "V")) {
+                    type = NETSNMP_SENSOR_TYPE_VOLTAGE_DC;
+                }
+                if (strstr(label, "fan") || strstr(label, "Fan")) {
+                    type = NETSNMP_SENSOR_TYPE_RPM;
+                }
+                if (strstr(label, "temp") || strstr(label, "Temp")) {
+                    type = NETSNMP_SENSOR_TYPE_TEMPERATURE;
+                }
+
+                /*
+                 * Use this type to create a new sensor entry
+                 *  (inserting it in the appropriate sub-containers)
+                 */
+                sp = sensor_by_name( label, type );
+                if ( sp ) {
+                    sp->value = val;
+                    sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+                }
+            }
+	    if (label) {
+		free(label);
+		label = NULL;
+	    }
+        } /* end while data */
+    } /* end while chip */
+
+    return 0;
+}
diff -up /dev/null net-snmp-5.4.1/agent/mibgroup/hardware/sensors/lmsensors_v2.h
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/agent/mibgroup/hardware/sensors/lmsensors_v2.h	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1 @@
+config_require(hardware/sensors/hw_sensors)
diff -up /dev/null net-snmp-5.4.1/agent/mibgroup/hardware/sensors/lmsensors_v3.c
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/agent/mibgroup/hardware/sensors/lmsensors_v3.c	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1,101 @@
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include <net-snmp/agent/hardware/sensors.h>
+
+#include "util_funcs.h"
+#include <time.h>
+#include <sensors/sensors.h>
+
+
+void netsnmp_sensor_arch_init( void ) {
+    FILE *fp = fopen("/etc/sensors.conf", "r");
+    DEBUGMSGTL(("sensors:arch", "Initialise v3 LM Sensors module\n"));
+    sensors_init( fp );
+}
+
+int
+netsnmp_sensor_arch_load(netsnmp_cache *cache, void *vp) {
+    netsnmp_sensor_info        *sp;
+    const sensors_chip_name    *chip;
+    const sensors_feature      *data;
+    const sensors_subfeature   *data2;
+    int             chip_nr = 0;
+
+    DEBUGMSGTL(("sensors:arch", "Reload v3 LM Sensors module\n"));
+    while ((chip = sensors_get_detected_chips( NULL, &chip_nr))) {
+	int             a = 0;
+
+        while ((data = sensors_get_features( chip, &a))) {
+            DEBUGMSGTL(("sensors:arch:detail", "get_features (%s, %d)\n", data->name, data->number));
+	    int             b = 0;
+ 
+
+            while ((data2 = sensors_get_all_subfeatures( chip, data, &b))) {
+                char           *label = NULL;
+                double          val;
+                int             type = NETSNMP_SENSOR_TYPE_OTHER;
+
+                DEBUGMSGTL(("sensors:arch:detail", "  get_subfeatures (%s, %d)\n", data2->name, data2->number));
+                /*
+                 * Check the type of this subfeature,
+                 *   concentrating on the main "input" measurements.
+                 */
+                switch ( data2->type ) {
+                case SENSORS_SUBFEATURE_IN_INPUT:
+                    type = NETSNMP_SENSOR_TYPE_VOLTAGE_DC;
+                    break;
+                case SENSORS_SUBFEATURE_FAN_INPUT:
+                    type = NETSNMP_SENSOR_TYPE_RPM;
+                    break;
+                case SENSORS_SUBFEATURE_TEMP_INPUT:
+                    type = NETSNMP_SENSOR_TYPE_TEMPERATURE;
+                    break;
+                case SENSORS_SUBFEATURE_VID:
+                    type = NETSNMP_SENSOR_TYPE_VOLTAGE_DC;
+                    break;
+                default:
+                    /* Skip everything other than these basic sensor features - ??? */
+                    DEBUGMSGTL(("sensors:arch:detail", "  Skip type %x\n", data2->type));
+                    continue;
+                }
+            
+                /*
+                 * Get the name and value of this subfeature
+                 */
+/*
+                if (!(label = sensors_get_label(chip, data))) {
+                    DEBUGMSGTL(("sensors:arch:detail", "  Can't get name (%s)\n", label));
+                    continue;
+                }
+                if (sensors_get_value(chip, data2->number, &val) < 0) {
+                    DEBUGMSGTL(("sensors:arch:detail", "  Can't get value (%f)\n", val));
+                    continue;
+                }
+*/
+                if (!(label = sensors_get_label(chip, data)) ||
+                     (sensors_get_value(chip, data2->number, &val) < 0)) {
+                    DEBUGMSGTL(("sensors:arch:detail", "  Can't get name/value (%s, %f)\n", label, val));
+                    continue;
+                }
+                DEBUGMSGTL(("sensors:arch:detail", "%s = %f\n", label, val));
+
+                /*
+                 * Use this type to create a new sensor entry
+                 *  (inserting it in the appropriate sub-containers)
+                 */
+                sp = sensor_by_name( label, type );
+                if ( sp ) {
+                    sp->value = val;
+                    sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+                }
+	        if (label) {
+		    free(label);
+		    label = NULL;
+	        }
+            } /* end while data2 */
+        } /* end while data */
+    } /* end while chip */
+
+    return 0;
+}
diff -up /dev/null net-snmp-5.4.1/agent/mibgroup/hardware/sensors/lmsensors_v3.h
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/agent/mibgroup/hardware/sensors/lmsensors_v3.h	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1 @@
+config_require(hardware/sensors/hw_sensors)
diff -up /dev/null net-snmp-5.4.1/agent/mibgroup/hardware/sensors/picld_sensors.c
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/agent/mibgroup/hardware/sensors/picld_sensors.c	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1,341 @@
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include <net-snmp/agent/hardware/sensors.h>
+
+#include "util_funcs.h"
+#include <time.h>
+
+#include <picl.h>
+#include </usr/platform/sun4u/include/sys/envctrl.h>
+
+void netsnmp_sensor_arch_init( void ) {
+    DEBUGMSGTL(("sensors:arch", "Initialise PICLd Sensors module\n"));
+    picl_initialize();
+}
+
+
+/*
+ * Handle a numeric-valued sensor
+ */
+static int
+read_num_sensor( picl_nodehdl_t childh, char *propval, float *value )
+{
+    picl_nodehdl_t  sensorh;
+    picl_propinfo_t sensor_info;
+    picl_errno_t    error_code;
+
+    union valu {
+        char buf[PICL_PROPSIZE_MAX];
+        uint32_t us4;
+        uint16_t us2;
+        int32_t is4;
+        int16_t is2;
+        float f;
+    } val;
+
+    /*
+     *  Retrieve the specified sensor information and value
+     */
+    error_code = picl_get_propinfo_by_name(childh, propval, &sensor_info, &sensorh);
+    if ( error_code != PICL_SUCCESS ) {
+        DEBUGMSGTL(("sensors:arch:detail", "sensor info lookup failed (%d)\n",
+                                            error_code));
+        return( error_code );
+    }
+
+    error_code = picl_get_propval(sensorh, &val.buf, sensor_info.size);
+    if ( error_code != PICL_SUCCESS ) {
+        DEBUGMSGTL(("sensors:arch:detail", "sensor value lookup failed (%d)\n",
+                                            error_code));
+        return( error_code );
+    }
+
+    /*
+     *  Check the validity (type and size) of this value
+     */
+    if ( sensor_info.type == PICL_PTYPE_FLOAT ) {
+        *value = val.f;
+    } else if ( sensor_info.type == PICL_PTYPE_UNSIGNED_INT ) {
+        /* 16-bit or 32-bit unsigned integers */
+        if ( sensor_info.size == 2 ) {
+            *value = val.us2;
+        } else if ( sensor_info.size == 4 ) { 
+            *value = val.us4;
+        } else {
+            DEBUGMSGTL(("sensors:arch:detail", "unsigned integer (%d bit)\n",
+                                                sensor_info.size * 8));
+            return PICL_FAILURE;
+        }
+    } else if ( sensor_info.type == PICL_PTYPE_INT ) {
+        /* 16-bit or 32-bit signed integers */
+        if ( sensor_info.size == 2 ) {
+            *value = val.is2;
+        } else if ( sensor_info.size == 4 ) { 
+            *value = val.is4;
+        } else {
+            DEBUGMSGTL(("sensors:arch:detail", "signed integer (%d bit)\n",
+                                                sensor_info.size * 8));
+            return PICL_FAILURE;
+        }
+    } else {
+        DEBUGMSGTL(("sensors:arch:detail", "unrecognised type (%d)\n",
+                                            sensor_info.type));
+        return PICL_FAILURE;
+    }
+
+    return error_code;
+}
+
+static int
+process_num_sensor( picl_nodehdl_t childh, char *propname, char *propval, int typ )
+{
+    netsnmp_sensor_info        *sp;
+    float                       value;
+    picl_errno_t    error_code;
+
+    sp = sensor_by_name( propname, typ );
+    if ( !sp ) {
+         return -1;
+    }
+
+    error_code = read_num_sensor( childh, propval, &value );
+    if ( error_code == PICL_SUCCESS ) {
+        sp->value = value;
+        sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+    } else {
+        DEBUGMSGTL(("sensors:arch:detail", "Failed to read %s sensor value (%d)\n",
+                                            propname, error_code));
+        return -1;
+    }
+    return 0;
+}
+
+
+
+/*
+ *    Handle an enumeration-valued sensor
+ */
+char *switch_settings[] = { "OFF","ON","NORMAL","LOCKED",
+                            "UNKNOWN","DIAG","SECURE",
+                            NULL };
+char *led_settings[]    = { "OFF","ON","BLINK",
+                            NULL };
+char *i2c_settings[]    = { "OK",
+                            NULL };
+
+static int
+read_enum_sensor( picl_nodehdl_t childh, float *value, char **options )
+{
+    picl_nodehdl_t  sensorh;
+    picl_propinfo_t sensor_info;
+    picl_errno_t    error_code;
+    char            state[PICL_PROPSIZE_MAX];
+    int             i;
+
+    /*
+     *  Retrieve the specified sensor information and value
+     */
+    error_code = picl_get_propinfo_by_name(childh, "State", &sensor_info, &sensorh);
+    if ( error_code != PICL_SUCCESS ) {
+        DEBUGMSGTL(("sensors:arch:detail", "sensor info lookup failed (%d)\n",
+                                            error_code));
+        return( error_code );
+    }
+
+    error_code = picl_get_propval(sensorh, state, sensor_info.size);
+    if ( error_code != PICL_SUCCESS ) {
+        DEBUGMSGTL(("sensors:arch:detail", "sensor value lookup failed (%d)\n",
+                                            error_code));
+        return( error_code );
+    }
+
+    /*
+     * Try to find a matching entry in the list of options.
+     * Note that some platforms may use upper or lower case
+     *   versions of these enumeration values
+     *  (so the checks are case insensitive)
+     */
+    *value = 99;    /* Dummy value */
+    for ( i=0;  options[i] != NULL; i++ ) {
+        if (strncasecmp(state, options[i], strlen(options[i])) == 0) {
+            *value = i;
+            return 0;
+        }
+    }
+    
+    DEBUGMSGTL(("sensors:arch:detail", "Enumeration state %s not matched\n",
+                                        state));
+    return 0;  /* Or an error ? */
+}
+
+static int
+process_enum_sensor( picl_nodehdl_t childh, char *propname, int typ, char **options )
+{
+    netsnmp_sensor_info        *sp;
+    float                       value;
+    picl_errno_t    error_code;
+
+    sp = sensor_by_name( propname, typ );
+    if ( !sp ) {
+         return -1;
+    }
+
+    error_code = read_enum_sensor( childh, &value, options );
+    if ( error_code == PICL_SUCCESS ) {
+        sp->value = value;
+        sp->flags|= NETSNMP_SENSOR_FLAG_ACTIVE;
+    } else {
+        DEBUGMSGTL(("sensors:arch:detail", "Failed to read %s sensor value (%d)\n",
+                                            propname, error_code));
+        return -1;
+    }
+    return 0;
+}
+static int
+process_enum_sensor( picl_nodehdl_t childh, char *propname, int typ, char **options )
+{
+    return 0;
+}
+
+
+
+/*
+ *  Recursively walk through the tree of sensors
+ */
+static int
+process_sensors( int level, picl_nodehdl_t nodeh ) {
+    picl_nodehdl_t childh, nexth;
+    char           propname[  PICL_PROPNAMELEN_MAX  ];
+    char           propclass[ PICL_CLASSNAMELEN_MAX ];
+    picl_errno_t   error_code;
+
+    level++;
+    DEBUGMSGTL(("sensors:arch:detail", "process_sensors - level %d\n", level));
+
+    /* Look up the first child node at this level */
+    error_code = pick_get_propval_by_name( nodeh, PICL_PROP_CHILD,
+                                           &childh, sizeof(childh));
+    if ( error_code != PICL_SUCCESS ) {
+        DEBUGMSGTL(("sensors:arch:detail", "Failed to get first child node (%d)\n",
+                                            error_code));
+        return( error_code );
+    }
+
+    /* Step through the child nodes, retrieving the name and class of each one */
+    while ( error_code == PICL_SUCCESS ) {
+        error_code = pick_get_propval_by_name( childh, PICL_PROP_NAME,
+                                               propname, sizeof(propname)-1);
+        if ( error_code != PICL_SUCCESS ) {
+            /* The Node With No Name */
+            DEBUGMSGTL(("sensors:arch:detail", "get property name failed (%d)\n",
+                                                error_code));
+            return( error_code );
+        }
+
+        error_code = pick_get_propval_by_name( childh, PICL_PROP_CLASSNAME,
+                                               propclass, sizeof(propclass)-1);
+        if ( error_code != PICL_SUCCESS ) {
+            /* The Classless Society */
+            DEBUGMSGTL(("sensors:arch:detail", "get property class failed (%d)\n",
+                                                error_code));
+            return( error_code );
+        }
+
+        DEBUGMSGTL(("sensors:arch:detail", "Name: %s, Class %s\n",
+                                            propname, propclass ));
+
+
+        /*
+         *  Three classes represent further groups of sensors, etc.
+         *  Call 'process_sensors' recursively to handle this next level
+         */
+        if (( strstr( propclass, "picl"    )) ||
+            ( strstr( propclass, "frutree" )) ||
+            ( strstr( propclass, "obp"     ))) {
+            process_sensors( level, childh );
+        }
+        /*
+         *  Otherwise retrieve the value appropriately based on the
+         *     class of the sensor.
+         *
+         *  We need to specify the name of the PICL property to retrieve
+         *     for this class of sensor, and the Net-SNMP sensor type.
+         */
+        else if ( strstr( propclass, "fan-tachometer" )) {
+            process_num_sensor( childh, propname, "AtoDSensorValue",
+                                                   NETSNMP_SENSOR_TYPE_RPM );
+        } else if ( strstr( propclass, "fan" )) {
+            process_num_sensor( childh, propname, "Speed",
+                                                   NETSNMP_SENSOR_TYPE_RPM );
+        } else if ( strstr( propclass, "temperature-sensor" )) {
+            process_num_sensor( childh, propname, "Temperature",
+                                                   NETSNMP_SENSOR_TYPE_TEMPERATURE );
+        } else if ( strstr( propclass, "voltage-sensor" )) {
+            process_num_sensor( childh, propname, "Voltage",
+                                          /* ?? */ NETSNMP_SENSOR_TYPE_VOLTAGE_DC );
+        } else if ( strstr( propclass, "digital-sensor" )) {
+            process_num_sensor( childh, propname, "AtoDSensorValue",
+                                          /* ?? */ NETSNMP_SENSOR_TYPE_VOLTAGE_DC );
+            /*
+             * Enumeration-valued sensors use a fixed PICL property ("State"),
+             *   but take a list of the values appropriate for that sensor,
+             *   as well as the Net-SNMP sensor type.
+             */
+        } else if ( strstr( propclass, "switch" )) {
+            process_enum_sensor( childh, propname, NETSNMP_SENSOR_TYPE_OTHER,
+                                                   switch_settings );
+        } else if ( strstr( propclass, "led" )) {
+            process_enum_sensor( childh, propname, NETSNMP_SENSOR_TYPE_OTHER,
+                                                   led_settings );
+        } else if ( strstr( propclass, "i2c" )) {
+            process_enum_sensor( childh, propname, NETSNMP_SENSOR_TYPE_BOOLEAN, /* ?? */
+                                                   i2c_settings );
+        } else {
+            /* Skip other classes of sensor */
+            DEBUGMSGTL(("sensors:arch:detail", "Skipping class %s\n", propclass ));
+        }
+
+        /*
+         *  Move on to the next child node at the current level (if any)
+         */
+        error_code = pick_get_propval_by_name( childh, PICL_PROP_PEER,
+                                               &nexth, sizeof(nexth));
+        if ( error_code != PICL_SUCCESS ) {
+            /* That's All Folks! */
+            return (( error_code == PICL_PROPNOTFOUND )
+                          ? PICL_SUCCESS : error_code );
+        }
+        childh = nexth;
+    }
+    
+    return error_code;
+}
+
+
+int
+netsnmp_sensor_arch_load(netsnmp_cache *cache, void *vp) {
+    int               error_code;
+    picl_nodehdl_t    rooth;
+
+    DEBUGMSGTL(("sensors:arch", "Reload PICLd Sensors module\n"));
+
+    error_code = picl_get_root(&rooth);
+    if ( error_code != PICL_SUCCESS) {
+        DEBUGMSGTL(("sensors:arch", "Couldn't get root node (error %d)\n", error_code));
+        return 1;
+    }
+
+    error_code = process_sensors(0, rooth);
+    if ( error_code != 255 )
+        if ( error_code != 7 )  /* ignore PICL_PROPNOTFOUND error */
+            DEBUGMSGTL(("sensors:arch", "Internal PICLd problem (error %d)\n", error_code));
+
+    return 0;
+}
+
+void netsnmp_sensor_arch_shutdown( void ) {
+    DEBUGMSGTL(("sensors:arch", "Shutdown PicLD Sensors module\n"));
+    picl_shutdown();
+}
+
diff -up /dev/null net-snmp-5.4.1/agent/mibgroup/hardware/sensors/picld_sensors.h
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/agent/mibgroup/hardware/sensors/picld_sensors.h	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1 @@
+config_require(hardware/sensors/hw_sensors)
diff -up /dev/null net-snmp-5.4.1/agent/mibgroup/ucd-snmp/lmsensorsMib.c
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/agent/mibgroup/ucd-snmp/lmsensorsMib.c	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1,205 @@
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include <net-snmp/agent/hardware/sensors.h>
+#include "ucd-snmp/lmsensorsMib.h"
+
+netsnmp_container *sensorContainer = NULL;
+
+void initialize_lmSensorsTable(const char *tableName, oid *tableOID,
+                               netsnmp_container_op *filter, int mult );
+
+int _sensor_filter_temp( netsnmp_container *c, const void *v );
+int _sensor_filter_fan(  netsnmp_container *c, const void *v );
+int _sensor_filter_volt( netsnmp_container *c, const void *v );
+int _sensor_filter_misc( netsnmp_container *c, const void *v );
+
+static oid lmTempSensorsTable_oid[]   = {1,3,6,1,4,1,2021,13,16,2};
+static oid lmFanSensorsTable_oid[]    = {1,3,6,1,4,1,2021,13,16,3};
+static oid lmVoltSensorsTable_oid[]   = {1,3,6,1,4,1,2021,13,16,4};
+static oid lmMiscSensorsTable_oid[]   = {1,3,6,1,4,1,2021,13,16,5};
+            /* All the tables have the same length root OID */
+size_t     lmSensorsTables_oid_len = OID_LENGTH(lmMiscSensorsTable_oid);
+
+
+/* Initialise the LM Sensors MIB module */
+void
+init_lmsensorsMib(void)
+{
+    DEBUGMSGTL(("ucd-snmp/lmsensorsMib","Initializing LM-SENSORS-MIB tables\n"));
+
+    /* 
+     * Initialise the four LM-SENSORS-MIB tables
+     *
+     * They are almost identical, so we can use the same registration code.
+     */
+    initialize_lmSensorsTable( "lmTempSensorsTable", lmTempSensorsTable_oid,
+                                _sensor_filter_temp, 1000 );  /* MIB asks for mC */
+    initialize_lmSensorsTable( "lmFanSensorsTable",  lmFanSensorsTable_oid,
+                                _sensor_filter_fan,  1);
+    initialize_lmSensorsTable( "lmVoltSensorsTable", lmVoltSensorsTable_oid,
+                                _sensor_filter_volt, 1000 );  /* MIB asks for mV */
+    initialize_lmSensorsTable( "lmMiscSensorsTable", lmMiscSensorsTable_oid,
+                                _sensor_filter_misc, 1 );
+}
+
+/*
+ * Common initialisation code, used for setting up all four tables
+ */
+void
+initialize_lmSensorsTable(const char *tableName, oid *tableOID,
+                          netsnmp_container_op *filter, int mult )
+{
+    netsnmp_handler_registration    *reg;
+    netsnmp_table_registration_info *table_info;
+    netsnmp_cache     *cache;
+    netsnmp_container *container;
+
+    /*
+     * Ensure the HAL sensors module has been initialised,
+     *   and retrieve the main sensors container.
+     * This table will then be registered using a filter on this container.
+     */
+    sensorContainer = get_sensor_container();
+    if ( !sensorContainer ) {
+        init_hw_sensors( );
+        sensorContainer = get_sensor_container();
+    }
+    container = netsnmp_container_find("sensorTable:table_container");
+    container->insert_filter = filter;
+    netsnmp_container_add_index( sensorContainer, container );
+
+
+    /*
+     * Create a basic registration structure for the table
+     */
+    reg = netsnmp_create_handler_registration(
+               tableName, lmSensorsTables_handler,
+               tableOID,  lmSensorsTables_oid_len, HANDLER_CAN_RONLY
+              );
+
+    /*
+     * Register the table using the filtered container
+     * Include an indicator of any scaling to be applied to the sensor value
+     */
+    reg->my_reg_void = (void *)mult;
+    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
+    netsnmp_table_helper_add_indexes(table_info, ASN_INTEGER, 0);
+    table_info->min_column = COLUMN_LMSENSORS_INDEX;
+    table_info->max_column = COLUMN_LMSENSORS_VALUE;
+    netsnmp_container_table_register( reg, table_info, container, 0 );
+
+    /*
+     * If the HAL sensors module was configured as an on-demand caching
+     *  module (rather than being automatically loaded regularly),
+     *  then ensure this table makes use of that cache.
+     */
+    cache = get_sensor_cache();
+    if ( cache ) {
+        netsnmp_inject_handler_before( reg, netsnmp_cache_handler_get( cache ),
+                                            "table_container");
+    }
+
+}
+
+
+/*
+ *  Container filters for the four tables
+ *
+ *  Used to ensure that sensor entries appear in the appropriate table.
+ */
+int _sensor_filter_temp( netsnmp_container *c, const void *v ) {
+    const netsnmp_sensor_info *sp = (const netsnmp_sensor_info *)v;
+    /* Only matches temperature sensors */
+    return (( sp->type == NETSNMP_SENSOR_TYPE_TEMPERATURE ) ? 0 : 1 );
+}
+
+int _sensor_filter_fan( netsnmp_container *c, const void *v ) {
+    const netsnmp_sensor_info *sp = (const netsnmp_sensor_info *)v;
+    /* Only matches fan sensors */
+    return (( sp->type == NETSNMP_SENSOR_TYPE_RPM ) ? 0 : 1 );
+}
+
+int _sensor_filter_volt( netsnmp_container *c, const void *v ) {
+    const netsnmp_sensor_info *sp = (const netsnmp_sensor_info *)v;
+    /* Only matches voltage sensors (AC or DC) */
+    return ((( sp->type == NETSNMP_SENSOR_TYPE_VOLTAGE_DC ) ||
+             ( sp->type == NETSNMP_SENSOR_TYPE_VOLTAGE_AC )) ? 0 : 1 );
+}
+
+int _sensor_filter_misc( netsnmp_container *c, const void *v ) {
+    const netsnmp_sensor_info *sp = (const netsnmp_sensor_info *)v;
+    /* Matches everything except temperature, fan or voltage sensors */
+    return ((( sp->type == NETSNMP_SENSOR_TYPE_TEMPERATURE ) ||
+             ( sp->type == NETSNMP_SENSOR_TYPE_RPM         ) ||
+             ( sp->type == NETSNMP_SENSOR_TYPE_VOLTAGE_DC  ) ||
+             ( sp->type == NETSNMP_SENSOR_TYPE_VOLTAGE_AC  )) ? 1 : 0 );
+}
+
+
+/*
+ * Handle requests for any of the four lmXxxxSensorsTables 
+ *
+ * This is possible because all the table share the
+ *  same structure and behaviour.
+ */
+int
+lmSensorsTables_handler(
+    netsnmp_mib_handler               *handler,
+    netsnmp_handler_registration      *reginfo,
+    netsnmp_agent_request_info        *reqinfo,
+    netsnmp_request_info              *requests) {
+
+    netsnmp_request_info       *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_sensor_info        *sensor_info;
+    int mult  = (int)reginfo->my_reg_void;
+
+    DEBUGMSGTL(( "ucd-snmp/lmsensorsMib","lmSensorsTables_handler - root: "));
+    DEBUGMSGOID(("ucd-snmp/lmsensorsMib", reginfo->rootoid, reginfo->rootoid_len));
+    DEBUGMSG((   "ucd-snmp/lmsensorsMib",", mode %d\n", reqinfo->mode ));
+    /*
+     * This is a read-only table, so we only need to handle GET requests.
+     *    (The container helper converts GETNEXT->GET requests automatically).
+     */
+    switch (reqinfo->mode) {
+    case MODE_GET:
+        for (request=requests; request; request=request->next) {
+            sensor_info = (netsnmp_sensor_info *)
+                            netsnmp_container_table_extract_context(request);
+            if ( !sensor_info ) {
+                netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHINSTANCE);
+                continue;
+            }
+    
+            table_info   =  netsnmp_extract_table_info(request);
+            switch (table_info->colnum) {
+            case COLUMN_LMSENSORS_INDEX:
+                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
+                                            sensor_info->idx.oids[0]);
+                break;
+            case COLUMN_LMSENSORS_DEVICE:
+                if ( sensor_info->descr[0] != '\0' ) {
+                    snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
+                                              sensor_info->descr, strlen(sensor_info->descr));
+                } else {
+                    snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
+                                              sensor_info->name,  strlen(sensor_info->name));
+                }
+                break;
+            case COLUMN_LMSENSORS_VALUE:
+                /* Multiply the value by the appropriate scaling factor for this table */
+                snmp_set_var_typed_integer( request->requestvb, ASN_GAUGE,
+                                            (int)(mult*sensor_info->value));
+                break;
+            default:
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_NOSUCHOBJECT);
+                break;
+            }
+        }
+        break;
+
+    }
+    return SNMP_ERR_NOERROR;
+}
diff -up /dev/null net-snmp-5.4.1/agent/mibgroup/ucd-snmp/lmsensorsMib.h
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/agent/mibgroup/ucd-snmp/lmsensorsMib.h	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1,23 @@
+#ifndef LM_SENSORS_MIB_H
+#define LM_SENSORS_MIB_H
+
+config_require(hardware/sensors)
+config_add_mib(LM-SENSORS-MIB)
+
+/* function declarations */
+void init_lmsensorsMib(void);
+
+/*
+ * Handler and Column definitions for lmXxxxSensorsTable
+ *
+ * Note that the same handler (and hence the same
+ *  column identifiers) are used for all four tables.
+ * This is possible because all the table share the
+ *  same structure and behaviour.
+ */
+Netsnmp_Node_Handler lmSensorsTables_handler;
+#define COLUMN_LMSENSORS_INDEX		1
+#define COLUMN_LMSENSORS_DEVICE		2
+#define COLUMN_LMSENSORS_VALUE		3
+
+#endif /* LM_SENSORS_MIB_H */
diff -up net-snmp-5.4.1/configure.backup_patch_15 net-snmp-5.4.1/configure
--- net-snmp-5.4.1/configure.backup_patch_15	2008-07-25 12:53:39.000000000 +0200
+++ net-snmp-5.4.1/configure	2008-07-25 12:53:46.000000000 +0200
@@ -31030,7 +31030,7 @@ fi
 fi
 
 # LM-SENSORS-MIB support
-echo " $module_list " | grep " ucd-snmp/lmSensors " > /dev/null
+echo " $module_list " | $GREP -i "ucd-snmp/lmsensor" > /dev/null
 if test $? -eq 0 ; then
         echo "$as_me:$LINENO: checking for sensors support" >&5
 echo $ECHO_N "checking for sensors support... $ECHO_C" >&6
diff -up net-snmp-5.4.1/configure.in.backup_patch_15 net-snmp-5.4.1/configure.in
--- net-snmp-5.4.1/configure.in.backup_patch_15	2008-07-25 12:53:39.000000000 +0200
+++ net-snmp-5.4.1/configure.in	2008-07-25 12:53:46.000000000 +0200
@@ -2880,7 +2880,7 @@ if test $? -eq 0 ; then
 fi
 
 # LM-SENSORS-MIB support
-echo " $module_list " | grep " ucd-snmp/lmSensors " > /dev/null
+echo " $module_list " | $GREP -i "ucd-snmp/lmsensor" > /dev/null
 if test $? -eq 0 ; then
         AC_MSG_CHECKING([for sensors support])
         case $target_os in
diff -up /dev/null net-snmp-5.4.1/include/net-snmp/agent/hardware/sensors.h
--- /dev/null	2008-07-23 14:59:56.660004489 +0200
+++ net-snmp-5.4.1/include/net-snmp/agent/hardware/sensors.h	2008-07-25 12:53:46.000000000 +0200
@@ -0,0 +1,48 @@
+/*
+ * Hardware Abstraction Layer - Sensors module
+ *
+ * Public interface
+ */
+
+#define NETSNMP_SENSOR_TYPE_OTHER       1
+#define NETSNMP_SENSOR_TYPE_VOLTAGE_AC  3
+#define NETSNMP_SENSOR_TYPE_VOLTAGE_DC  4
+#define NETSNMP_SENSOR_TYPE_CURRENT     5
+#define NETSNMP_SENSOR_TYPE_POWER       6
+#define NETSNMP_SENSOR_TYPE_FREQUENCY   7
+#define NETSNMP_SENSOR_TYPE_TEMPERATURE 8
+#define NETSNMP_SENSOR_TYPE_HUMIDITY    9
+#define NETSNMP_SENSOR_TYPE_RPM        10
+#define NETSNMP_SENSOR_TYPE_VOLUME     11
+#define NETSNMP_SENSOR_TYPE_BOOLEAN    12
+
+
+#define NETSNMP_SENSOR_FLAG_ACTIVE     0x01
+#define NETSNMP_SENSOR_FLAG_NAVAIL     0x02
+#define NETSNMP_SENSOR_FLAG_BROKEN     0x04
+#define NETSNMP_SENSOR_FLAG_DISABLE    0x08
+
+#define NETSNMP_SENSOR_MASK_STATUS     0x06  /* NAVAIL|BROKEN */
+
+
+#define NETSNMP_SENSOR_FIND_CREATE     1   /* or use one of the sensor type values */
+#define NETSNMP_SENSOR_FIND_EXIST      0
+
+typedef struct netsnmp_sensor_info_s netsnmp_sensor_info;
+struct netsnmp_sensor_info_s {
+
+    netsnmp_index  idx;
+    /* int  idx; */
+    char  name[256];
+    
+    int   type;
+    float value;
+    char  descr[256];
+    long  flags;
+};
+
+netsnmp_container   *get_sensor_container( void );
+netsnmp_cache       *get_sensor_cache( void );
+netsnmp_sensor_info *sensor_by_name( char *, int );
+NetsnmpCacheLoad     netsnmp_sensor_load;
+NetsnmpCacheFree     netsnmp_sensor_free;
