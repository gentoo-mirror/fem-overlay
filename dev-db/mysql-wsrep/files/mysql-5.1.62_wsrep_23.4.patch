=== modified file 'BUILD/SETUP.sh'
--- old/BUILD/SETUP.sh	2011-06-30 15:37:13 +0000
+++ new/BUILD/SETUP.sh	2011-11-15 21:01:57 +0000
@@ -192,7 +192,7 @@
 alpha_cflags="$check_cpu_cflags -Wa,-m$cpu_flag"
 amd64_cflags="$check_cpu_cflags"
 amd64_cxxflags=""  # If dropping '--with-big-tables', add here  "-DBIG_TABLES"
-pentium_cflags="$check_cpu_cflags"
+pentium_cflags="$check_cpu_cflags -m32"
 pentium64_cflags="$check_cpu_cflags -m64"
 ppc_cflags="$check_cpu_cflags"
 sparc_cflags=""
@@ -228,6 +228,20 @@
   echo "$CXX" | grep "ccache" > /dev/null || CXX="ccache $CXX"
 fi
 
+################################################################################
+## WSREP SETUP                                                               ##
+################################################################################
+MYSQL_SOCKET_PATH=${MYSQL_SOCKET_PATH:-"/var/lib/mysql/mysql.sock"}
+wsrep_configs="$SSL_LIBRARY $wsrep_configs "\
+"--with-wsrep "\
+"--with-plugins=innobase,innodb_plugin "\
+"--with-plugin-partition "\
+"--with-innodb-disallow-writes "
+
+wsrep_cflags="$wsrep_cflags -DWSREP_PROC_INFO -DMYSQL_MAX_VARIABLE_VALUE_LEN=2048"
+if test -n "$MYSQL_REV"; then wsrep_cflags="$wsrep_cflags -DMYSQL_REV=$MYSQL_REV"; fi
+#if test -n "$WSREP_REV"; then wsrep_cflags="$wsrep_cflags -DWSREP_REV=$WSREP_REV"; fi
+
 # gcov
 
 # The  -fprofile-arcs and -ftest-coverage options cause GCC to instrument the

=== added file 'BUILD/compile-amd64-debug-wsrep'
--- old/BUILD/compile-amd64-debug-wsrep	1970-01-01 00:00:00 +0000
+++ new/BUILD/compile-amd64-debug-wsrep	2010-05-22 16:22:29 +0000
@@ -0,0 +1,11 @@
+#! /bin/sh
+
+path=`dirname $0`
+. "$path/SETUP.sh"
+
+extra_flags="$amd64_cflags $debug_cflags $wsrep_cflags -g -O0"
+c_warnings="$c_warnings $debug_extra_warnings"
+cxx_warnings="$cxx_warnings $debug_extra_warnings"
+extra_configs="$amd64_configs $debug_configs $wsrep_configs"
+
+. "$path/FINISH.sh"

=== added file 'BUILD/compile-amd64-wsrep'
--- old/BUILD/compile-amd64-wsrep	1970-01-01 00:00:00 +0000
+++ new/BUILD/compile-amd64-wsrep	2010-05-22 16:22:29 +0000
@@ -0,0 +1,9 @@
+#! /bin/sh
+
+path=`dirname $0`
+. "$path/SETUP.sh"
+
+extra_flags="$amd64_cflags $fast_cflags $wsrep_cflags -g"
+extra_configs="$amd64_configs $wsrep_configs"
+
+. "$path/FINISH.sh"

=== added file 'BUILD/compile-pentium-debug-wsrep'
--- old/BUILD/compile-pentium-debug-wsrep	1970-01-01 00:00:00 +0000
+++ new/BUILD/compile-pentium-debug-wsrep	2010-05-22 16:22:29 +0000
@@ -0,0 +1,12 @@
+#! /bin/sh -x
+
+path=`dirname $0`
+set -- "$@" --with-debug=full
+. "$path/SETUP.sh"
+
+extra_flags="$pentium_cflags $debug_cflags $wsrep_cflags -g -O0"
+c_warnings="$c_warnings $debug_extra_warnings"
+cxx_warnings="$cxx_warnings $debug_extra_warnings"
+extra_configs="$pentium_configs $debug_configs $wsrep_configs"
+
+. "$path/FINISH.sh"

=== added file 'BUILD/compile-pentium-wsrep'
--- old/BUILD/compile-pentium-wsrep	1970-01-01 00:00:00 +0000
+++ new/BUILD/compile-pentium-wsrep	2010-05-22 16:22:29 +0000
@@ -0,0 +1,11 @@
+#! /bin/sh
+
+path=`dirname $0`
+. "$path/SETUP.sh"
+
+extra_flags="$pentium_cflags $fast_cflags $wsrep_cflags"
+extra_configs="$pentium_configs $wsrep_configs"
+
+#strip=yes
+
+. "$path/FINISH.sh"

=== modified file 'Docs/Makefile.am'
--- old/Docs/Makefile.am	2008-04-08 09:44:18 +0000
+++ new/Docs/Makefile.am	2011-09-11 06:43:27 +0000
@@ -28,6 +28,13 @@
 	  $(INSTALL_DATA) $(srcdir)/mysql.info $(DESTDIR)$(infodir) ; \
 	  test ! -f $(top_srcdir)/ChangeLog || $(INSTALL_DATA) $(top_srcdir)/ChangeLog $(DESTDIR)$(pkgdatadir) ; \
 	fi
+if ENABLE_WSREP
+	if test `basename $(prefix)` = "mysql" ; then \
+	  $(INSTALL_DATA) $(srcdir)/README-wsrep $(DESTDIR)$(prefix)/docs ; \
+	else \
+	  $(INSTALL_DATA) $(srcdir)/README-wsrep $(DESTDIR)$(pkgdatadir) ; \
+	fi
+endif
 
 uninstall-local:
 	if test `basename $(prefix)` = "mysql" ; then \
@@ -37,6 +44,13 @@
 	  @RM@ -f $(DESTDIR)$(infodir)/mysql.info ; \
 	  @RM@ -f $(DESTDIR)$(pkgdatadir)/ChangeLog ; \
 	fi
+if ENABLE_WSREP
+	if test `basename $(prefix)` = "mysql" ; then \
+	  @RM@ -f $(DESTDIR)$(prefix)/docs/README-wsrep ; \
+	else \
+	  @RM@ -f $(DESTDIR)$(pkgdatadir)/README-wsrep ; \
+	fi
+endif
 
 # Don't update the files from bitkeeper
 %::SCCS/s.%

=== added file 'Docs/README-wsrep'
--- old/Docs/README-wsrep	1970-01-01 00:00:00 +0000
+++ new/Docs/README-wsrep	2012-02-08 17:52:31 +0000
@@ -0,0 +1,379 @@
+Codership Oy
+http://www.codership.com
+<info@codership.com>
+
+DISCLAIMER
+
+THIS SOFTWARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
+EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+IN NO EVENT SHALL CODERSHIP OY BE HELD LIABLE TO ANY PARTY FOR ANY DAMAGES
+RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE.
+
+Trademark Information.
+
+MySQL is a trademark or registered trademark of Oracle and/or its affiliates.
+Other trademarks are the property of their respective owners.
+
+Licensing Information.
+
+Please see file COPYING that came with this distribution
+
+Source code can be found at
+wsrep API:    https://launchpad.net/wsrep
+MySQL patch:  https://launchpad.net/codership-mysql
+
+
+ABOUT THIS DOCUMENT
+
+This document covers installation and configuration issues specific to this
+wsrep-patched MySQL distribution by Codership. It does not cover the use or
+administration of MySQL server per se. The reader is assumed to know how to
+install, configure, administer and use standard MySQL server version 5.1.xx.
+
+
+                        MYSQL-5.1.x/wsrep-23.x
+
+CONTENTS:
+=========
+1. WHAT IS WSREP PATCH FOR MYSQL
+2. INSTALLATION
+3. FIRST TIME SETUP
+   3.1 CONFIGURATION FILES
+   3.2 DATABASE PRIVILEGES
+   3.3 CHECK AND CORRECT FIREWALL SETTINGS
+   3.4 SELINUX
+   3.5 APPARMOR
+   3.6 CONNECT TO CLUSTER
+4. CONFIGURATION OPTIONS
+   4.1 MANDATORY MYSQL OPTIONS
+   4.2 WSREP OPTIONS
+5. LIMITATIONS
+
+
+1. WHAT IS WSREP PATCH FOR MYSQL/INNODB
+
+Wsrep API developed by Codership Oy is a modern generic (database-agnostic)
+replication API for transactional databases with a goal to make database
+replication/logging subsystem completely modular and pluggable. It is developed
+with flexibility and completeness in mind to satisfy broad range of modern
+replication scenarios. It is equally suitable for synchronous and asynchronous,
+master-slave and multi-master replication.
+
+wsrep stands for Write Set REPlication.
+
+Wsrep patch for MySQL/InnoDB allows MySQL server to load and use various wsrep
+API implementations ("wsrep providers") with different qualities of service.
+Without wsrep provider MySQL-wsrep server will function like a regular
+standalone server.
+
+
+2. INSTALLATION
+
+In the examples below mysql authentication options are omitted for brevity.
+
+2.1 Download and install mysql-wsrep package.
+
+Download binary package for your Linux distribution from
+https://launchpad.net/codership-mysql/
+
+2.1.1 On Debian and Debian-derived distributions.
+
+Upgrade from mysql-server-5.0 to mysql-wsrep is not supported yet, please 
+upgrade to mysql-server-5.1 first.
+
+If you're installing over an existing mysql installation, mysql-server-wsrep
+will conflict with mysql-server-5.1 package, so remove it first:
+
+$ sudo apt-get remove mysql-server-5.1 mysql-server-core-5.1
+
+mysql-server-wsrep requires psmisc and mysql-client-5.1.47 (or later).
+MySQL 5.1 packages can be found from backports repositories.
+For further information about configuring and using Debian or Ubuntu
+backports, see:
+
+* http://backports.debian.org
+
+* https://help.ubuntu.com/community/UbuntuBackports
+
+For example, installation of required packages on Debian Lenny:
+
+$ sudo apt-get install psmisc
+$ sudo apt-get -t lenny-backports install mysql-client-5.1
+
+Now you should be able to install mysql-wsrep package:
+
+$ sudo dpkg -i <mysql-server-wsrep DEB>
+
+2.1.2 On CentOS and similar RPM-based distributions.
+
+If you're migrating from existing MySQL installation, there are two variants:
+
+  a) If you're already using official MySQL-server-community 5.1.x RPM from
+     Oracle:
+
+     # rpm -e mysql-server
+
+  b) If you're upgrading from the stock mysql-5.0.77 on CentOS:
+
+     1) Make sure that the following packages are not installed:
+     # rpm --nodeps --allmatches -e mysql-server mysql-test mysql-bench
+
+     2) Install *official* MySQL-shared-compat-5.1.x from
+        http://dev.mysql.com/downloads/mysql/5.1.html
+
+Actual installation:
+
+   # rpm -Uvh <MySQL-server-wsrep RPM>
+
+   If this fails due to unsatisfied dependencies, install missing packages
+   (e.g. yum install perl-DBI) and retry.
+
+Additional packages to consider (if not yet installed):
+   * galera (multi-master replication provider, https://launchpad.net/galera)
+   * MySQL-client-community (for connecting to server and mysqldump-based SST)
+   * rsync (for rsync-based SST)
+
+2.2 Upgrade system tables.
+
+If you're upgrading a previous MySQL installation, it might be advisable to
+upgrade system tables. To do that start mysqld and run mysql_upgrade command.
+Consult MySQL documentation in case of errors. Normally they are not critical
+and can be ignored unless specific functionality is needed.
+
+
+3. FIRST TIME SETUP
+
+Unless you're upgrading an already installed mysql-wsrep package, you will need
+to set up a few things to prepare server for operation.
+
+3.1 CONFIGURATION FILES
+
+* Make sure system-wide my.cnf does not bind mysqld to 127.0.0.1. That is, if
+  you have the following line in [mysqld] section, comment it out:
+
+  #bind-address = 127.0.0.1
+
+* Make sure system-wide my.cnf contains "!includedir /etc/mysql/conf.d/" line.
+
+* Edit /etc/mysql/conf.d/wsrep.cnf and set wsrep_provider option by specifying
+  a path to provider library. If you don't have a provider, leave it as it is.
+
+* When a new node joins the cluster it'll have to receive a state snapshot from
+  one of the peers. This requires a privileged MySQL account with access from
+  the rest of the cluster. Edit /etc/mysql/conf.d/wsrep.cnf and set mysql
+  login/password pair for SST, for example:
+
+  wsrep_sst_auth=wsrep_sst:wspass
+
+* See CONFIGURATION section below about other configuration parameters that you
+  might want to change at this point.
+
+3.2 DATABASE PRIVILEGES
+
+Restart MySQL server and connect to it as root to grant privileges to SST
+account (empty users confuse MySQL authentication matching rules, we need to
+delete them too):
+
+$ mysql -e "SET wsrep_on=OFF; DELETE FROM mysql.user WHERE user='';"
+$ mysql -e "SET wsrep_on=OFF; GRANT ALL ON *.* TO wsrep_sst@'%' IDENTIFIED BY 'wspass'";
+
+3.3 CHECK AND CORRECT FIREWALL SETTINGS.
+
+MySQL-wsrep server needs to be accessible from other cluster members through
+its client listening socket and through wsrep provider socket. See your
+distribution and wsrep provider documentation for details. For example on
+CentOS you might need to do something along these lines:
+
+# iptables --insert RH-Firewall-1-INPUT 1 --proto tcp --source <my IP>/24 --destination <my IP>/32 --dport 3306 -j ACCEPT
+# iptables --insert RH-Firewall-1-INPUT 1 --proto tcp --source <my IP>/24 --destination <my IP>/32 --dport 4567 -j ACCEPT
+
+If there is a NAT firewall between the nodes, it must be configured to allow
+direct connections between the nodes (e.g. via port forwarding).
+
+3.4 SELINUX
+
+If you have SELinux enabled, it may block mysqld from doing required operations.
+You'll need to either disable it or configure to allow mysqld to run external
+programs and open listen sockets at unprivileged ports (i.e. things that
+an unprivileged user can do). See SELinux documentation about it.
+
+To quickly disable SELinux:
+1) run 'setenforce 0' as root.
+2) set 'SELINUX=permissive' in  /etc/selinux/config
+
+3.5 APPARMOR
+
+AppArmor automatically comes with Ubuntu and may also prevent mysqld to from
+opening additional ports or run scripts. See AppArmor documentation about its
+configuration. To disable AppArmor for mysqld:
+
+$ cd /etc/apparmor.d/disable/
+$ sudo ln -s /etc/apparmor.d/usr.sbin.mysqld
+$ sudo service apparmor restart
+
+
+3.6 CONNECT TO CLUSTER
+
+Now you're ready to connect to cluster by setting wsrep_cluster_address variable
+and monitor status of wsrep provider:
+
+mysql> SET GLOBAL wsrep_cluster_address='<cluster address string>';
+mysql> SHOW STATUS LIKE 'wsrep%';
+
+
+4. CONFIGURATION OPTIONS
+
+4.1 MANDATORY MYSQL OPTIONS
+
+binlog_format=ROW
+   This option is required to use row-level replication as opposed to
+   statement-level. For performance and consistency considerations don't change
+   that. As a side effect, binlog, if turned on, can be ROW only. In future this
+   option won't have special meaning.
+
+innodb_autoinc_lock_mode=2
+   This is a required parameter. Without it INSERTs into tables with
+   AUTO_INCREMENT column may fail.
+   autoinc lock modes 0 and 1 can cause unresolved deadlock, and make
+   system unresponsive.
+
+innodb_locks_unsafe_for_binlog=1
+   This option is required for parallel applying.
+
+4.2 WSREP OPTIONS
+
+All options are optional except for wsrep_provider, wsrep_cluster_address, and
+wsrep_sst_auth.
+
+wsrep_provider=none
+   A full path to the library that implements WSREP interface. If none is
+   specified, the server behaves like a regular mysqld.
+
+wsrep_provider_options=
+   Provider-specific option string. Check wsrep provider documentation or
+   http://www.codership.com/wiki
+
+wsrep_cluster_address=
+   Provider-specific cluster address string. This is used to connect a node to
+   the desired cluster. This option can be given either on mysqld startup or set
+   during runtime. See wsrep provider documentation for possible values.
+
+wsrep_cluster_name="my_wsrep_cluster"
+   Logical cluster name, must be the same for all nodes of the cluster.
+
+wsrep_node_name=
+   Human readable node name (for easier log reading only). Defaults to hostname.
+
+wsrep_slave_threads=1
+   Number of threads dedicated to processing of writesets from other nodes.
+   For best performance should be few per CPU core.
+
+wsrep_dbug_option
+   Options for the built-in DBUG library (independent from what MySQL uses).
+   Empty by default. Not currently in use.
+
+wsrep_debug=0
+   Enable debug-level logging.
+
+wsrep_convert_LOCK_to_trx=0
+   Implicitly convert locking sessions into transactions inside mysqld. By
+   itself it does not mean support for locking sessions, but it prevents the
+   database from going into logically inconsistent state. Note however, that
+   loading large database dump with LOCK statements might result in abnormally
+   large transactions and cause an out-of-memory condition
+
+wsrep_retry_autocommit=1
+   Retry autocommit queries and single statement transactions should they fail
+   certification test. This is analogous to rescheduling an autocommit query
+   should it go into deadlock with other transactions in the database lock
+   manager.
+
+wsrep_auto_increment_control=1
+   Automatically adjust auto_increment_increment and auto_increment_offset
+   variables based on the number of nodes in the cluster. Significantly reduces
+   certification conflict rate for INSERTS.
+
+wsrep_drupal_282555_workaround=1
+   MySQL seems to have an obscure bug when INSERT into table with
+   AUTO_INCREMENT column with NULL value for that column can fail with a 
+   duplicate key error. When this option is on, it retries such INSERTs.
+   Required for stable Drupal operation. Documented at:
+      http://bugs.mysql.com/bug.php?id=41984
+      http://drupal.org/node/282555
+
+wsrep_causal_reads=0
+   Enforce strict READ COMMITTED semantics on reads and transactions. May
+   result in additional latencies. It is a session variable.
+
+
+State snapshot transfer options.
+
+When a new node joins the cluster it has to synchronize its initial state with
+the other cluster members by transferring state snapshot from one of them.
+The options below govern how this happens and should be set up before attempting
+to join or start a cluster.
+
+wsrep_sst_method=mysqldump
+   What method to use to copy database state to a newly joined node. Supported
+   methods:
+   - mysqldump: slow (except for small datasets) but most tested.
+   - rsync:     much faster on large datasets.
+   - rsync_wan: same as rsync but with deltaxfer to minimize network traffic.
+
+wsrep_sst_receive_address=
+   Address (hostname:port) at which this node wants to receive state snapshot.
+   Defaults to mysqld bind address, and if that is not specified (0.0.0.0) -
+   to the first IP of eth0 + mysqld bind port.
+   NOTE: check that your firewall allows connections to this address from other
+         cluster nodes.
+
+wsrep_sst_auth=
+   Authentication information needed for state transfer. Depends on the state
+   transfer method. For mysqldump-based SST it is
+   <mysql_root_user>:<mysql_root_password>
+   and should be the same on all nodes - it is used to authenticate with both
+   state snapshot receiver and state snapshot donor.
+
+wsrep_sst_donor=
+   A name of the node which should serve as state snapshot donor. This allows
+   to control which node will serve state snapshot request. By default the
+   most suitable node is chosen by wsrep provider. This is the same as given in
+   wsrep_node_name.
+
+
+5. LIMITATIONS
+
+1) Currently replication works only with InnoDB storage engine. Any writes to 
+   tables of other types, including system (mysql.*) tables are not replicated. 
+   However, DDL statements are replicated in statement level, and changes
+   to mysql.* tables will get replicated that way.
+   So, you can safely issue: CREATE USER...,
+   but issuing: INSERT INTO mysql.user..., will not be replicated.
+
+2) DELETE operation is unsupported on tables without primary key. Also rows in
+   tables without primary key may appear in different order on different nodes.
+   As a result SELECT...LIMIT... may return slightly different sets.
+
+3) Unsupported queries:
+    * LOCK/UNLOCK TABLES cannot be supported in multi-master setups.
+    * lock functions (GET_LOCK(), RELEASE_LOCK()... )
+
+4) Query log cannot be directed to table. If you enable query logging,
+   you must forward the log to a file:
+       log_output = FILE
+   Use general_log and general_log_file to choose query logging and the 
+   log file name
+
+5) Maximum allowed transaction size is defined by wsrep_max_ws_rows and
+   wsrep_max_ws_size. Anything bigger (e.g. huge LOAD DATA) will be rejected.
+
+6) Due to cluster level optimistic concurrency control, transaction issuing
+   COMMIT may still be aborted at that stage. There can be two transactions.
+   writing to same rows and committing in separate cluster nodes, and only one
+   of the them can successfully commit. The failing one will be aborted.
+   For cluster level aborts, MySQL/galera cluster gives back deadlock error.
+   code (Error: 1213 SQLSTATE: 40001  (ER_LOCK_DEADLOCK)).
+
+7) XA transactions can not be supported due to possible rollback on commit.
+

=== modified file 'Makefile.am'
--- old/Makefile.am	2011-02-22 21:03:32 +0000
+++ new/Makefile.am	2011-07-03 19:34:26 +0000
@@ -23,7 +23,7 @@
 
 SUBDIRS =		. include @docs_dirs@ @zlib_dir@ \
 			@readline_topdir@ sql-common scripts \
-			@sql_union_dirs@ unittest \
+			@sql_union_dirs@ unittest @wsrep_dir@ \
 			@sql_server@ @man_dirs@ tests \
 			netware @libmysqld_dirs@ \
 			mysql-test support-files sql-bench @tools_dirs@ \
@@ -31,7 +31,7 @@
 
 DIST_SUBDIRS =		. include Docs zlib \
 			cmd-line-utils sql-common scripts \
-			strings mysys dbug extra regex libmysql libmysql_r client unittest storage plugin \
+			strings mysys dbug extra regex libmysql libmysql_r client unittest storage plugin wsrep \
 			vio sql man tests \
 			netware libmysqld \
 			mysql-test support-files sql-bench server-tools \
@@ -50,12 +50,14 @@
 # Create initial database files for Windows installations and check them.
 dist-hook:
 	rm -rf `find $(distdir) -type d -name SCCS -print`
+if !ENABLE_WSREP
 	mkdir -p $(distdir)/win
 	scripts/mysql_install_db --no-defaults --cross-bootstrap \
 		--builddir=$(top_builddir) \
 		--datadir=$(distdir)/win/data \
 		--srcdir=$(top_srcdir)
 	storage/myisam/myisamchk --silent --fast $(distdir)/win/data/mysql/*.MYI
+endif
 
 all-local:		@ABI_CHECK@	
 

=== modified file 'config/ac-macros/check_cpu.m4'
--- old/config/ac-macros/check_cpu.m4	2004-12-04 19:00:33 +0000
+++ new/config/ac-macros/check_cpu.m4	2009-05-30 23:54:36 +0000
@@ -32,7 +32,7 @@
 
 for ac_arg in $cpu_set;
 do
-  CFLAGS="$ac_save_CFLAGS -mcpu=$ac_arg -march=$ac_arg -DCPU=$ac_arg" 
+  CFLAGS="$ac_save_CFLAGS -mtune=$ac_arg -march=$ac_arg -DCPU=$ac_arg" 
   AC_TRY_COMPILE([],[int i],mysql_cv_cpu=$ac_arg; break;, mysql_cv_cpu="unknown")
 done
 

=== modified file 'config/ac-macros/maintainer.m4'
--- old/config/ac-macros/maintainer.m4	2010-12-07 15:06:20 +0000
+++ new/config/ac-macros/maintainer.m4	2011-07-03 18:34:57 +0000
@@ -8,8 +8,7 @@
     [AS_HELP_STRING([--enable-mysql-maintainer-mode],
                     [Enable a MySQL maintainer-specific development environment])],
     [USE_MYSQL_MAINTAINER_MODE=$enableval],
-    [AS_IF([test "$with_debug" != "no"],
-      [USE_MYSQL_MAINTAINER_MODE=yes], [USE_MYSQL_MAINTAINER_MODE=no])])
+    [USE_MYSQL_MAINTAINER_MODE=no])
   AC_MSG_RESULT([$USE_MYSQL_MAINTAINER_MODE])
 ])
 

=== added file 'config/ac-macros/wsrep.m4'
--- old/config/ac-macros/wsrep.m4	1970-01-01 00:00:00 +0000
+++ new/config/ac-macros/wsrep.m4	2012-02-21 20:44:53 +0000
@@ -0,0 +1,48 @@
+dnl ---------------------------------------------------------------------------
+dnl Macro: MYSQL_CHECK_WSREP
+dnl Sets WITH_WSREP if --with-wsrep is used
+dnl ---------------------------------------------------------------------------
+
+
+AC_DEFUN([MYSQL_CHECK_WSREP],
+         [AC_ARG_WITH([wsrep],
+          AC_HELP_STRING([--with-wsrep],
+                         [enable WS replication [[default=no]]]),,
+                         [with_wsrep="no"])
+
+    if test "$with_wsrep" != "no"
+    then
+        AC_MSG_CHECKING([for required WS replication libraries])
+        WSREP_INCLUDES="-I\$(top_srcdir)/wsrep"
+        WSREP_LIBS="\$(top_builddir)/wsrep/libwsrep.a"
+        AC_SUBST(WSREP_INCLUDES)
+        AC_SUBST(WSREP_LIBS)
+	wsrep_dir="wsrep"
+	AC_SUBST([wsrep_dir])
+	AC_DEFINE([WITH_WSREP],[1],[Use WS replication])
+	mysql_plugin_defs="$mysql_plugin_defs, builtin_wsrep_plugin"
+
+	WSREP_API=23
+	AC_SUBST(WSREP_API)
+	AC_DEFINE_UNQUOTED(WSREP_API, [$WSREP_API], [wsrep API version])
+	WSREP_PATCH=4
+	AC_SUBST(WSREP_PATCH)
+	AC_DEFINE_UNQUOTED(WSREP_PATCH, [$WSREP_PATCH], [wsrep patch version])
+	WSREP_VER=${WSREP_VER:-"$WSREP_API.$WSREP_PATCH"}
+	AC_SUBST(WSREP_VER)
+	AC_DEFINE_UNQUOTED(WSREP_VER, [$WSREP_VER], [wsrep version])
+	WSREP_REV=${WSREP_REV:-"xxxx"}
+	AC_SUBST(WSREP_REV)
+	AC_DEFINE_UNQUOTED(WSREP_REV, [$WSREP_REV], [wsrep revision])
+	COMPILATION_COMMENT="${COMPILATION_COMMENT}, wsrep_${WSREP_API}.${WSREP_PATCH}.r${WSREP_REV}"
+	AC_SUBST(COMPILATION_COMMENT)
+
+	extra_docs="$extra_docs README-wsrep"
+    fi
+
+    AM_CONDITIONAL([ENABLE_WSREP], [test "$with_wsrep" != "no"])
+])
+
+dnl ---------------------------------------------------------------------------
+dnl END OF MYSQL_CHECK_WSREP SECTION
+dnl ---------------------------------------------------------------------------

=== modified file 'configure.in'
--- old/configure.in	2012-01-12 14:43:41 +0000
+++ new/configure.in	2012-04-19 19:26:55 +0000
@@ -78,6 +78,8 @@
 sinclude(config/ac-macros/ssl.m4)
 sinclude(config/ac-macros/zlib.m4)
 
+sinclude(config/ac-macros/wsrep.m4)
+
 # Remember to add a directory sql/share/LANGUAGE
 AVAILABLE_LANGUAGES="\
 czech danish dutch english estonian french german greek hungarian \
@@ -2549,7 +2551,7 @@
 then
   docs_dirs="Docs"
   if test -f "$srcdir/Docs/manual.chm" ; then
-    extra_docs="manual.chm"
+    extra_docs="$extra_docs manual.chm"
   fi
 else
   docs_dirs=""
@@ -2680,6 +2682,7 @@
 AC_SUBST(readline_link)
 AC_SUBST(readline_h_ln_cmd)
 
+MYSQL_CHECK_WSREP
 
 
 # Include man pages, if desired, adapted to the configured parts.
@@ -2866,7 +2869,7 @@
  libmysqld/Makefile libmysqld/examples/Makefile dnl
  mysql-test/Makefile mysql-test/lib/My/SafeProcess/Makefile dnl
  netware/Makefile sql-bench/Makefile dnl
- include/mysql_version.h plugin/Makefile win/Makefile)
+ include/mysql_version.h plugin/Makefile win/Makefile wsrep/Makefile)
 
 AC_CONFIG_COMMANDS([default], , test -z "$CONFIG_HEADERS" || echo timestamp > stamp-h)
 

=== modified file 'include/thr_lock.h'
--- old/include/thr_lock.h	2011-06-30 15:37:13 +0000
+++ new/include/thr_lock.h	2011-10-12 21:45:28 +0000
@@ -23,6 +23,14 @@
 #ifdef	__cplusplus
 extern "C" {
 #endif
+#ifdef WITH_WSREP
+#include <my_sys.h>
+  typedef int (* wsrep_thd_is_brute_force_fun)(void *);
+  typedef int (* wsrep_abort_thd_fun)(void *, void *, my_bool);
+  void wsrep_thr_lock_init(
+    wsrep_thd_is_brute_force_fun bf_fun, wsrep_abort_thd_fun abort_fun,
+    my_bool debug, my_bool convert_LOCK_to_trx);
+#endif
 
 #include <my_pthread.h>
 #include <my_list.h>
@@ -100,8 +108,11 @@
   pthread_t thread;
   my_thread_id thread_id;
   ulong n_cursors;
+#ifdef WITH_WSREP
+  void *mysql_thd;        // THD pointer
+  my_bool in_lock_tables; // true, if inside locking session
+#endif
 } THR_LOCK_INFO;
-
 /*
   Lock owner identifier. Globally identifies the lock owner within the
   thread and among all the threads. The address of an instance of this

=== modified file 'libmysqld/Makefile.am'
--- old/libmysqld/Makefile.am	2011-06-30 15:37:13 +0000
+++ new/libmysqld/Makefile.am	2011-10-12 21:45:28 +0000
@@ -35,7 +35,8 @@
 			-I$(top_srcdir)/sql/examples \
 			-I$(top_srcdir)/regex \
 			$(openssl_includes) @ZLIB_INCLUDES@ \
-			@condition_dependent_plugin_includes@
+			@condition_dependent_plugin_includes@ \
+			@WSREP_INCLUDES@
 
 noinst_LIBRARIES =	libmysqld_int.a
 pkglib_LIBRARIES =	libmysqld.a
@@ -100,7 +101,8 @@
 		$(top_builddir)/vio/libvio.a \
                 @NDB_SCI_LIBS@ \
 		@mysql_plugin_libs@ \
-		$(yassl_inc_libs)
+		$(yassl_inc_libs) \
+		@WSREP_LIBS@
 
 if HAVE_YASSL
 yassl_inc_libs=	$(top_builddir)/extra/yassl/src/.libs/libyassl.a \

=== modified file 'mysys/default.c'
--- old/mysys/default.c	2011-06-30 15:37:13 +0000
+++ new/mysys/default.c	2011-12-11 20:15:29 +0000
@@ -48,6 +48,12 @@
 const char *my_defaults_group_suffix=0;
 char *my_defaults_extra_file=0;
 
+#ifdef WITH_WSREP
+/* The only purpose of this global array is to hold full name of my.cnf
+ * which seems to be otherwise unavailable */
+char wsrep_defaults_file[FN_REFLEN + 10]={0,};
+#endif /* WITH_WREP */
+
 /* Which directories are searched for options (and in which order) */
 
 #define MAX_DEFAULT_DIRS 6
@@ -700,6 +706,10 @@
   if (!(fp= my_fopen(name, O_RDONLY, MYF(0))))
     return 1;					/* Ignore wrong files */
 
+#ifdef WITH_WSREP
+  strncpy(wsrep_defaults_file, name, sizeof(wsrep_defaults_file) - 1);
+#endif /* WITH_WSREP */
+
   while (fgets(buff, sizeof(buff) - 1, fp))
   {
     line++;

=== modified file 'mysys/thr_lock.c'
--- old/mysys/thr_lock.c	2011-06-30 15:37:13 +0000
+++ new/mysys/thr_lock.c	2011-10-12 21:45:28 +0000
@@ -87,7 +87,22 @@
 ulong locks_immediate = 0L, locks_waited = 0L;
 ulong table_lock_wait_timeout;
 enum thr_lock_type thr_upgraded_concurrent_insert_lock = TL_WRITE;
-
+#ifdef WITH_WSREP
+static wsrep_thd_is_brute_force_fun wsrep_thd_is_brute_force= NULL;
+static wsrep_abort_thd_fun wsrep_abort_thd= NULL;
+static my_bool wsrep_debug;
+static my_bool wsrep_convert_LOCK_to_trx;
+
+void wsrep_thr_lock_init(
+    wsrep_thd_is_brute_force_fun bf_fun, wsrep_abort_thd_fun abort_fun,
+    my_bool debug, my_bool convert_LOCK_to_trx
+) {
+  wsrep_thd_is_brute_force= bf_fun;
+  wsrep_abort_thd= abort_fun;
+  wsrep_debug= debug;
+  wsrep_convert_LOCK_to_trx= convert_LOCK_to_trx;;
+}
+#endif
 /* The following constants are only for debug output */
 #define MAX_THREADS 100
 #define MAX_LOCKS   100
@@ -507,7 +522,82 @@
   pthread_mutex_unlock(&thread_var->mutex);
   DBUG_RETURN(result);
 }
+#ifdef WITH_WSREP
+/*
+ * If brute force applier would need to wait for a thr lock,
+ * it needs to make sure that it will get the lock without (too much) 
+ * delay. 
+ * We identify here the owners of blocking locks and ask them to
+ * abort. We then put our lock request in the first place in the
+ * wait queue. When lock holders abort (one by one) the lock release
+ * algorithm should grant the lock to us. We rely on this and proceed
+ * to wait_for_locks().
+ * wsrep_break_locks() should be called in all the cases, where lock
+ * wait would happen.
+ *
+ * TODO: current implementation might not cover all possible lock wait
+ *       situations. This needs an review still.
+ * TODO: lock release, might favor some other lock (instead our bf).
+ *       This needs an condition to check for bf locks first.
+ * TODO: we still have a debug fprintf, this should be removed
+ */
+static inline my_bool 
+wsrep_break_lock(
+    THR_LOCK_DATA *data, struct st_lock_list *lock_queue1, 
+    struct st_lock_list *lock_queue2, struct st_lock_list *wait_queue)
+{
+  if (wsrep_thd_is_brute_force &&
+      wsrep_thd_is_brute_force(data->owner->info->mysql_thd))
+  {
+    THR_LOCK_DATA *holder;
+
+    /* if locking session conversion to transaction has been enabled,
+       we know that this conflicting lock must be read lock and furthermore,
+       lock holder is read-only. It is safe to wait for him.
+    */
+    if (wsrep_convert_LOCK_to_trx && data->owner->info->in_lock_tables)
+    {
+      if (wsrep_debug) 
+        fprintf(stderr,"WSREP wsrep_break_lock read lock untouched\n");
+      return FALSE;
+    }
+    if (wsrep_debug) 
+      fprintf(stderr,"WSREP wsrep_break_lock aborting locks\n");
 
+    /* aborting lock holder(s) here */
+    for (holder=lock_queue1->data; holder; holder=holder->next) 
+    {
+      wsrep_abort_thd(data->owner->info->mysql_thd, 
+                      holder->owner->info->mysql_thd, FALSE);
+    }
+    for (holder=lock_queue2->data; holder; holder=holder->next) 
+    {
+      wsrep_abort_thd(data->owner->info->mysql_thd,
+                      holder->owner->info->mysql_thd, FALSE);
+    }
+        
+    /* Add our lock to the head of the wait queue */
+    if (*(wait_queue->last)==wait_queue->data)
+    {
+      wait_queue->last=&data->next;
+      assert(wait_queue->data==0);
+    }
+    else
+    {
+      assert(wait_queue->data!=0);
+      wait_queue->data->prev=&data->next;
+    }
+    data->next=wait_queue->data;
+    data->prev=&wait_queue->data;
+    wait_queue->data=data;
+    data->cond=get_cond();
+
+    statistic_increment(locks_immediate,&THR_LOCK_lock);
+    return TRUE;
+  }
+  return FALSE;
+}
+#endif
 
 enum enum_thr_lock_result
 thr_lock(THR_LOCK_DATA *data, THR_LOCK_OWNER *owner,
@@ -517,6 +607,9 @@
   enum enum_thr_lock_result result= THR_LOCK_SUCCESS;
   struct st_lock_list *wait_queue;
   THR_LOCK_DATA *lock_owner;
+#ifdef WITH_WSREP
+  my_bool wsrep_lock_inserted= FALSE;
+#endif
   DBUG_ENTER("thr_lock");
 
   data->next=0;
@@ -564,6 +657,13 @@
       }
       if (lock->write.data->type == TL_WRITE_ONLY)
       {
+#ifdef WITH_WSREP
+        if (wsrep_break_lock(data, &lock->write, NULL, &lock->read_wait))
+        {
+          wsrep_lock_inserted= TRUE;
+          goto wsrep_read_wait;
+        }
+#endif
 	/* We are not allowed to get a READ lock in this case */
 	data->type=TL_UNLOCK;
         result= THR_LOCK_ABORTED;               /* Can't wait for this one */
@@ -591,6 +691,13 @@
       lock but a high priority write waiting in the write_wait queue.
       In the latter case we should yield the lock to the writer.
     */
+#ifdef WITH_WSREP
+    if (wsrep_break_lock(data, &lock->write, NULL, &lock->read_wait))
+    {
+      wsrep_lock_inserted= TRUE;
+    }
+  wsrep_read_wait:
+#endif
     wait_queue= &lock->read_wait;
   }
   else						/* Request for WRITE lock */
@@ -599,6 +706,13 @@
     {
       if (lock->write.data && lock->write.data->type == TL_WRITE_ONLY)
       {
+#ifdef WITH_WSREP
+        if (wsrep_break_lock(data, &lock->write, NULL, &lock->write_wait))
+        {
+          wsrep_lock_inserted=TRUE;
+            goto wsrep_write_wait;
+        }
+#endif
 	data->type=TL_UNLOCK;
         result= THR_LOCK_ABORTED;               /* Can't wait for this one */
 	goto end;
@@ -612,6 +726,12 @@
 	  !have_specific_lock(lock->write_wait.data,TL_WRITE_ALLOW_READ) &&
 	  (lock->write.data || lock->read.data))
       {
+#ifdef WITH_WSREP
+        if (wsrep_break_lock(data, &lock->write, NULL, &lock->write_wait))
+        {
+          goto end;
+        }
+#endif
 	/* Add delayed write lock to write_wait queue, and return at once */
 	(*lock->write_wait.last)=data;
 	data->prev=lock->write_wait.last;
@@ -635,6 +755,13 @@
         /* Allow lock owner to bypass TL_WRITE_ONLY. */
         if (!thr_lock_owner_equal(data->owner, lock->write.data->owner))
         {
+#ifdef WITH_WSREP
+          if (wsrep_break_lock(data, &lock->write, NULL, &lock->write_wait))
+          {
+            wsrep_lock_inserted=TRUE;
+            goto wsrep_write_wait;
+          }
+#endif
           /* We are not allowed to get a lock in this case */
           data->type=TL_UNLOCK;
           result= THR_LOCK_ABORTED;               /* Can't wait for this one */
@@ -708,6 +835,14 @@
       DBUG_PRINT("lock",("write locked 3 by thread: 0x%lx  type: %d",
 			 lock->read.data->owner->info->thread_id, data->type));
     }
+#ifdef WITH_WSREP
+    if (wsrep_break_lock(data, &lock->write, &lock->read, &lock->write_wait))
+    {
+      wsrep_lock_inserted= TRUE;
+    }
+  wsrep_write_wait:
+
+#endif
     wait_queue= &lock->write_wait;
   }
   /*
@@ -724,6 +859,10 @@
     goto end;
   }
   /* Can't get lock yet;  Wait for it */
+#ifdef WITH_WSREP
+  if (wsrep_lock_inserted)
+    DBUG_RETURN(wait_for_lock(wait_queue, data, 1));
+#endif
   DBUG_RETURN(wait_for_lock(wait_queue, data, 0));
 end:
   pthread_mutex_unlock(&lock->mutex);

=== modified file 'scripts/Makefile.am'
--- old/scripts/Makefile.am	2011-06-30 15:37:13 +0000
+++ new/scripts/Makefile.am	2011-10-12 21:45:28 +0000
@@ -61,6 +61,13 @@
 			mysqld_multi.sh \
 			mysqld_safe.sh
 
+if ENABLE_WSREP
+bin_SCRIPTS += wsrep_sst_mysqldump
+EXTRA_SCRIPTS += wsrep_sst_mysqldump.sh
+bin_SCRIPTS += wsrep_sst_rsync
+EXTRA_SCRIPTS += wsrep_sst_rsync.sh
+endif
+
 EXTRA_DIST =		$(EXTRA_SCRIPTS) \
 			mysqlaccess.conf \
 			mysqlbug \
@@ -92,6 +99,10 @@
 			mysqldumpslow \
 			mysqld_multi
 
+if ENABLE_WSREP
+CLEANFILES += wsrep_sst_mysqldupmp
+endif
+
 pkgplugindir =		$(pkglibdir)/plugin
 
 # Default same as 'pkgdatadir', but we can override it

=== modified file 'scripts/mysqld_safe.sh'
--- old/scripts/mysqld_safe.sh	2010-04-09 11:47:18 +0000
+++ new/scripts/mysqld_safe.sh	2012-05-16 19:32:39 +0000
@@ -53,6 +53,7 @@
   --syslog                   Log messages to syslog with 'logger'
   --skip-syslog              Log messages to error log (default)
   --syslog-tag=TAG           Pass -t "mysqld-TAG" to 'logger'
+  --wsrep-urls=WSREP_URLS    Comma-separated list of wsrep URLs
 
 All other options are passed to the mysqld program.
 
@@ -143,6 +144,34 @@
   echo "$1" | sed -e 's,\([^a-zA-Z0-9/_.=-]\),\\\1,g'
 }
 
+wsrep_pick_url() {
+  [ $# -eq 0 ] && return 0
+
+  if ! which nc >/dev/null; then
+    log_error "ERROR: nc tool not found in PATH! Make sure you have it installed."
+    return 1
+  fi
+
+  local url
+  # Assuming URL in the form scheme://host:port
+  # If host and port are not NULL, the liveness of URL is assumed to be tested
+  # If port part is absent, the url is returned literally and unconditionally
+  # If every URL has port but none is reachable, nothing is returned
+  for url in `echo $@ | sed s/,/\ /g` 0; do
+    local host=`echo $url | cut -d \: -f 2 | sed s/^\\\/\\\///`
+    local port=`echo $url | cut -d \: -f 3`
+    [ -z "$port" ] && break
+    nc -z "$host" $port >/dev/null && break
+  done
+
+  if [ "$url" == "0" ]; then
+    log_error "ERROR: none of the URLs in '$@' is reachable."
+    return 1
+  fi
+
+  echo $url
+}
+
 parse_arguments() {
   # We only need to pass arguments through to the server if we don't
   # handle them here.  So, we collect unrecognized options (passed on
@@ -189,6 +218,7 @@
       --skip-syslog) want_syslog=0 ;;
       --syslog-tag=*) syslog_tag="$val" ;;
       --timezone=*) TZ="$val"; export TZ; ;;
+      --wsrep[-_]urls=*) wsrep_urls="$val"; ;;
 
       --help) usage ;;
 
@@ -570,7 +600,14 @@
 do
   rm -f $safe_mysql_unix_port "$pid_file"	# Some extra safety
 
-  eval_log_error "$cmd"
+  [ -n "$wsrep_urls" ] && url=`wsrep_pick_url $wsrep_urls` # check connect address
+
+  if [ -z "$url" ]
+  then
+    eval_log_error "$cmd"
+  else
+    eval_log_error "$cmd --wsrep_cluster_address=$url"
+  fi
 
   if test ! -f "$pid_file"		# This is removed if normal shutdown
   then

=== added file 'scripts/wsrep_sst_mysqldump.sh'
--- old/scripts/wsrep_sst_mysqldump.sh	1970-01-01 00:00:00 +0000
+++ new/scripts/wsrep_sst_mysqldump.sh	2011-11-07 20:35:12 +0000
@@ -0,0 +1,125 @@
+#!/bin/sh -e
+# Copyright (C) 2009 Codership Oy
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; version 2 of the License.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING. If not, write to the
+# Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston
+# MA  02110-1301  USA.
+
+# This is a reference script for mysqldump-based state snapshot tansfer
+
+USER=$1
+PSWD=$2
+HOST=$3
+PORT=$4
+LOCAL_HOST="127.0.0.1"
+LOCAL_PORT=$5
+UUID=$6
+SEQNO=$7
+BYPASS=$8
+
+EINVAL=22
+
+err()
+{
+    echo "SST error: $*" >&2
+}
+
+local_ip()
+{
+    export PATH=$PATH:/usr/sbin:/usr/bin:/sbin:/bin
+
+    [ "$1" = "127.0.0.1" ]      && return 0
+    [ "$1" = "localhost" ]      && return 0
+    [ "$1" = "$(hostname -s)" ] && return 0
+    [ "$1" = "$(hostname -f)" ] && return 0
+    [ "$1" = "$(hostname -d)" ] && return 0
+
+    # Now if ip program is not found in the path, we can't return 0 since
+    # it would block any address. Thankfully grep should fail in this case
+    ip route get "$1" | grep local >/dev/null && return 0
+
+    return 1
+}
+
+if test -z "$USER";  then err "USER cannot be nil"; exit $EINVAL; fi
+if test -z "$HOST";  then err "HOST cannot be nil"; exit $EINVAL; fi
+if test -z "$PORT";  then err "PORT cannot be nil"; exit $EINVAL; fi
+if test -z "$LOCAL_PORT"; then err "LOCAL_PORT cannot be nil"; exit $EINVAL; fi
+if test -z "$UUID";  then err "UUID cannot be nil"; exit $EINVAL; fi
+if test -z "$SEQNO"; then err "SEQNO cannot be nil"; exit $EINVAL; fi
+
+if local_ip $HOST && [ "$PORT" = "$LOCAL_PORT" ]
+then
+    err "destination address '$HOST:$PORT' matches source address."
+    exit $EINVAL
+fi
+
+AUTH="-u$USER"
+if test -n "$PSWD"; then AUTH="$AUTH -p$PSWD"; fi
+
+STOP_WSREP="SET wsrep_on=OFF;"
+
+# NOTE: we don't use --routines here because we're dumping mysql.proc table
+#MYSQLDUMP="@bindir@/mysqldump $AUTH -h$LOCAL_HOST -P$LOCAL_PORT \
+MYSQLDUMP="mysqldump $AUTH -h$LOCAL_HOST -P$LOCAL_PORT \
+--add-drop-database --add-drop-table --skip-add-locks --create-options \
+--disable-keys --extended-insert --skip-lock-tables --quick --set-charset \
+--skip-comments --flush-privileges --all-databases"
+
+# mysqldump cannot restore CSV tables, fix this issue
+CSV_TABLES_FIX="
+set sql_mode='';
+
+USE mysql;
+
+SET @str = IF (@@have_csv = 'YES', 'CREATE TABLE IF NOT EXISTS general_log (event_time TIMESTAMP NOT NULL, user_host MEDIUMTEXT NOT NULL, thread_id INTEGER NOT NULL, server_id INTEGER UNSIGNED NOT NULL, command_type VARCHAR(64) NOT NULL,argument MEDIUMTEXT NOT NULL) engine=CSV CHARACTER SET utf8 comment=\"General log\"', 'SET @dummy = 0');
+
+PREPARE stmt FROM @str;
+EXECUTE stmt;
+DROP PREPARE stmt;
+
+SET @str = IF (@@have_csv = 'YES', 'CREATE TABLE IF NOT EXISTS slow_log (start_time TIMESTAMP NOT NULL, user_host MEDIUMTEXT NOT NULL, query_time TIME NOT NULL, lock_time TIME NOT NULL, rows_sent INTEGER NOT NULL, rows_examined INTEGER NOT NULL, db VARCHAR(512) NOT NULL, last_insert_id INTEGER NOT NULL, insert_id INTEGER NOT NULL, server_id INTEGER UNSIGNED NOT NULL, sql_text MEDIUMTEXT NOT NULL) engine=CSV CHARACTER SET utf8 comment=\"Slow log\"', 'SET @dummy = 0');
+
+PREPARE stmt FROM @str;
+EXECUTE stmt;
+DROP PREPARE stmt;"
+
+SET_START_POSITION="SET GLOBAL wsrep_start_position='$UUID:$SEQNO';"
+
+#MYSQL="@bindir@/mysql -u'$USER' -p'$PSWD' -h'$HOST' -P'$PORT'"
+MYSQL="mysql $AUTH -h$HOST -P$PORT --disable-reconnect --connect_timeout=10"
+
+# need to disable logging when loading the dump
+# reason is that dump contains ALTER TABLE for log tables, and
+# this causes an error if logging is enabled
+GENERAL_LOG_OPT=`$MYSQL --skip-column-names -e"$STOP_WSREP SELECT @@GENERAL_LOG"`
+SLOW_LOG_OPT=`$MYSQL --skip-column-names -e"$STOP_WSREP SELECT @@SLOW_QUERY_LOG"`
+$MYSQL -e"$STOP_WSREP SET GLOBAL GENERAL_LOG=OFF"
+$MYSQL -e"$STOP_WSREP SET GLOBAL SLOW_QUERY_LOG=OFF"
+
+# commands to restore log settings
+RESTORE_GENERAL_LOG="SET GLOBAL GENERAL_LOG=$GENERAL_LOG_OPT;"
+RESTORE_SLOW_QUERY_LOG="SET GLOBAL SLOW_QUERY_LOG=$SLOW_LOG_OPT;"
+
+if [ $BYPASS -eq 0 ]
+then
+    (echo $STOP_WSREP && $MYSQLDUMP && echo $CSV_TABLES_FIX \
+    && echo $RESTORE_GENERAL_LOG && echo $RESTORE_SLOW_QUERY_LOG \
+    && echo $SET_START_POSITION \
+    || echo "SST failed to complete;") | $MYSQL
+else
+    echo "Bypassing state dump." >&2
+    echo $SET_START_POSITION | $MYSQL
+fi
+
+#

=== added file 'scripts/wsrep_sst_rsync.sh'
--- old/scripts/wsrep_sst_rsync.sh	1970-01-01 00:00:00 +0000
+++ new/scripts/wsrep_sst_rsync.sh	2012-01-19 16:57:41 +0000
@@ -0,0 +1,213 @@
+#!/bin/bash -ue
+
+# Copyright (C) 2010 Codership Oy
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; version 2 of the License.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; see the file COPYING. If not, write to the
+# Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston
+# MA  02110-1301  USA.
+
+# This is a reference script for rsync-based state snapshot tansfer
+
+RSYNC_PID=
+RSYNC_CONF=
+
+cleanup_joiner()
+{
+    echo "Joiner cleanup:" >&2
+set -x
+    local PID=$(cat "$RSYNC_PID" 2>/dev/null || echo 0)
+    [ "0" != "$PID" ] && kill $PID && sleep 0.5 && kill -9 $PID || :
+set +x
+    rm -rf "$RSYNC_CONF"
+    rm -rf "$MAGIC_FILE"
+    rm -rf "$RSYNC_PID"
+}
+
+check_pid()
+{
+    local pid_file=$1
+    [ -r $pid_file ] && ps -p $(cat $pid_file) >/dev/null 2>&1
+}
+
+check_pid_and_port()
+{
+    local pid_file=$1
+    local rsync_pid=$(cat $pid_file)
+    local rsync_port=$2
+
+    check_pid $pid_file && \
+    netstat -anpt 2>/dev/null | \
+    grep LISTEN | grep \:$rsync_port | grep $rsync_pid/rsync >/dev/null
+}
+
+ROLE=$1
+ADDR=$2
+AUTH=$3
+DATA=$4
+CONF=$5
+
+MAGIC_FILE="$DATA/rsync_sst_complete"
+rm -rf "$MAGIC_FILE"
+
+if [ "$ROLE" = "donor" ]
+then
+    UUID=$6
+    SEQNO=$7
+    BYPASS=$8
+
+    if [ $BYPASS -eq 0 ]
+    then
+
+        FLUSHED="$DATA/tables_flushed"
+        rm -rf "$FLUSHED"
+
+        # Use deltaxfer only for WAN
+        inv=$(basename $0)
+        [ "$inv" = "wsrep_sst_rsync_wan" ] && WHOLE_FILE_OPT="" \
+                                           || WHOLE_FILE_OPT="--whole-file"
+        echo "flush tables"
+
+        # wait for tables flushed and state ID written to the file
+        while [ ! -r "$FLUSHED" ] && ! grep -q ':' "$FLUSHED" >/dev/null 2>&1
+        do
+            sleep 0.2
+        done
+
+        STATE="$(cat $FLUSHED)"
+        rm -rf "$FLUSHED"
+
+        sync
+
+        # Old filter - include everything except selected
+        # FILTER=(--exclude '*.err' --exclude '*.pid' --exclude '*.sock' \
+        #         --exclude '*.conf' --exclude core --exclude 'galera.*' \
+        #         --exclude grastate.txt --exclude '*.pem' \
+        #         --exclude '*.[0-9][0-9][0-9][0-9][0-9][0-9]' --exclude '*.index')
+
+        # New filter - exclude everything except dirs (schemas) and innodb files
+        FILTER=(-f '+ /ibdata*' -f '+ /ib_logfile*' -f '+ */' -f '-! */*')
+
+        RC=0
+        rsync --archive --no-times --ignore-times --inplace --delete --quiet \
+              $WHOLE_FILE_OPT "${FILTER[@]}" "$DATA" rsync://$ADDR || RC=$?
+
+        [ $RC -ne 0 ] && echo "rsync returned code $RC:" >> /dev/stderr
+
+        case $RC in
+        0)  RC=0   # Success
+            ;;
+        12) RC=71  # EPROTO
+            echo "rsync server on the other end has incompatible protocol. " \
+                 "Make sure you have the same version of rsync on all nodes."\
+                 >> /dev/stderr
+            ;;
+        22) RC=12  # ENOMEM
+            ;;
+        *)  RC=255 # unknown error
+            ;;
+        esac
+
+        [ $RC -ne 0 ] && exit $RC
+
+    else # BYPASS
+        STATE="$UUID:$SEQNO"
+    fi
+
+    echo "continue" # now server can resume updating data
+
+    echo "$STATE" > "$MAGIC_FILE"
+    rsync -aqc "$MAGIC_FILE" rsync://$ADDR
+
+    echo "done $STATE"
+
+elif [ "$ROLE" = "joiner" ]
+then
+    MYSQLD_PID=$6
+
+    MODULE="rsync_sst"
+
+    RSYNC_PID="$DATA/$MODULE.pid"
+
+    if check_pid $RSYNC_PID
+    then
+        echo "rsync daemon already running."
+        exit 114 # EALREADY
+    fi
+    rm -rf "$RSYNC_PID"
+
+    RSYNC_PORT=$(echo $ADDR | awk -F ':' '{ print $2 }')
+    if [ -z "$RSYNC_PORT" ]
+    then
+        RSYNC_PORT=4444
+        ADDR="$(echo $ADDR | awk -F ':' '{ print $1 }'):$RSYNC_PORT"
+    fi
+
+    trap "exit 32" HUP PIPE
+    trap "exit 3"  INT TERM
+    trap cleanup_joiner EXIT
+
+    MYUID=$(id -u)
+    MYGID=$(id -g)
+    RSYNC_CONF="$DATA/$MODULE.conf"
+
+cat << EOF > "$RSYNC_CONF"
+pid file = $RSYNC_PID
+use chroot = no
+[$MODULE]
+	path = $DATA
+	read only = no
+	timeout = 300
+	uid = $MYUID
+	gid = $MYGID
+EOF
+
+#    rm -rf "$DATA"/ib_logfile* # we don't want old logs around
+
+    # listen at all interfaces (for firewalled setups)
+    rsync --daemon --port $RSYNC_PORT --config "$RSYNC_CONF"
+
+    until check_pid_and_port $RSYNC_PID $RSYNC_PORT
+    do
+        sleep 0.2
+    done
+
+    echo "ready $ADDR/$MODULE"
+
+    # wait for SST to complete by monitoring magic file
+    while [ ! -r "$MAGIC_FILE" ] && check_pid "$RSYNC_PID" && \
+          ps -p $MYSQLD_PID >/dev/null
+    do
+        sleep 1
+    done
+
+    if ! ps -p $MYSQLD_PID >/dev/null
+    then
+        echo "Parent mysqld process (PID:$MYSQLD_PID) terminated unexpectedly." >&2
+        exit 32
+    fi
+
+    if [ -r "$MAGIC_FILE" ]
+    then
+        cat "$MAGIC_FILE" # output UUID:seqno
+    else
+        # this message should cause joiner to abort
+        echo "rsync process ended without creating '$MAGIC_FILE'"
+    fi
+
+#    cleanup_joiner
+else
+    echo "Unrecognized role: $ROLE"
+    exit 22 # EINVAL
+fi
+
+exit 0

=== modified file 'sql/Makefile.am'
--- old/sql/Makefile.am	2012-02-15 16:21:38 +0000
+++ new/sql/Makefile.am	2012-04-19 19:26:55 +0000
@@ -22,7 +22,8 @@
 pkgplugindir =		$(pkglibdir)/plugin
 INCLUDES =		@ZLIB_INCLUDES@ \
 			-I$(top_builddir)/include -I$(top_srcdir)/include \
-			-I$(top_srcdir)/regex -I$(srcdir) $(openssl_includes)
+			-I$(top_srcdir)/regex -I$(srcdir) $(openssl_includes) \
+			@WSREP_INCLUDES@
 WRAPLIBS=		@WRAPLIBS@
 SUBDIRS =		share
 libexec_PROGRAMS =	mysqld
@@ -37,13 +38,14 @@
 			$(top_builddir)/dbug/libdbug.a \
 			$(top_builddir)/regex/libregex.a \
 			$(top_builddir)/strings/libmystrings.a
-mysqld_DEPENDENCIES=	@mysql_plugin_libs@ $(SUPPORTING_LIBS) libndb.la
+mysqld_DEPENDENCIES=	@mysql_plugin_libs@ $(SUPPORTING_LIBS) libndb.la @WSREP_LIBS@
 LDADD = $(SUPPORTING_LIBS) @ZLIB_LIBS@ @NDB_SCI_LIBS@
 mysqld_LDADD =		libndb.la \
 			@MYSQLD_EXTRA_LDFLAGS@ \
 			@mysql_plugin_libs@ \
 			$(LDADD)  $(CXXLDFLAGS) $(WRAPLIBS) @LIBDL@ \
-			$(yassl_libs) $(openssl_libs) @MYSQLD_EXTRA_LIBS@
+			$(yassl_libs) $(openssl_libs) @MYSQLD_EXTRA_LIBS@ \
+			@WSREP_LIBS@
 
 noinst_HEADERS =	item.h item_func.h item_sum.h item_cmpfunc.h \
 			item_strfunc.h item_timefunc.h \
@@ -72,7 +74,7 @@
 			sp_head.h sp_pcontext.h sp_rcontext.h sp.h sp_cache.h \
 			parse_file.h sql_view.h	sql_trigger.h \
 			sql_array.h sql_cursor.h events.h scheduler.h \
-                        event_db_repository.h event_queue.h \
+			event_db_repository.h event_queue.h \
 			sql_plugin.h authors.h event_parse_data.h \
 			event_data_objects.h event_scheduler.h \
 			sql_partition.h partition_info.h partition_element.h \
@@ -124,6 +126,12 @@
 			sql_builtin.cc sql_tablespace.cc partition_info.cc \
 			sql_servers.cc event_parse_data.cc
 
+if ENABLE_WSREP
+noinst_HEADERS += wsrep_mysqld.h wsrep_priv.h
+mysqld_SOURCES += wsrep_utils.cc wsrep_notify.cc wsrep_mysqld.cc \
+		  wsrep_hton.cc wsrep_check_opts.cc wsrep_var.cc wsrep_sst.cc
+endif
+
 nodist_mysqld_SOURCES =	mini_client_errors.c pack.c client.c my_time.c my_user.c 
 
 libndb_la_CPPFLAGS=	@ndbcluster_includes@

=== modified file 'sql/handler.cc'
--- old/sql/handler.cc	2011-10-25 13:46:38 +0000
+++ new/sql/handler.cc	2012-01-19 22:42:33 +0000
@@ -31,7 +31,9 @@
 #ifdef WITH_PARTITION_STORAGE_ENGINE
 #include "ha_partition.h"
 #endif
-
+#ifdef WITH_WSREP
+#include "wsrep_mysqld.h"
+#endif
 /*
   While we have legacy_db_type, we have this array to
   check for dups and to find handlerton from legacy_db_type.
@@ -1174,9 +1176,25 @@
         */
         if ((err= ht->prepare(ht, thd, all)))
         {
-          my_error(ER_ERROR_DURING_COMMIT, MYF(0), err);
+#ifdef WITH_WSREP
+          if (ht->db_type== DB_TYPE_WSREP)
+          {
+	    error= 1;
+	    /* avoid sending error, if we need to replay */
+            if (thd->wsrep_conflict_state!= MUST_REPLAY)
+            {
+              my_error(ER_LOCK_DEADLOCK, MYF(0), err);
+            }
+          }
+          else
+          {
+            /* not wsrep hton, bail to native mysql behavior */
+#endif
           error= 1;
-        }
+#ifdef WITH_WSREP
+          }
+#endif
+     }
         status_var_increment(thd->status_var.ha_prepare_count);
       }
       DBUG_EXECUTE_IF("crash_commit_after_prepare", DBUG_SUICIDE(););
@@ -1204,7 +1222,11 @@
   }
   /* Free resources and perform other cleanup even for 'empty' transactions. */
   else if (is_real_trans)
+#ifdef WITH_WSREP
+    thd->transaction.cleanup(thd);
+#else
     thd->transaction.cleanup();
+#endif
 #endif /* USING_TRANSACTIONS */
   DBUG_RETURN(error);
 }
@@ -1227,6 +1249,16 @@
   bool is_real_trans=all || thd->transaction.all.ha_list == 0;
   Ha_trx_info *ha_info= trans->ha_list, *ha_info_next;
   DBUG_ENTER("ha_commit_one_phase");
+#ifdef WITH_WSREP
+#ifdef WSREP_PROC_INFO
+  char info[64]= { 0, };
+  snprintf (info, sizeof(info) - 1, "ha_commit_one_phase(%lld)",
+            (long long)thd->wsrep_trx_seqno);
+#else
+  const char info[]="ha_commit_one_phase()";
+#endif /* WSREP_PROC_INFO */
+  const char* tmp_info= thd_proc_info(thd, info);
+#endif /* WITH_WSREP */
 #ifdef USING_TRANSACTIONS
   if (ha_info)
   {
@@ -1256,8 +1288,15 @@
   }
   /* Free resources and perform other cleanup even for 'empty' transactions. */
   if (is_real_trans)
+#ifdef WITH_WSREP
+    thd->transaction.cleanup(thd);
+#else
     thd->transaction.cleanup();
+#endif /* WITH_WSREP */
 #endif /* USING_TRANSACTIONS */
+#ifdef WITH_WSREP
+  thd_proc_info(thd, tmp_info);
+#endif /* WITH_WSREP */
   DBUG_RETURN(error);
 }
 
@@ -1327,7 +1366,11 @@
   }
   /* Always cleanup. Even if there nht==0. There may be savepoints. */
   if (is_real_trans)
+#ifdef WITH_WSREP
+    thd->transaction.cleanup(thd);
+#else
     thd->transaction.cleanup();
+#endif /* WITH_WSREP */
 #endif /* USING_TRANSACTIONS */
   if (all)
     thd->transaction_rollback_request= FALSE;
@@ -1592,7 +1635,9 @@
     for now, only InnoDB supports 2pc. It means we can always safely
     rollback all pending transactions, without risking inconsistent data
   */
+#ifndef WITH_WSREP
   DBUG_ASSERT(total_ha_2pc == (ulong) opt_bin_log+1); // only InnoDB and binlog
+#endif
   tc_heuristic_recover= TC_HEURISTIC_RECOVER_ROLLBACK; // forcing ROLLBACK
   info.dry_run=FALSE;
 #endif
@@ -2477,7 +2522,12 @@
                                           variables->auto_increment_increment);
     auto_inc_intervals_count++;
     /* Row-based replication does not need to store intervals in binlog */
+#ifdef WITH_WSREP
+    if (((wsrep_emulate_bin_log) || mysql_bin_log.is_open()) &&
+	!thd->current_stmt_binlog_row_based)
+#else
     if (mysql_bin_log.is_open() && !thd->current_stmt_binlog_row_based)
+#endif /* WITH_WSREP */
         thd->auto_inc_intervals_in_cur_stmt_for_binlog.append(auto_inc_interval_for_cur_row.minimum(),
                                                               auto_inc_interval_for_cur_row.values(),
                                                               variables->auto_increment_increment);
@@ -4513,7 +4563,11 @@
   return (thd->current_stmt_binlog_row_based &&
           table->s->cached_row_logging_check &&
           (thd->options & OPTION_BIN_LOG) &&
+#ifdef WITH_WSREP
+          (wsrep_emulate_bin_log || mysql_bin_log.is_open()));
+#else
           mysql_bin_log.is_open());
+#endif
 }
 
 
@@ -4738,8 +4792,6 @@
   /* fallback to use all columns in the table to identify row */
   table->use_all_columns();
 }
-
-
 /** @brief
   Dummy function which accept information about log files which is not need
   by handlers
@@ -4751,7 +4803,38 @@
   DBUG_VOID_RETURN;
 }
 
+#ifdef WITH_WSREP
+/**
+  @details
+  This function makes the storage engine to force te victim transaction
+  to abort. Currently, only innodb has this functionality, but any SE
+  implementing the wsrep API should provide this service to support
+  multi-master operation.
+
+  @param bf_thd       brute force THD asking for the abort
+  @param victim_thd   victim THD to be aborted
+
+  @return
+    always 0
+*/
+
+int ha_wsrep_abort_transaction(THD *bf_thd, THD *victim_thd, my_bool signal)
+{
+  DBUG_ENTER("ha_wsrep_abort_transaction");
+
+  handlerton *hton= installed_htons[DB_TYPE_INNODB];
+  if (hton && hton->wsrep_abort_transaction)
+  {
+    hton->wsrep_abort_transaction(hton, bf_thd, victim_thd, signal);
+  } 
+  else 
+  {
+    WSREP_WARN("cannot abort InnoDB transaction");
+  }
 
+  DBUG_RETURN(0);
+}
+#endif /* WITH_WSREP */
 #ifdef TRANS_LOG_MGM_EXAMPLE_CODE
 /*
   Example of transaction log management functions based on assumption that logs

=== modified file 'sql/handler.h'
--- old/sql/handler.h	2011-07-03 15:47:37 +0000
+++ new/sql/handler.h	2011-10-12 21:45:28 +0000
@@ -278,6 +278,7 @@
   DB_TYPE_MEMCACHE,
   DB_TYPE_FALCON,
   DB_TYPE_MARIA,
+  DB_TYPE_WSREP,
   DB_TYPE_FIRST_DYNAMIC=42,
   DB_TYPE_DEFAULT=127 // Must be last
 };
@@ -714,6 +715,10 @@
                      const char *wild, bool dir, List<LEX_STRING> *files);
    int (*table_exists_in_engine)(handlerton *hton, THD* thd, const char *db,
                                  const char *name);
+#ifdef WITH_WSREP
+  int (*wsrep_abort_transaction)(handlerton *hton, THD *bf_thd, THD *victim_thd,
+				 my_bool signal);
+#endif /* WITH_WSREP */
    uint32 license; /* Flag for Engine License */
    void *data; /* Location for engines to keep personal structures */
 };
@@ -2052,6 +2057,10 @@
 int ha_savepoint(THD *thd, SAVEPOINT *sv);
 int ha_release_savepoint(THD *thd, SAVEPOINT *sv);
 
+#ifdef WITH_WSREP
+int ha_wsrep_abort_transaction(THD *bf_thd, THD *victim_thd, my_bool signal);
+#endif /* WITH_WSREP */
+
 /* these are called by storage engines */
 void trans_register_ha(THD *thd, bool all, handlerton *ht);
 
@@ -2081,3 +2090,6 @@
 #define ha_binlog_wait(a) do {} while (0)
 #define ha_binlog_end(a)  do {} while (0)
 #endif
+#ifdef WITH_WSREP
+void wsrep_brute_force_aborts();
+#endif

=== modified file 'sql/item_func.cc'
--- old/sql/item_func.cc	2011-07-03 15:47:37 +0000
+++ new/sql/item_func.cc	2011-10-12 21:45:28 +0000
@@ -2135,7 +2135,18 @@
     TODO: do not do reinit 'rand' for every execute of PS/SP if
     args[0] is a constant.
   */
+#ifdef WITH_WSREP
+  uint32 tmp;
+  if (current_thd->wsrep_exec_mode==REPL_RECV) {
+    tmp= current_thd->wsrep_rand;
+  } 
+  else
+  {
+    tmp= current_thd->wsrep_rand= (uint32) arg->val_int();
+  }
+#else
   uint32 tmp= (uint32) arg->val_int();
+#endif
   randominit(rand, (uint32) (tmp*0x10001L+55555555L),
              (uint32) (tmp*0x10000001L));
 }

=== modified file 'sql/lock.cc'
--- old/sql/lock.cc	2011-06-30 15:37:13 +0000
+++ new/sql/lock.cc	2011-11-10 11:35:30 +0000
@@ -79,6 +79,10 @@
 #include <hash.h>
 #include <assert.h>
 
+#ifdef WITH_WSREP
+#include "wsrep_mysqld.h"
+#endif /* WITH_WSREP */
+
 /**
   @defgroup Locking Locking
   @{
@@ -274,7 +278,9 @@
     /* Copy the lock data array. thr_multi_lock() reorders its contens. */
     memcpy(sql_lock->locks + sql_lock->lock_count, sql_lock->locks,
            sql_lock->lock_count * sizeof(*sql_lock->locks));
-    /* Lock on the copied half of the lock data array. */
+#ifdef WITH_WSREP
+    thd->main_lock_id.info->in_lock_tables= thd->in_lock_tables;
+#endif    /* Lock on the copied half of the lock data array. */
     rc= thr_lock_errno_to_mysql[(int) thr_multi_lock(sql_lock->locks +
                                                      sql_lock->lock_count,
                                                      sql_lock->lock_count,
@@ -316,8 +322,11 @@
       thd->locked=0;
       break;
     }
+#ifdef WITH_WSREP
+    thd_proc_info(thd, "mysql_lock_tables(): unlocking tables I");
+#else /* WITH_WSREP */
     thd_proc_info(thd, 0);
-
+#endif /* WITH_WSREP */
     /* some table was altered or deleted. reopen tables marked deleted */
     mysql_unlock_tables(thd,sql_lock);
     thd->locked=0;
@@ -331,7 +340,11 @@
     if (wait_for_tables(thd))
       break;					// Couldn't open tables
   }
+#ifdef WITH_WSREP
+  thd_proc_info(thd, "mysql_lock_tables(): unlocking tables II");
+#else /* WITH_WSREP */
   thd_proc_info(thd, 0);
+#endif /* WITH_WSREP */
   if (thd->killed)
   {
     thd->send_kill_message();
@@ -343,6 +356,9 @@
   }
 
   thd->set_time_after_lock();
+#ifdef WITH_WSREP
+  thd_proc_info(thd, "exit mysqld_lock_tables()");
+#endif /* WITH_WSREP */
   DBUG_RETURN (sql_lock);
 }
 
@@ -1454,6 +1470,10 @@
   if (thd->global_read_lock == MADE_GLOBAL_READ_LOCK_BLOCK_COMMIT)
     --global_read_lock_blocks_commit;
   pthread_mutex_unlock(&LOCK_global_read_lock);
+#ifdef WITH_WSREP
+  wsrep_locked_seqno= WSREP_SEQNO_UNDEFINED;
+  wsrep->resume(wsrep);
+#endif /* WITH_WSREP */
   /* Send the signal outside the mutex to avoid a context switch */
   if (!tmp)
   {
@@ -1465,9 +1485,16 @@
   DBUG_VOID_RETURN;
 }
 
+#ifndef WITH_WSREP
 #define must_wait (global_read_lock &&                             \
                    (is_not_commit ||                               \
                     global_read_lock_blocks_commit))
+#else /* WITH_WSREP */
+/* wsrep appliers are blocked in make_global_read_lock_block_commit() */
+#define must_wait ((global_read_lock && thd->wsrep_exec_mode==LOCAL_STATE) && \
+                   (is_not_commit ||                                          \
+                    global_read_lock_blocks_commit))
+#endif /* WITH_WSREP */
 
 bool wait_if_global_read_lock(THD *thd, bool abort_on_refresh,
                               bool is_not_commit)
@@ -1484,6 +1511,10 @@
   safe_mutex_assert_not_owner(&LOCK_open);
 
   (void) pthread_mutex_lock(&LOCK_global_read_lock);
+#ifdef WITH_WSREP
+  if (global_read_lock && thd->wsrep_conflict_state == REPLAYING)
+    WSREP_INFO("replaying THD ignoring GRL: %ld", thd->wsrep_trx_seqno);
+#endif
   if ((need_exit_cond= must_wait))
   {
     if (thd->global_read_lock)		// This thread had the read locks
@@ -1568,7 +1599,33 @@
   if ((error= test(thd->killed)))
     global_read_lock_blocks_commit--; // undo what we did
   else
+#ifdef WITH_WSREP
+  {
+    // allow wsrep appliers to continue committing so that we can lock provider
+    (void) pthread_mutex_unlock(&LOCK_global_read_lock);
+    long long ret = wsrep->pause(wsrep);
+    (void) pthread_mutex_lock(&LOCK_global_read_lock);
+    if (ret >= 0)
+    {
+      wsrep_locked_seqno= ret;
+    }
+    else if (ret != -ENOSYS) /* -ENOSYS - no provider */
+    {
+      WSREP_ERROR("Failed to pause provider: %lld (%s)", -ret, strerror(-ret));
+      error= 1;
+    }
+    if (error)
+    {
+      global_read_lock_blocks_commit--;
+    }
+    else
+    {
+#endif /* WITH_WSREP */
     thd->global_read_lock= MADE_GLOBAL_READ_LOCK_BLOCK_COMMIT;
+#ifdef WITH_WSREP
+    }
+  }
+#endif /* WITH_WSREP */
   thd->exit_cond(old_message); // this unlocks LOCK_global_read_lock
   DBUG_RETURN(error);
 }

=== modified file 'sql/log.cc'
--- old/sql/log.cc	2011-11-29 14:52:47 +0000
+++ new/sql/log.cc	2012-03-04 20:20:11 +0000
@@ -39,6 +39,10 @@
 
 #include <mysql/plugin.h>
 
+#ifdef WITH_WSREP
+#include "wsrep_mysqld.h"
+#endif /* WITH_WSREP */
+
 /* max size of the log message */
 #define MAX_LOG_BUFFER_SIZE 1024
 #define MAX_USER_HOST_SIZE 512
@@ -260,6 +264,9 @@
 };
 
 handlerton *binlog_hton;
+#ifdef WITH_WSREP
+extern handlerton *wsrep_hton;
+#endif
 
 bool LOGGER::is_log_table_enabled(uint log_table_type)
 {
@@ -274,6 +281,123 @@
   }
 }
 
+#ifdef WITH_WSREP
+IO_CACHE * get_trans_log(THD * thd)
+{
+  class binlog_trx_data* trx_data = (class binlog_trx_data*)
+    thd_get_ha_data(thd, binlog_hton);
+  if (trx_data)
+  {
+    return &(trx_data->trans_log);
+  } 
+  else
+  {
+    WSREP_DEBUG("binlog cache not initialized, conn :%ld", thd->thread_id);
+    return NULL;
+  }
+}
+
+
+bool wsrep_trans_cache_is_empty(THD *thd)
+{
+  bool res= TRUE;
+
+  if (thd_sql_command((const THD*) thd) != SQLCOM_SELECT)
+    res= FALSE;
+  else
+  {
+    IO_CACHE *trans_log = get_trans_log(thd);
+    if (trans_log)
+    {
+      res= (my_b_tell(trans_log) ==0);
+    }
+  }
+  return res;
+}
+
+void thd_binlog_flush_pending_rows_event(THD *thd, bool stmt_end)
+{
+  thd->binlog_flush_pending_rows_event(stmt_end);
+}
+void thd_binlog_trx_reset(THD * thd)
+{
+  /*
+    todo: fix autocommit select to not call the caller
+  */
+  if (thd_get_ha_data(thd, binlog_hton) != NULL)
+  {
+    ((class binlog_trx_data*)
+     thd_get_ha_data(thd, binlog_hton))->reset();
+  }
+  thd->wsrep_clear_binlog_table_maps();
+}
+/*
+  Write the contents of a cache to memory buffer.
+
+  This function quite the same as MYSQL_BIN_LOG::write_cache(),
+  with the exception that here we write in buffer instead of log file.
+ */
+
+int wsrep_write_cache(IO_CACHE *cache, uchar **buf, uint *buf_len)
+{
+
+  if (reinit_io_cache(cache, READ_CACHE, 0, 0, 0))
+    return ER_ERROR_ON_WRITE;
+  uint length= my_b_bytes_in_cache(cache);
+  uint total_length = 0;
+  uchar *buf_ptr = NULL;
+  
+  do
+  {
+    /* bail out if buffer grows too large
+       This is a temporary fix to avoid flooding replication
+       TODO: remove this check for 0.7.4 release
+     */
+    if (total_length > wsrep_max_ws_size)
+    {
+      sql_print_warning("WSREP: transaction size exceeded: %d", total_length);
+      if (reinit_io_cache(cache, WRITE_CACHE, 0, 0, 0))
+      {
+        sql_print_warning("WSREP: failed to initialize io-cache");
+      } 
+      if (buf_ptr) my_free(*buf, MYF(0));
+      *buf_len = 0;
+      return ER_ERROR_ON_WRITE;
+    }
+    if (total_length > 0)
+    {
+      *buf_len += length;
+      *buf = (uchar *)my_realloc(*buf, total_length+length, MYF(0));
+      if (!*buf)
+      {
+        sql_print_error("WSREP io cache write problem: %d %d",*buf_len,length);
+        return ER_ERROR_ON_WRITE;
+      }
+      buf_ptr = *buf+total_length;
+    }
+    else
+    {
+      if (buf_ptr != NULL)
+      {
+        sql_print_error("WSREP io cache alloc error: %d %d", *buf_len, length);
+        my_free(*buf, MYF(0));
+      }
+      if (length > 0) 
+      {
+        *buf = (uchar *) my_malloc(length, MYF(0));
+        buf_ptr = *buf;
+        *buf_len = length;
+      }
+    }
+    total_length += length;
+
+    memcpy(buf_ptr, cache->read_pos, length);
+    cache->read_pos=cache->read_end;
+  } while ((cache->file >= 0) && (length= my_b_fill(cache)));
+
+  return 0;
+}
+#endif
 
 /* Check if a given table is opened log table */
 int check_if_log_table(uint db_len, const char *db, uint table_name_len,
@@ -1308,7 +1432,11 @@
     thd->binlog_setup_trx_data();
   binlog_trx_data *const trx_data=
     (binlog_trx_data*) thd_get_ha_data(thd, binlog_hton);
+#ifdef WITH_WSREP
+  DBUG_ASSERT(wsrep_emulate_bin_log || mysql_bin_log.is_open());
+#else
   DBUG_ASSERT(mysql_bin_log.is_open());
+#endif
   *pos= trx_data->position();
   DBUG_PRINT("return", ("*pos: %lu", (ulong) *pos));
   DBUG_VOID_RETURN;
@@ -1356,7 +1484,11 @@
 int binlog_init(void *p)
 {
   binlog_hton= (handlerton *)p;
+#ifdef WITH_WSREP
+  binlog_hton->state= SHOW_OPTION_YES;
+#else
   binlog_hton->state=opt_bin_log ? SHOW_OPTION_YES : SHOW_OPTION_NO;
+#endif
   binlog_hton->db_type=DB_TYPE_BINLOG;
   binlog_hton->savepoint_offset= sizeof(my_off_t);
   binlog_hton->close_connection= binlog_close_connection;
@@ -1369,6 +1501,7 @@
   return 0;
 }
 
+
 static int binlog_close_connection(handlerton *hton, THD *thd)
 {
   binlog_trx_data *const trx_data=
@@ -1439,7 +1572,6 @@
     error= mysql_bin_log.write(thd, &trx_data->trans_log, end_ev,
                                trx_data->has_incident());
     trx_data->reset();
-
     statistic_increment(binlog_cache_use, &LOCK_status);
     if (trans_log->disk_writes != 0)
     {
@@ -1502,6 +1634,9 @@
   binlog_trx_data *const trx_data=
     (binlog_trx_data*) thd_get_ha_data(thd, binlog_hton);
 
+#ifdef WITH_WSREP
+  if (!trx_data) DBUG_RETURN(0);
+#endif /* WITH_WSREP */
   if (trx_data->empty())
   {
     // we're here because trans_log was flushed in MYSQL_BIN_LOG::log_xid()
@@ -1561,6 +1696,9 @@
   binlog_trx_data *const trx_data=
     (binlog_trx_data*) thd_get_ha_data(thd, binlog_hton);
 
+#ifdef WITH_WSREP
+  if (!trx_data) DBUG_RETURN(0);
+#endif /* WITH_WSREP */
   if (trx_data->empty()) {
     trx_data->reset();
     DBUG_RETURN(0);
@@ -4111,6 +4249,19 @@
 
   DBUG_RETURN(0);
 }
+#ifdef WITH_WSREP
+void
+THD::wsrep_start_trans_and_stmt()
+{
+  if (options & (OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN))
+  {
+    trans_register_ha(this, TRUE, wsrep_hton);
+    ha_data[wsrep_hton->slot].ha_info[1].set_trx_read_write();
+  }
+  trans_register_ha(this, FALSE, wsrep_hton);
+  ha_data[wsrep_hton->slot].ha_info[0].set_trx_read_write();
+}
+#endif /* WITH_WSREP */
 
 /*
   Function to start a statement and optionally a transaction for the
@@ -4154,6 +4305,9 @@
       trx_data->before_stmt_pos == MY_OFF_T_UNDEF)
   {
     this->binlog_set_stmt_begin();
+#ifdef WITH_WSREP
+    wsrep_start_trans_and_stmt();
+#endif
     if (options & (OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN))
       trans_register_ha(this, TRUE, binlog_hton);
     trans_register_ha(this, FALSE, binlog_hton);
@@ -4201,7 +4355,13 @@
                        table->s->table_map_id));
 
   /* Pre-conditions */
+#ifdef WITH_WSREP
+  DBUG_ASSERT(current_stmt_binlog_row_based &&
+              (wsrep_emulate_bin_log || mysql_bin_log.is_open()));
+#else
   DBUG_ASSERT(current_stmt_binlog_row_based && mysql_bin_log.is_open());
+#endif
+
   DBUG_ASSERT(table->s->table_map_id != ULONG_MAX);
 
   Table_map_log_event
@@ -4280,7 +4440,11 @@
                                                 Rows_log_event* event)
 {
   DBUG_ENTER("MYSQL_BIN_LOG::flush_and_set_pending_rows_event(event)");
+#ifdef WITH_WSREP
+  DBUG_ASSERT(wsrep_emulate_bin_log || mysql_bin_log.is_open());
+#else
   DBUG_ASSERT(mysql_bin_log.is_open());
+#endif
   DBUG_PRINT("enter", ("event: 0x%lx", (long) event));
 
   int error= 0;
@@ -4382,7 +4546,11 @@
      mostly called if is_open() *was* true a few instructions before, but it
      could have changed since.
   */
+#ifdef WITH_WSREP
+  if (wsrep_emulate_bin_log || mysql_bin_log.is_open())
+#else
   if (likely(is_open()))
+#endif
   {
     IO_CACHE *file= &log_file;
 #ifdef HAVE_REPLICATION
@@ -4535,6 +4703,37 @@
   }
 
   pthread_mutex_unlock(&LOCK_log);
+
+#ifdef WITH_WSREP
+  if (wsrep_incremental_data_collection &&
+      (wsrep_emulate_bin_log || mysql_bin_log.is_open()))
+  {
+    DBUG_ASSERT(thd->wsrep_trx_handle.trx_id != (unsigned long)-1);
+    if (!error)
+    {
+      IO_CACHE* cache= get_trans_log(thd);
+      uchar* buf= NULL;
+      uint buf_len= 0;
+
+      if (wsrep_emulate_bin_log)
+        thd->binlog_flush_pending_rows_event(false);
+      error= wsrep_write_cache(cache, &buf, &buf_len);
+      if (!error && buf_len > 0)
+      {
+        wsrep_status_t rc= wsrep->append_data(wsrep,
+                                              &thd->wsrep_trx_handle,
+                                              buf, buf_len);
+        if (rc != WSREP_OK)
+        {
+          sql_print_warning("WSREP: append_data() returned %d", rc);
+          error= 1;
+        }
+      }
+      if (buf_len) my_free(buf, MYF(0));
+    }
+  }
+#endif /* WITH_WSREP */
+
   DBUG_RETURN(error);
 }
 
@@ -4624,6 +4823,14 @@
 #ifdef HAVE_REPLICATION
   bool check_purge= false;
 #endif
+#ifdef WITH_WSREP
+  if (wsrep_to_isolation)
+    {
+      WSREP_DEBUG("avoiding binlog rotate due to TO isolation: %d", 
+		  wsrep_to_isolation);
+      DBUG_RETURN(0);
+    }
+#endif
   if (!(flags & RP_LOCK_LOG_IS_ALREADY_LOCKED))
     pthread_mutex_lock(&LOCK_log);
   if ((flags & RP_FORCE_ROTATE) ||
@@ -4898,6 +5105,9 @@
                           bool incident)
 {
   DBUG_ENTER("MYSQL_BIN_LOG::write(THD *, IO_CACHE *, Log_event *)");
+#ifdef WITH_WSREP
+  if (wsrep_emulate_bin_log) DBUG_RETURN(0);
+#endif /* WITH_WSREP */
   VOID(pthread_mutex_lock(&LOCK_log));
 
   /* NULL would represent nothing to replicate after ROLLBACK */
@@ -5483,8 +5693,8 @@
     pthread_mutex_init(&pg->lock, MY_MUTEX_INIT_FAST);
     pthread_cond_init (&pg->cond, 0);
     pg->start=(my_xid *)(data + i*tc_log_page_size);
-    pg->end=(my_xid *)(pg->start + tc_log_page_size);
     pg->size=pg->free=tc_log_page_size/sizeof(my_xid);
+    pg->end=pg->start + pg->size;
   }
   pages[0].size=pages[0].free=
                 (tc_log_page_size-TC_LOG_HEADER_SIZE)/sizeof(my_xid);

=== modified file 'sql/log.h'
--- old/sql/log.h	2011-06-30 15:37:13 +0000
+++ new/sql/log.h	2011-12-15 14:53:06 +0000
@@ -168,7 +168,12 @@
   TODO use mmap instead of IO_CACHE for binlog
   (mmap+fsync is two times faster than write+fsync)
 */
-
+#ifdef WITH_WSREP
+extern my_bool wsrep_emulate_bin_log;
+Log_event* wsrep_read_log_event(
+  char **arg_buf, size_t *arg_buf_len,
+  const Format_description_log_event *description_event);
+#endif
 class MYSQL_LOG
 {
 public:
@@ -586,6 +591,12 @@
     statement-based except for cases where only row-based can work (UUID()
     etc):
   */
+#ifdef WITH_WSREP
+  BINLOG_FORMAT_STMT= 0, // statement-based
+  BINLOG_FORMAT_ROW= 1, // row_based
+  BINLOG_FORMAT_UNSPEC= 2,
+  BINLOG_FORMAT_MIXED= 3 // mixed format is disabled
+#else
   BINLOG_FORMAT_MIXED= 0,
   BINLOG_FORMAT_STMT= 1, // statement-based
   BINLOG_FORMAT_ROW= 2, // row_based
@@ -595,9 +606,18 @@
   the user has explicitely specified a binlog format at startup or not.
 */
   BINLOG_FORMAT_UNSPEC= 3
+#endif
 };
 extern TYPELIB binlog_format_typelib;
 
+#ifdef WITH_WSREP
+IO_CACHE * get_trans_log(THD * thd);
+bool wsrep_trans_cache_is_empty(THD *thd);
+void thd_binlog_flush_pending_rows_event(THD *thd, bool stmt_end);
+void thd_binlog_trx_reset(THD * thd);
+void thd_binlog_rollback_stmt(THD * thd);
+int wsrep_write_cache(IO_CACHE *cache, uchar **buf, uint *buf_len);
+#endif
 int query_error_code(THD *thd, bool not_killed);
 
 #endif /* LOG_H */

=== modified file 'sql/log_event.cc'
--- old/sql/log_event.cc	2011-07-15 11:42:06 +0000
+++ new/sql/log_event.cc	2011-11-24 22:37:43 +0000
@@ -35,6 +35,9 @@
 #include "rpl_record.h"
 #include <my_dir.h>
 
+#if WITH_WSREP
+#include "wsrep_mysqld.h"
+#endif
 #endif /* MYSQL_CLIENT */
 
 #include <base64.h>
@@ -2454,6 +2457,9 @@
 {
   time_t end_time;
 
+#ifdef WITH_WSREP
+  thd->wsrep_PA_safe= false;
+#endif /* WITH_WSREP */
   memset(&user, 0, sizeof(user));
   memset(&host, 0, sizeof(host));
 
@@ -6345,7 +6351,11 @@
     end_io_cache(&file);
   if (fd >= 0)
     my_close(fd, MYF(0));
+#ifdef WITH_WSREP
+  thd_proc_info(thd, "exit Create_file_log_event::do_apply_event()");
+#else /* WITH_WSREP */
   thd_proc_info(thd, 0);
+#endif /* WITH_WSREP */
   return error != 0;
 }
 #endif /* defined(HAVE_REPLICATION) && !defined(MYSQL_CLIENT) */
@@ -6510,7 +6520,11 @@
 err:
   if (fd >= 0)
     my_close(fd, MYF(0));
+#ifdef WITH_WSREP
+  thd_proc_info(thd, "exit Append_block_log_event::do_apply_event()");
+#else /* WITH_WSREP */
   thd_proc_info(thd, 0);
+#endif /* WITH_WSREP */
   DBUG_RETURN(error);
 }
 #endif
@@ -7452,7 +7466,18 @@
 
     if (simple_open_n_lock_tables(thd, rli->tables_to_lock))
     {
+#ifdef WITH_WSREP
+      uint actual_error= ER_SERVER_SHUTDOWN;
+      if (!thd->main_da.is_error())
+      {
+        sql_print_information("WSREP, BF applier interrupted in log_event.cc");
+      } 
+      else
+        actual_error= thd->main_da.sql_errno();
+
+#else
       uint actual_error= thd->main_da.sql_errno();
+#endif
       if (thd->is_slave_error || thd->is_fatal_error)
       {
         /*
@@ -8941,8 +8966,24 @@
 Write_rows_log_event::do_exec_row(const Relay_log_info *const rli)
 {
   DBUG_ASSERT(m_table != NULL);
+#ifdef WITH_WSREP
+#ifdef WSREP_PROC_INFO
+  char info[64];
+  info[sizeof(info) - 1] = '\0';
+  snprintf(info, sizeof(info) - 1, "Write_rows_log_event::write_row(%lld)",
+           (long long) thd->wsrep_trx_seqno);
+  const char* tmp = thd_proc_info(thd, info);
+#else
+  const char* tmp = thd_proc_info(thd,"Write_rows_log_event::write_row()");
+#endif /* WSREP_PROC_INFO */
+#endif /* WITH_WSREP */
+
   int error= write_row(rli, (slave_exec_mode & SLAVE_EXEC_MODE_IDEMPOTENT));
 
+#ifdef WITH_WSREP
+  thd_proc_info(thd, tmp);
+#endif /* WITH_WSREP */
+
   if (error && !thd->is_error())
   {
     DBUG_ASSERT(0);
@@ -9473,13 +9514,39 @@
   int error;
   DBUG_ASSERT(m_table != NULL);
 
+#ifdef WITH_WSREP
+#ifdef WSREP_PROC_INFO
+  char info[64];
+  info[sizeof(info) - 1] = '\0';
+  snprintf(info, sizeof(info) - 1, "Delete_rows_log_event::find_row(%lld)",
+           (long long) thd->wsrep_trx_seqno);
+  const char* tmp = thd_proc_info(thd, info);
+#else
+  const char* tmp = thd_proc_info(thd,"Delete_rows_log_event::find_row()");
+#endif /* WSREP_PROC_INFO */
+#endif /* WITH_WSREP */
+
   if (!(error= find_row(rli))) 
   { 
     /*
       Delete the record found, located in record[0]
     */
+#ifdef WITH_WSREP
+#ifdef WSREP_PROC_INFO
+    snprintf(info, sizeof(info) - 1,
+             "Delete_rows_log_event::ha_delete_row(%lld)",
+             (long long) thd->wsrep_trx_seqno);
+    thd_proc_info(thd, info);
+#else
+    thd_proc_info(thd,"Delete_rows_log_event::ha_delete_row()");
+#endif /* WSREP_PROC_INFO */
+#endif /* WITH_WSREP */
     error= m_table->file->ha_delete_row(m_table->record[0]);
   }
+
+#ifdef WITH_WSREP
+  thd_proc_info(thd, tmp);
+#endif /* WITH_WSREP */
   return error;
 }
 
@@ -9596,6 +9663,17 @@
 {
   DBUG_ASSERT(m_table != NULL);
 
+#ifdef WITH_WSREP
+#ifdef WSREP_PROC_INFO
+  char info[64];
+  info[sizeof(info) - 1] = '\0';
+  snprintf(info, sizeof(info) - 1, "Update_rows_log_event::find_row(%lld)",
+           (long long) thd->wsrep_trx_seqno);
+  const char* tmp = thd_proc_info(thd, info);
+#else
+  const char* tmp = thd_proc_info(thd,"Update_rows_log_event::find_row()");
+#endif /* WSREP_PROC_INFO */
+#endif /* WITH_WSREP */
   int error= find_row(rli); 
   if (error)
   {
@@ -9622,6 +9700,16 @@
   store_record(m_table,record[1]);
 
   m_curr_row= m_curr_row_end;
+#ifdef WITH_WSREP
+#ifdef WSREP_PROC_INFO
+  snprintf(info, sizeof(info) - 1,
+           "Update_rows_log_event::unpack_current_row(%lld)",
+           (long long) thd->wsrep_trx_seqno);
+  thd_proc_info(thd, info);
+#else
+  thd_proc_info(thd,"Update_rows_log_event::unpack_current_row()");
+#endif /* WSREP_PROC_INFO */
+#endif /* WITH_WSREP */
   /* this also updates m_curr_row_end */
   if ((error= unpack_current_row(rli)))
     return error;
@@ -9640,10 +9728,23 @@
   DBUG_DUMP("new values", m_table->record[0], m_table->s->reclength);
 #endif
 
+#ifdef WITH_WSREP
+#ifdef WSREP_PROC_INFO
+  snprintf(info, sizeof(info) - 1,
+           "Update_rows_log_event::ha_update_row(%lld)",
+           (long long) thd->wsrep_trx_seqno);
+  thd_proc_info(thd, info);
+#else
+  thd_proc_info(thd,"Update_rows_log_event::ha_update_row()");
+#endif /* WSREP_PROC_INFO */
+#endif /* WITH_WSREP */
   error= m_table->file->ha_update_row(m_table->record[1], m_table->record[0]);
   if (error == HA_ERR_RECORD_IS_THE_SAME)
     error= 0;
 
+#ifdef WITH_WSREP
+  thd_proc_info(thd, tmp);
+#endif /* WITH_WSREP */
   return error;
 }
 
@@ -9803,3 +9904,50 @@
   open_cached_file(&body_cache, NULL, NULL, 0, flags);
 }
 #endif
+
+#if WITH_WSREP && !defined(MYSQL_CLIENT)
+Format_description_log_event *wsrep_format_desc; // TODO: free them at the end
+
+/*
+  read the first event from (*buf). The size of the (*buf) is (*buf_len).
+  At the end (*buf) is shitfed to point to the following event or NULL and
+  (*buf_len) will be changed to account just being read bytes of the 1st event.
+*/
+Log_event* wsrep_read_log_event(
+  char **arg_buf, size_t *arg_buf_len,
+  const Format_description_log_event *description_event)
+{
+  DBUG_ENTER("wsrep_read_log_event");
+  char *head= (*arg_buf);
+
+  uint data_len = uint4korr(head + EVENT_LEN_OFFSET);
+  char *buf= (*arg_buf);
+  const char *error= 0;
+  Log_event *res=  0;
+#ifndef max_allowed_packet
+  THD *thd=current_thd;
+  uint max_allowed_packet= thd ? thd->variables.max_allowed_packet : ~(ulong)0;
+#endif
+
+  if (data_len > max_allowed_packet)
+  {
+    error = "Event too big";
+    goto err;
+  }
+
+  res= Log_event::read_log_event(buf, data_len, &error, description_event);
+
+err:
+  if (!res)
+  {
+    DBUG_ASSERT(error != 0);
+    sql_print_error("Error in Log_event::read_log_event(): "
+                    "'%s', data_len: %d, event_type: %d",
+		    error,data_len,head[EVENT_TYPE_OFFSET]);
+  }
+  (*arg_buf)+= data_len;
+  (*arg_buf_len)-= data_len;
+  DBUG_RETURN(res);
+}
+
+#endif

=== modified file 'sql/mysql_priv.h'
--- old/sql/mysql_priv.h	2011-07-07 08:06:59 +0000
+++ new/sql/mysql_priv.h	2011-10-12 21:45:28 +0000
@@ -1336,6 +1336,26 @@
 bool load_des_key_file(const char *file_name);
 #endif /* HAVE_OPENSSL */
 
+#ifdef WITH_WSREP
+void wsrep_replication_process(THD *thd);
+void wsrep_rollback_process(THD *thd);
+void wsrep_brute_force_killer(THD *thd);
+int  wsrep_hire_brute_force_killer(THD *thd, uint64_t trx_id);
+extern "C" int wsrep_thd_is_brute_force(void *thd_ptr);
+extern "C" int wsrep_abort_thd(void *bf_thd_ptr, void *victim_thd_ptr, 
+			       my_bool signal);
+struct wsrep_thd_shadow {
+  ulonglong            options;
+  enum wsrep_exec_mode wsrep_exec_mode;
+  Vio                  *vio;
+  ulong                tx_isolation;
+};
+
+
+void wsrep_prepare_bf_thd(THD *thd, struct wsrep_thd_shadow*);
+void wsrep_return_from_bf_mode(THD *thd, struct wsrep_thd_shadow*);
+#endif
+
 #ifdef MYSQL_SERVER
 /* sql_do.cc */
 bool mysql_do(THD *thd, List<Item> &values);
@@ -2056,11 +2076,35 @@
 #if defined MYSQL_SERVER || defined INNODB_COMPATIBILITY_HOOKS
 extern MYSQL_PLUGIN_IMPORT struct system_variables global_system_variables;
 #endif /* MYSQL_SERVER || INNODB_COMPATIBILITY_HOOKS */
+#ifdef WITH_WSREP
+/* this is visible for client build so that innodb plugin gets this */
+typedef struct wsrep_aborting_thd {
+  struct wsrep_aborting_thd *next;
+  THD *aborting_thd;
+} *wsrep_aborting_thd_t;
+#endif
 #ifdef MYSQL_SERVER
 extern struct system_variables max_system_variables;
 extern struct system_status_var global_status_var;
 extern struct rand_struct sql_rand;
-
+#ifdef WITH_WSREP
+extern pthread_mutex_t LOCK_wsrep_rollback;
+extern pthread_cond_t COND_wsrep_rollback;
+extern wsrep_aborting_thd_t wsrep_aborting_thd;
+extern pthread_mutex_t LOCK_wsrep_replaying;
+extern pthread_cond_t COND_wsrep_replaying;
+extern int wsrep_replaying;
+extern MYSQL_PLUGIN_IMPORT my_bool wsrep_debug;
+extern my_bool wsrep_convert_LOCK_to_trx;
+extern ulong   wsrep_retry_autocommit;
+extern my_bool wsrep_emulate_bin_log;
+extern my_bool wsrep_auto_increment_control;
+extern my_bool wsrep_drupal_282555_workaround;
+extern long long wsrep_max_ws_size;
+extern long      wsrep_max_ws_rows;
+extern int       wsrep_to_isolation;
+extern my_bool wsrep_certify_nonPK;
+#endif
 extern const char *opt_date_time_formats[];
 extern KNOWN_DATE_TIME_FORMAT known_date_time_formats[];
 

=== modified file 'sql/mysqld.cc'
--- old/sql/mysqld.cc	2011-11-30 16:11:13 +0000
+++ new/sql/mysqld.cc	2012-03-04 20:20:11 +0000
@@ -29,6 +29,11 @@
 #include "events.h"
 #include "debug_sync.h"
 
+#ifdef WITH_WSREP
+#include "wsrep_mysqld.h"
+ulong  wsrep_running_threads = 0; // # of currently running wsrep threads
+#endif
+
 #include "../storage/myisam/ha_myisam.h"
 
 #include "rpl_injector.h"
@@ -426,7 +431,9 @@
 static uint kill_cached_threads, wake_thread;
 static ulong killed_threads, thread_created;
        ulong max_used_connections;
+#ifndef WITH_WSREP
 static ulong my_bind_addr;			/**< the address we bind to */
+#endif
 static volatile ulong cached_thread_count= 0;
 static const char *sql_mode_str= "OFF";
 /* Text representation for OPTIMIZER_SWITCH_DEFAULT */
@@ -449,6 +456,20 @@
 
 /* Global variables */
 
+#ifdef WITH_WSREP
+ulong my_bind_addr;
+char* opt_wsrep_provider;
+char* opt_wsrep_cluster_address;
+char* opt_wsrep_cluster_name;
+char* opt_wsrep_node_address;
+char* opt_wsrep_node_name;
+char* opt_wsrep_start_pos;
+char* opt_wsrep_sst_method;
+char* opt_wsrep_sst_receive_address;
+char* opt_wsrep_sst_auth;
+char* opt_wsrep_sst_donor;
+#endif /* WITH_WSREP */
+
 bool opt_update_log, opt_bin_log, opt_ignore_builtin_innodb= 0;
 my_bool opt_log, opt_slow_log;
 ulong log_output_options;
@@ -547,7 +568,11 @@
 my_bool sp_automatic_privileges= 1;
 
 ulong opt_binlog_rows_event_max_size;
+#ifdef WITH_WSREP
+const char *binlog_format_names[]= {"STATEMENT", "ROW", NullS};
+#else
 const char *binlog_format_names[]= {"MIXED", "STATEMENT", "ROW", NullS};
+#endif
 TYPELIB binlog_format_typelib=
   { array_elements(binlog_format_names) - 1, "",
     binlog_format_names, NULL };
@@ -710,6 +735,16 @@
 pthread_mutex_t  LOCK_server_started;
 pthread_cond_t  COND_server_started;
 
+#ifdef WITH_WSREP
+pthread_mutex_t LOCK_wsrep_rollback;
+pthread_cond_t  COND_wsrep_rollback;
+wsrep_aborting_thd_t wsrep_aborting_thd= NULL;
+pthread_mutex_t LOCK_wsrep_replaying;
+pthread_cond_t  COND_wsrep_replaying;
+int wsrep_replaying= 0;
+static void wsrep_close_threads(THD* thd);
+#endif
+
 int mysqld_server_started= 0;
 
 File_parser_dummy_hook file_parser_dummy_hook;
@@ -989,7 +1024,11 @@
     /* We skip slave threads & scheduler on this first loop through. */
     if (tmp->slave_thread)
       continue;
-
+#ifdef WITH_WSREP
+    /* skip wsrep system threads as well */
+    if (tmp->wsrep_exec_mode==REPL_RECV || tmp->wsrep_applier)
+      continue;
+#endif
     tmp->killed= THD::KILL_CONNECTION;
     thread_scheduler.post_kill_notification(tmp);
     if (tmp->mysys_var)
@@ -1040,9 +1079,37 @@
       close_connection(tmp,0,0);
     }
 #endif
+#ifdef WITH_WSREP
+    /*
+     * TODO: this code block may turn out redundant. wsrep->disconnect()
+     *       should terminate slave threads gracefully, and we don't need
+     *       to signal them here. 
+     *       The code here makes sure mysqld will not hang during shutdown
+     *       even if wsrep provider has problems in shutting down.
+     */
+    if (tmp->wsrep_exec_mode==REPL_RECV)
+    {
+      sql_print_information("closing wsrep system thread");
+      tmp->killed= THD::KILL_CONNECTION;
+      thread_scheduler.post_kill_notification(tmp);
+      if (tmp->mysys_var)
+      {
+        tmp->mysys_var->abort=1;
+        pthread_mutex_lock(&tmp->mysys_var->mutex);
+        if (tmp->mysys_var->current_cond)
+        {
+          pthread_mutex_lock(tmp->mysys_var->current_mutex);
+          pthread_cond_broadcast(tmp->mysys_var->current_cond);
+          pthread_mutex_unlock(tmp->mysys_var->current_mutex);
+        }
+        pthread_mutex_unlock(&tmp->mysys_var->mutex);
+      }
+    }
+#endif
     DBUG_PRINT("quit",("Unlocking LOCK_thread_count"));
     (void) pthread_mutex_unlock(&LOCK_thread_count);
   }
+  
   /* All threads has now been aborted */
   DBUG_PRINT("quit",("Waiting for threads to die (count=%u)",thread_count));
   (void) pthread_mutex_lock(&LOCK_thread_count);
@@ -1200,8 +1267,17 @@
 		 GetLastError()));    
   }
 #endif  
+
+#ifdef WITH_WSREP
+  wsrep_stop_replication(NULL);
+#endif
   
   close_connections();
+  
+#ifdef WITH_WSREP
+  wsrep_deinit();
+#endif
+
   if (sig != MYSQL_KILL_SIGNAL &&
       sig != 0)
     unireg_abort(1);				/* purecov: inspected */
@@ -1288,6 +1364,23 @@
     usage();
   if (exit_code)
     sql_print_error("Aborting\n");
+
+#ifdef WITH_WSREP
+  if (wsrep)
+  {
+    /* This is an abort situation, we cannot expect to gracefully close all
+     * wsrep threads here, we can only diconnect from service */
+    wsrep_close_client_connections(FALSE);
+    shutdown_in_progress= 1;
+    THD* thd(0);
+    wsrep->disconnect(wsrep);
+    WSREP_INFO("Service disconnected.");
+    wsrep_close_threads(thd); /* this won't close all threads */
+    sleep(1); /* so give some time to exit for those which can */
+    WSREP_INFO("Some threads may fail to exit.");
+  }
+#endif // WITH_WSREP
+
   clean_up(!opt_help && (exit_code || !opt_bootstrap)); /* purecov: inspected */
   DBUG_PRINT("quit",("done with cleanup in unireg_abort"));
   wait_for_signal_thread_to_end();
@@ -1492,6 +1585,12 @@
   (void) pthread_cond_destroy(&COND_thread_cache);
   (void) pthread_cond_destroy(&COND_flush_thread_cache);
   (void) pthread_cond_destroy(&COND_manager);
+#ifdef WITH_WSREP
+  (void) pthread_mutex_destroy(&LOCK_wsrep_rollback);
+  (void) pthread_cond_destroy(&COND_wsrep_rollback);
+  (void) pthread_mutex_destroy(&LOCK_wsrep_replaying);
+  (void) pthread_cond_destroy(&COND_wsrep_replaying);
+#endif
 }
 
 #endif /*EMBEDDED_LIBRARY*/
@@ -3211,6 +3310,11 @@
   load_defaults(conf_file_name, groups, &argc, &argv);
   defaults_argv=argv;
   defaults_argc=argc;
+#ifdef WITH_WSREP
+  /* This is a protection against mutually incompatible option values. */
+  if (wsrep_check_opts (defaults_argc, defaults_argv))
+    return 1;
+#endif /* WITH_WSREP */
   if (get_options(&defaults_argc, defaults_argv))
     return 1;
   set_server_version();
@@ -3541,6 +3645,12 @@
     sql_print_error("Can't create thread-keys");
     return 1;
   }
+#ifdef WITH_WSREP
+  (void) pthread_mutex_init(&LOCK_wsrep_rollback, MY_MUTEX_INIT_FAST);
+  (void) pthread_cond_init(&COND_wsrep_rollback,NULL);
+  (void) pthread_mutex_init(&LOCK_wsrep_replaying, MY_MUTEX_INIT_FAST);
+  (void) pthread_cond_init(&COND_wsrep_replaying,NULL);
+#endif
   return 0;
 }
 
@@ -3659,7 +3769,6 @@
 
 #endif /* EMBEDDED_LIBRARY */
 
-
 static int init_server_components()
 {
   DBUG_ENTER("init_server_components");
@@ -3780,6 +3889,7 @@
                     "--log-slave-updates work.");
     unireg_abort(1);
   }
+#if !defined(WITH_WSREP)
   if (!opt_bin_log)
   {
     if (opt_binlog_format_id != BINLOG_FORMAT_UNSPEC)
@@ -3794,12 +3904,16 @@
     }
   }
   else
-    if (opt_binlog_format_id == BINLOG_FORMAT_UNSPEC)
-      global_system_variables.binlog_format= BINLOG_FORMAT_STMT;
-    else
-    { 
-      DBUG_ASSERT(global_system_variables.binlog_format != BINLOG_FORMAT_UNSPEC);
-    }
+  if (opt_binlog_format_id == BINLOG_FORMAT_UNSPEC)
+    global_system_variables.binlog_format= BINLOG_FORMAT_STMT;
+#else /* !WITH_WSREP */
+  if (opt_binlog_format_id == BINLOG_FORMAT_UNSPEC)
+    global_system_variables.binlog_format= BINLOG_FORMAT_ROW;
+#endif /* !WITH_WSREP */
+  else
+  { 
+    DBUG_ASSERT(global_system_variables.binlog_format != BINLOG_FORMAT_UNSPEC);
+  }
 
   /* Check that we have not let the format to unspecified at this point */
   DBUG_ASSERT((uint)global_system_variables.binlog_format <=
@@ -3816,6 +3930,32 @@
   }
 #endif
 
+/* WSREP BEFORE */
+#ifdef WITH_WSREP
+  // add basedir/bin to PATH to resolve wsrep script names
+  char* const tmp_path((char*)alloca(strlen(mysql_home) + strlen("/bin") + 1));
+  if (tmp_path)
+  {
+    strcpy(tmp_path, mysql_home);
+    strcat(tmp_path, "/bin");
+    wsrep_prepend_PATH(tmp_path);
+  }
+  else
+  {
+    WSREP_ERROR("Could not append %s/bin to PATH", mysql_home);
+  }
+
+  if (opt_bootstrap)
+  {
+    strcpy((char*)wsrep_provider, WSREP_NONE);
+    if (wsrep_init()) unireg_abort(1);
+  }
+  else if (wsrep_init_first())
+  {
+    wsrep_init_startup(true);
+  }
+#endif /* WITH_WSREP */
+
   if (opt_bin_log)
   {
     /* Reports an error and aborts, if the --log-bin's path 
@@ -4009,12 +4149,33 @@
     }
   }
 
+#ifdef WITH_WSREP
+  if (!opt_bin_log)
+  {
+    opt_bin_log= 1;
+    wsrep_emulate_bin_log= 1;
+  }
+#endif
+
+#ifdef WITH_WSREP
+  tc_log= (total_ha_2pc > 1 ? (opt_bin_log && !wsrep_emulate_bin_log ?
+                               (TC_LOG *) &mysql_bin_log :
+                               (TC_LOG *) &tc_log_dummy) :
+           (TC_LOG *) &tc_log_dummy);
+#else
   tc_log= (total_ha_2pc > 1 ? (opt_bin_log  ?
                                (TC_LOG *) &mysql_bin_log :
                                (TC_LOG *) &tc_log_mmap) :
            (TC_LOG *) &tc_log_dummy);
+#endif
+
 
-  if (tc_log->open(opt_bin_log ? opt_bin_logname : opt_tc_log_file))
+#ifdef WITH_WSREP
+  if (tc_log->open(opt_bin_log && !wsrep_emulate_bin_log ? 
+#else
+  if (tc_log->open(opt_bin_log ? 
+#endif                  
+                   opt_bin_logname : opt_tc_log_file))
   {
     sql_print_error("Can't init tc log");
     unireg_abort(1);
@@ -4025,12 +4186,21 @@
     unireg_abort(1);
   }
 
-  if (opt_bin_log && mysql_bin_log.open(opt_bin_logname, LOG_BIN, 0,
+#ifdef WITH_WSREP
+  if (opt_bin_log && !wsrep_emulate_bin_log &&
+#else
+  if (opt_bin_log && 
+#endif
+      mysql_bin_log.open(opt_bin_logname, LOG_BIN, 0,
                                         WRITE_CACHE, 0, max_binlog_size, 0, TRUE))
-    unireg_abort(1);
+      unireg_abort(1);
 
 #ifdef HAVE_REPLICATION
+#ifdef WITH_WSREP
+  if (opt_bin_log && !wsrep_emulate_bin_log && expire_logs_days)
+#else
   if (opt_bin_log && expire_logs_days)
+#endif
   {
     time_t purge_time= server_start_time - expire_logs_days*24*60*60;
     if (purge_time >= 0)
@@ -4091,6 +4261,404 @@
 
 #endif /* EMBEDDED_LIBRARY */
 
+#ifdef WITH_WSREP
+typedef void (*wsrep_thd_processor_fun)(THD *);
+
+pthread_handler_t start_wsrep_THD(void *arg)
+{
+  THD *thd;
+  wsrep_thd_processor_fun processor= (wsrep_thd_processor_fun)arg;
+
+  DBUG_ENTER("start_wsrep_THD");
+  if (my_thread_init()) 
+  {
+    WSREP_ERROR("Could not initialize thread");
+    DBUG_RETURN(NULL);
+  }
+
+  if (!(thd= new THD(true)))
+  {
+    DBUG_RETURN(NULL);
+  }
+  pthread_mutex_lock(&LOCK_thread_count);
+  thd->thread_id=thread_id++;
+
+  thd->real_id=pthread_self(); // Keep purify happy
+  thread_count++;
+  thread_created++;
+  threads.append(thd);
+
+  my_net_init(&thd->net,(st_vio*) 0);
+
+  DBUG_PRINT("wsrep",(("creating thread %lld"), (long long)thd->thread_id));
+  thd->prior_thr_create_utime= thd->start_utime= my_micro_time();
+  (void) pthread_mutex_unlock(&LOCK_thread_count);
+
+  /* from bootstrap()... */
+  thd->bootstrap=1;
+  thd->max_client_packet_length= thd->net.max_packet;
+  thd->security_ctx->master_access= ~(ulong)0;
+
+  /* from handle_one_connection... - this is no longer there (5.1.53) */
+  pthread_detach_this_thread();
+
+  if (thread_scheduler.init_new_connection_thread())
+  {
+    close_connection(thd, ER_OUT_OF_RESOURCES, 1);
+    statistic_increment(aborted_connects,&LOCK_status);
+    //thread_scheduler.end_thread(thd,0);
+    delete thd;
+
+    DBUG_RETURN(NULL);
+  }
+
+  /*
+    handle_one_connection() is normally the only way a thread would
+    start and would always be on the very high end of the stack ,
+    therefore, the thread stack always starts at the address of the
+    first local variable of handle_one_connection, which is thd. We
+    need to know the start of the stack so that we could check for
+    stack overruns.
+  */
+  DBUG_PRINT("wsrep", ("handle_one_connection called by thread %lld\n",
+                       (long long)thd->thread_id));
+  /* now that we've called my_thread_init(), it is safe to call DBUG_* */
+
+  thd->thread_stack= (char*) &thd;
+//  if (thd->store_globals())
+  if (setup_connection_thread_globals(thd))
+  {
+    close_connection(thd, ER_OUT_OF_RESOURCES, 1);
+    statistic_increment(aborted_connects,&LOCK_status);
+    thread_scheduler.end_thread(thd,0);
+    delete thd;
+
+    DBUG_RETURN(NULL);
+  }
+
+  /* from handle_bootstrap() */
+#ifdef REMOVED
+  thd->security_ctx->priv_user=
+    thd->security_ctx->user= (char*) my_strdup("boot", MYF(MY_WME));
+  thd->security_ctx->priv_host[0]=0;
+#endif
+
+  thd->system_thread= SYSTEM_THREAD_SLAVE_SQL;
+  thd->security_ctx->skip_grants();
+
+  /* handle_one_connection() again... */
+  thd->version= refresh_version;
+  thd->proc_info= 0;
+  thd->command= COM_SLEEP;
+  thd->set_time();
+  thd->init_for_queries();
+
+  pthread_mutex_lock(&LOCK_connection_count);
+  ++connection_count;
+  pthread_mutex_unlock(&LOCK_connection_count);
+
+  pthread_mutex_lock(&LOCK_thread_count);
+  wsrep_running_threads++;
+  pthread_cond_signal(&COND_thread_count);
+  pthread_mutex_unlock(&LOCK_thread_count);
+
+  processor(thd);
+
+  close_connection(thd, 0, 1);
+
+  pthread_mutex_lock(&LOCK_thread_count);
+  wsrep_running_threads--;
+  pthread_cond_signal(&COND_thread_count);
+  pthread_mutex_unlock(&LOCK_thread_count);
+
+  // Note: We can't call THD destructor without crashing
+  // if plugins have not been initialized. However, in most of the
+  // cases this means that pre SE initialization SST failed and
+  // we are going to exit anyway.
+  if (plugins_are_initialized)
+  {
+    net_end(&thd->net);
+    thread_scheduler.end_thread(thd, 0);
+    delete thd;
+  }
+  else
+  {
+    // TODO: lightweight cleanup to get rid of:
+    // 'Error in my_thread_global_end(): 2 threads didn't exit'
+    // at server shutdown
+  }
+  DBUG_RETURN(NULL);
+}
+
+void wsrep_create_rollbacker()
+{
+  pthread_t hThread;
+  /* create rollbacker */
+  if (pthread_create(
+      &hThread, &connection_attrib,
+      start_wsrep_THD, (void*)wsrep_rollback_process))
+      WSREP_WARN("Can't create thread to manage wsrep rollback");
+}
+
+void wsrep_create_appliers(long threads)
+{
+  if (!wsrep_connected)
+  {
+    /* see wsrep_replication_start() for the logic */
+    if (wsrep_cluster_address && strlen(wsrep_cluster_address) &&
+        wsrep_provider && strcasecmp(wsrep_provider, "none"))
+    {
+      WSREP_ERROR("Trying to launch slave threads before creating "
+                  "connection at '%s'", wsrep_cluster_address);
+      assert(0);
+    }
+    return;
+  }
+
+  long wsrep_threads=0;
+  pthread_t hThread;
+  while (wsrep_threads++ < threads) {
+    if (pthread_create(
+      &hThread, &connection_attrib,
+      start_wsrep_THD, (void*)wsrep_replication_process))
+      WSREP_WARN("Can't create thread to manage wsrep replication");
+  }
+}
+/**/
+static bool abort_replicated(THD *thd)
+{
+  bool ret_code= false;
+  if (thd->wsrep_query_state== QUERY_COMMITTING)
+  {
+    if (wsrep_debug) WSREP_INFO("aborting replicated trx: %lu", thd->real_id);
+
+    (void)wsrep_abort_thd(thd, thd, TRUE);
+    ret_code= true;
+  }
+  return ret_code;
+}
+/**/
+static inline bool is_client_connection(THD *thd)
+{
+#if REMOVE
+// REMOVE THIS LATER (lp:777201). Below we had to add an explicit check for
+// wsrep_applier since wsrep_exec_mode didn't seem to always work
+if (thd->wsrep_applier && thd->wsrep_exec_mode != REPL_RECV)
+WSREP_WARN("applier has wsrep_exec_mode = %d", thd->wsrep_exec_mode);
+
+  if ( thd->slave_thread               || /* declared as mysql slave  */
+       thd->system_thread              || /* declared as system thread */
+      !thd->vio_ok()                   || /* server internal thread */ 
+       thd->wsrep_exec_mode==REPL_RECV || /* applier or replaying thread */
+       thd->wsrep_applier              || /* wsrep slave applier */
+      !thd->variables.wsrep_on)           /* client, but fenced outside wsrep */
+    return false;
+
+  return true;
+#else
+  return (thd->wsrep_client_thread && thd->variables.wsrep_on);
+#endif /* REMOVE */
+}
+
+static bool have_client_connections()
+{
+  THD *tmp;
+
+  I_List_iterator<THD> it(threads);
+  while ((tmp=it++))
+  {
+    DBUG_PRINT("quit",("Informing thread %ld that it's time to die",
+                        tmp->thread_id));
+    if (is_client_connection(tmp) && tmp->killed == THD::KILL_CONNECTION)
+    {
+      (void)abort_replicated(tmp);
+      return true;
+    }
+  }
+  return false;
+}
+
+/*
+   returns the number of wsrep appliers running.
+   However, the caller (thd parameter) is not taken in account
+ */
+static int have_wsrep_appliers(THD *thd)
+{
+  int ret= 0;
+  THD *tmp;
+
+  I_List_iterator<THD> it(threads);
+  while ((tmp=it++))
+  {
+    ret+= (tmp != thd && tmp->wsrep_applier);
+  }
+  return ret;
+}
+
+static void wsrep_close_thread(THD *thd)
+{
+  thd->killed= THD::KILL_CONNECTION;
+  thread_scheduler.post_kill_notification(thd);
+  if (thd->mysys_var)
+  {
+    thd->mysys_var->abort=1;
+    pthread_mutex_lock(&thd->mysys_var->mutex);
+    if (thd->mysys_var->current_cond)
+    {
+      pthread_mutex_lock(thd->mysys_var->current_mutex);
+      pthread_cond_broadcast(thd->mysys_var->current_cond);
+      pthread_mutex_unlock(thd->mysys_var->current_mutex);
+    }
+    pthread_mutex_unlock(&thd->mysys_var->mutex);
+  }
+}
+
+void wsrep_close_client_connections(my_bool wait_to_end) 
+{
+  /*
+    First signal all threads that it's time to die
+  */
+
+  THD *tmp;
+  (void) pthread_mutex_lock(&LOCK_thread_count); // For unlink from list
+
+  bool kill_cached_threads_saved= kill_cached_threads;
+  kill_cached_threads= true; // prevent future threads caching
+  pthread_cond_broadcast(&COND_thread_cache); // tell cached threads to die
+
+  I_List_iterator<THD> it(threads);
+  while ((tmp=it++))
+  {
+    DBUG_PRINT("quit",("Informing thread %ld that it's time to die",
+                        tmp->thread_id));
+    /* We skip slave threads & scheduler on this first loop through. */
+    if (!is_client_connection(tmp))
+      continue;
+
+    /* replicated transactions must be skipped */
+    if (abort_replicated(tmp))
+      continue;
+
+    if (wsrep_debug) WSREP_INFO("closing connection %ld", tmp->thread_id);
+
+    wsrep_close_thread(tmp);
+  }
+  (void) pthread_mutex_unlock(&LOCK_thread_count);
+
+  if (thread_count)
+    sleep(2);                               // Give threads time to die
+
+  (void) pthread_mutex_lock(&LOCK_thread_count);
+  /*
+    Force remaining threads to die by closing the connection to the client
+  */
+
+  I_List_iterator<THD> it2(threads);
+  while ((tmp=it2++))
+  {
+#ifndef __bsdi__				// Bug in BSDI kernel
+    if (is_client_connection(tmp) && !abort_replicated(tmp))
+    {
+      WSREP_INFO("SST kill local trx: %ld",tmp->thread_id);
+      close_connection(tmp,0,0);
+    }
+#endif
+  }
+
+  DBUG_PRINT("quit",("Waiting for threads to die (count=%u)",thread_count));
+  if (wsrep_debug)
+    WSREP_INFO("waiting for client connections to close: %u", thread_count);
+
+  while (wait_to_end && have_client_connections())
+  {
+    (void) pthread_cond_wait(&COND_thread_count,&LOCK_thread_count);
+    DBUG_PRINT("quit",("One thread died (count=%u)",thread_count));
+  }
+
+  kill_cached_threads= kill_cached_threads_saved;
+
+  (void) pthread_mutex_unlock(&LOCK_thread_count);
+
+  /* All client connection threads have now been aborted */
+}
+
+void wsrep_close_applier(THD *thd)
+{
+  if (wsrep_debug)
+    WSREP_INFO("closing applier %ld", thd->thread_id);
+
+  wsrep_close_thread(thd);
+}
+
+static void wsrep_close_threads(THD *thd)
+{
+  THD *tmp;
+  (void) pthread_mutex_lock(&LOCK_thread_count); // For unlink from list
+
+  I_List_iterator<THD> it(threads);
+  while ((tmp=it++))
+  {
+    DBUG_PRINT("quit",("Informing thread %ld that it's time to die",
+                       tmp->thread_id));
+    /* We skip slave threads & scheduler on this first loop through. */
+    if (tmp->wsrep_applier && tmp != thd)
+    {
+      if (wsrep_debug)
+        WSREP_INFO("closing wsrep thread %ld", tmp->thread_id);
+      wsrep_close_thread (tmp);
+    }
+  }
+
+  (void) pthread_mutex_unlock(&LOCK_thread_count);
+}
+
+void wsrep_wait_appliers_close(THD *thd)
+{
+  /* Wait for wsrep appliers to gracefully exit */
+  (void) pthread_mutex_lock(&LOCK_thread_count);
+  while (have_wsrep_appliers(thd) > 1)
+  // 1 is for rollbacker thread which needs to be killed explicitly.
+  // This gotta be fixed in a more elegant manner if we gonna have arbitrary
+  // number of non-applier wsrep threads.
+  {
+    (void) pthread_cond_wait(&COND_thread_count,&LOCK_thread_count);
+    DBUG_PRINT("quit",("One applier died (count=%u)",thread_count));
+  }
+  (void) pthread_mutex_unlock(&LOCK_thread_count);
+  /* Now kill remaining wsrep threads: rollbacker */
+  wsrep_close_threads (thd);
+  /* and wait for them to die */
+  (void) pthread_mutex_lock(&LOCK_thread_count);
+  while (have_wsrep_appliers(thd) > 0)
+  {
+    (void) pthread_cond_wait(&COND_thread_count,&LOCK_thread_count);
+    DBUG_PRINT("quit",("One thread died (count=%u)",thread_count));
+  }
+  (void) pthread_mutex_unlock(&LOCK_thread_count);
+
+  /* All wsrep applier threads have now been aborted. However, if this thread
+     is also applier, we are still running...
+  */
+}
+
+void wsrep_kill_mysql(THD *thd)
+{
+  if (mysqld_server_started)
+  {
+    if (!shutdown_in_progress)
+    {
+      WSREP_INFO("starting shutdown");
+      kill_mysql();
+    }
+  }
+  else
+  {
+    unireg_abort(1);
+  }
+}
+
+#endif /* WITH_WSREP */
+
 
 #if (defined(__NT__) || defined(HAVE_SMEM)) && !defined(EMBEDDED_LIBRARY)
 static void handle_connections_methods()
@@ -4163,7 +4731,6 @@
 #define decrement_handler_count()
 #endif /* defined(__NT__) || defined(HAVE_SMEM) */
 
-
 #ifndef EMBEDDED_LIBRARY
 #ifndef DBUG_OFF
 /*
@@ -4428,12 +4995,35 @@
   if (Events::init(opt_noacl || opt_bootstrap))
     unireg_abort(1);
 
+/* WSREP AFTER */
+#ifdef WITH_WSREP
+  wsrep_SE_initialized();
+  if (opt_bootstrap)
+  {
+    /*! bootstrap wsrep init was taken care of above */
+  }
+  else if (wsrep_init_first())
+  {
+    /*! in case of no SST wsrep waits in view handler callback */
+    wsrep_SE_init_grab();
+    wsrep_SE_init_done();
+    /*! in case of SST wsrep waits for wsrep->sst_received */
+    wsrep_sst_continue();
+  }
+  else
+  {
+    wsrep_init_startup (false);
+  }
+  wsrep_create_appliers(wsrep_slave_threads - 1);
+#endif /* WITH_WSREP */
+
   if (opt_bootstrap)
   {
     select_thread_in_use= 0;                    // Allow 'kill' to work
     bootstrap(stdin);
     unireg_abort(bootstrap_error ? 1 : 0);
   }
+
   if (opt_init_file)
   {
     if (read_init_file(opt_init_file))
@@ -4477,16 +5067,16 @@
   DBUG_PRINT("quit",("Exiting main thread"));
 
 #ifndef __WIN__
-#ifdef EXTRA_DEBUG2
-  sql_print_error("Before Lock_thread_count");
+#ifdef WITH_WSREP
+  if (wsrep_debug) sql_print_information("Before Lock_thread_count");
 #endif
   (void) pthread_mutex_lock(&LOCK_thread_count);
   DBUG_PRINT("quit", ("Got thread_count mutex"));
   select_thread_in_use=0;			// For close_connections
   (void) pthread_mutex_unlock(&LOCK_thread_count);
   (void) pthread_cond_broadcast(&COND_thread_count);
-#ifdef EXTRA_DEBUG2
-  sql_print_error("After lock_thread_count");
+#ifdef WITH_WSREP
+  if (wsrep_debug) sql_print_information("After lock_thread_count");
 #endif
 #endif /* __WIN__ */
 
@@ -4731,6 +5321,10 @@
   DBUG_ENTER("bootstrap");
 
   THD *thd= new THD;
+#ifdef WITH_WSREP
+  thd->variables.wsrep_on= 0;
+#endif
+
   thd->bootstrap=1;
   my_net_init(&thd->net,(st_vio*) 0);
   thd->max_client_packet_length= thd->net.max_packet;
@@ -5651,6 +6245,37 @@
   OPT_WARNINGS,
   OPT_RECORD_BUFFER_OLD,
   OPT_LOG_OUTPUT,
+#ifdef WITH_WSREP
+  OPT_WSREP_PROVIDER,
+  OPT_WSREP_PROVIDER_OPTIONS,
+  OPT_WSREP_DATA_HOME_DIR,
+  OPT_WSREP_CLUSTER_NAME,
+  OPT_WSREP_CLUSTER_ADDRESS,
+  OPT_WSREP_NODE_NAME,
+  OPT_WSREP_NODE_ADDRESS,
+  OPT_WSREP_NODE_INCOMING_ADDRESS,
+  OPT_WSREP_SLAVE_THREADS,
+  OPT_WSREP_DBUG,
+  OPT_WSREP_LOCAL_CACHE_SIZE,
+  OPT_WSREP_WS_PERSISTENCY,
+  OPT_WSREP_DEBUG,
+  OPT_WSREP_CONVERT_LOCK_TO_TRX,
+  OPT_WSREP_RETRY_AUTOCOMMIT,
+  OPT_WSREP_AUTO_INCREMENT_CONTROL,
+  OPT_WSREP_DRUPAL_282555_WORKAROUND,
+  OPT_WSREP_SST_METHOD,
+  OPT_WSREP_SST_RECEIVE_ADDRESS,
+  OPT_WSREP_SST_AUTH,
+  OPT_WSREP_SST_DONOR,
+  OPT_WSREP_ON,
+  OPT_WSREP_START_POSITION,
+  OPT_WSREP_MAX_WS_SIZE,
+  OPT_WSREP_MAX_WS_ROWS,
+  OPT_WSREP_NOTIFY_CMD,
+  OPT_WSREP_CERTIFY_NONPK,
+  OPT_WSREP_CONSISTENT_READS,
+  OPT_WSREP_MAX_PROTOCOL_VERSION,
+#endif
   OPT_PORT_OPEN_TIMEOUT,
   OPT_PROFILING,
   OPT_KEEP_FILES_ON_CREATE,
@@ -7126,6 +7751,135 @@
    &max_system_variables.net_wait_timeout, 0, GET_ULONG,
    REQUIRED_ARG, NET_WAIT_TIMEOUT, 1, IF_WIN(INT_MAX32/1000, LONG_TIMEOUT),
    0, 1, 0},
+#ifdef WITH_WSREP
+  {"wsrep_provider", OPT_WSREP_PROVIDER,
+   "wsrep provider library to load.", 
+   (uchar**) &opt_wsrep_provider, 
+   (uchar**) &opt_wsrep_provider, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_provider_options", OPT_WSREP_PROVIDER_OPTIONS,
+   "a string with options for specific wsrep provider.", 
+   (uchar**) &wsrep_provider_options, 
+   (uchar**) &wsrep_provider_options, 0, GET_STR, REQUIRED_ARG, 0, 0, 0,0,0,0},
+  {"wsrep_data_home_dir", OPT_WSREP_DATA_HOME_DIR,
+   "Where wsrep stores its write set db files. If not set uses MySQL data dir.",
+   (uchar**) &wsrep_data_home_dir,
+   (uchar**) &wsrep_data_home_dir, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_cluster_name", OPT_WSREP_CLUSTER_NAME,
+   "Name of the cluster to join/form.",
+   (uchar**) &opt_wsrep_cluster_name,
+   (uchar**) &opt_wsrep_cluster_name, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_cluster_address", OPT_WSREP_CLUSTER_ADDRESS,
+   "The URL-like address at which connet to cluster. Example: 'gcomm://127.0.0.1:4567'. Depends on wsrep provider.",
+   (uchar**) &opt_wsrep_cluster_address,
+   (uchar**) &opt_wsrep_cluster_address, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_node_name", OPT_WSREP_NODE_NAME,
+   "Human-readable name of the node. If not specified uses hostname.",
+   (uchar**) &opt_wsrep_node_name,
+   (uchar**) &opt_wsrep_node_name, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_node_address", OPT_WSREP_NODE_ADDRESS,
+   "Base replication <address|hostname>[:port] of the node. "
+   "The values supplied will be used as defaults to receive state transfers, "
+   "open listening ports and so on. Default: address of the first network interface.",
+   (uchar**) &opt_wsrep_node_address,
+   (uchar**) &opt_wsrep_node_address, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_node_incoming_address", OPT_WSREP_NODE_INCOMING_ADDRESS,
+   "Address for incoming client connections (for load balancing purposes).",
+   (uchar**) &wsrep_node_incoming_address,
+   (uchar**) &wsrep_node_incoming_address, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_slave_threads", OPT_WSREP_SLAVE_THREADS,
+   "How many slave threads should handle replicated actions from other servers.",
+   (uchar**) &wsrep_slave_threads,
+   (uchar**) &wsrep_slave_threads, 0, GET_LONG, REQUIRED_ARG, 1, 1, 512, 0, 0, 0},
+  {"wsrep_dbug", OPT_WSREP_DBUG,
+   "wsrep DBUG option string. Defaults to MySQL default if empty.",
+   (uchar**) &wsrep_dbug_option,
+#ifndef DBUG_OFF
+   (uchar**) &default_dbug_option,
+#else
+   (uchar**) &wsrep_dbug_option,
+#endif /* DBUG_OFF */
+   0, GET_STR, OPT_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_debug", OPT_WSREP_DEBUG,
+   "enable debug level logging",
+   (uchar**) &wsrep_debug,
+   (uchar**) &wsrep_debug, 0, GET_BOOL, REQUIRED_ARG, 0, 0, 1, 0, 0, 0},
+  {"wsrep_convert_LOCK_to_trx", OPT_WSREP_CONVERT_LOCK_TO_TRX,
+   "convert locking sessions to transactions",
+   (uchar**) &wsrep_convert_LOCK_to_trx,
+   (uchar**) &wsrep_convert_LOCK_to_trx, 0, GET_BOOL, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_retry_autocommit", OPT_WSREP_RETRY_AUTOCOMMIT,
+   "retry deadlocking autocommit transactions until success or max_retry is reached",
+   (uchar**) &wsrep_retry_autocommit,
+   (uchar**) &wsrep_retry_autocommit, 0, GET_ULONG, REQUIRED_ARG, 5, 0, ULONG_MAX, 0, 0, 0},
+  {"wsrep_auto_increment_control", OPT_WSREP_AUTO_INCREMENT_CONTROL,
+   "adjust automatically auto_increment_increment & auto_increment_offset",
+   (uchar**) &wsrep_auto_increment_control,
+   (uchar**) &wsrep_auto_increment_control, 0, GET_BOOL, REQUIRED_ARG, 1, 0, 0, 0, 0, 0},
+  {"wsrep_drupal_282555_workaround", OPT_WSREP_DRUPAL_282555_WORKAROUND,
+   "retry autoinc insert, which failed for duplicate key error",
+   (uchar**) &wsrep_drupal_282555_workaround,
+   (uchar**) &wsrep_drupal_282555_workaround, 0, GET_BOOL, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_sst_method", OPT_WSREP_SST_METHOD,
+   "State Snapshot Transfer mode (default: 'mysqldump')",
+   (uchar**) &opt_wsrep_sst_method,
+   (uchar**) &opt_wsrep_sst_method, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_sst_receive_address", OPT_WSREP_SST_RECEIVE_ADDRESS,
+   "Address to receive SST at. SST mode-dependent. If not set, wsrep_node_address is used.",
+   (uchar**) &opt_wsrep_sst_receive_address,
+   (uchar**) &opt_wsrep_sst_receive_address, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_sst_auth", OPT_WSREP_SST_AUTH,
+   "Authentication required for SST. SST mode-dependent. "
+   "For mysqldump mode it is 'root:<root password>'. "
+   "Should be the same on all nodes",
+   (uchar**) &opt_wsrep_sst_auth,
+   (uchar**) &opt_wsrep_sst_auth, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_sst_donor", OPT_WSREP_SST_DONOR,
+   "Node name of the desired SST donor.",
+   (uchar**) &opt_wsrep_sst_donor,
+   (uchar**) &opt_wsrep_sst_donor, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_on", OPT_WSREP_ON,
+   "Enable WSREP replication (default: yes)",
+   (uchar**) &global_system_variables.wsrep_on,
+   (uchar**) &max_system_variables.wsrep_on, 0, GET_BOOL, REQUIRED_ARG, 1, 0, 1, 0, 0, 0},
+  {"wsrep_start_position", OPT_WSREP_START_POSITION,
+   "Start at this replication position. Format: <history UUID(hex)>:<sequence number>. Unset option means no previous state on this node. Setting this option from client assumes that state with that position has just been installed on the node.",
+   (uchar**) &opt_wsrep_start_pos,
+   (uchar**) &opt_wsrep_start_pos, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_max_ws_size", OPT_WSREP_MAX_WS_SIZE,
+   "Max allowed write set size, (RBR event size)",
+   (uchar**) &wsrep_max_ws_size,
+   (uchar**) &wsrep_max_ws_size,
+   0, GET_LL, REQUIRED_ARG, 1073741824LL, 67108864LL, 4294000000LL, 0, 0, 0},
+  {"wsrep_max_ws_rows", OPT_WSREP_MAX_WS_ROWS,
+   "Max allowed transaction length in rows",
+   (uchar**) &wsrep_max_ws_rows,
+   (uchar**) &wsrep_max_ws_rows,
+   0, GET_LONG, REQUIRED_ARG, 131072, 64, 1048576, 0, 0, 0},
+  {"wsrep_notify_cmd", OPT_WSREP_NOTIFY_CMD,
+   "Command to run when node status or cluster membership changes. "
+   "Will be given some or all of the following arguments: "
+   "--status  - new status of this node; "
+   "--uuid    - UUID of the cluster; "
+   "--primary - whether the component is primary or not; "
+   "--members - comma-separated list of members; "
+   "--index   - index of this node in the list.",
+   (uchar**) &wsrep_notify_cmd,
+   (uchar**) &wsrep_notify_cmd, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},
+  {"wsrep_certify_nonPK", OPT_WSREP_CERTIFY_NONPK,
+   "do certification test even for tables with no primary key",
+   (uchar**) &wsrep_certify_nonPK,
+   (uchar**) &wsrep_certify_nonPK, 0, GET_BOOL, REQUIRED_ARG, 1, 0, 1, 0, 0, 0},
+  {"wsrep_causal_reads", OPT_WSREP_CONSISTENT_READS,
+   "Enable causal (strict \"read committed\") read semantics (default: no)",
+   (uchar**) &global_system_variables.wsrep_causal_reads,
+   (uchar**) &max_system_variables.wsrep_causal_reads,
+   0, GET_BOOL, REQUIRED_ARG, 0, 0, 1, 0, 0, 0},
+  {"wsrep_max_protocol_version", OPT_WSREP_MAX_PROTOCOL_VERSION,
+   "maximum protocol version for wsrep",
+   (uchar**) &wsrep_max_protocol_version,
+   (uchar**) &wsrep_max_protocol_version,
+   0, GET_LONG, REQUIRED_ARG, 1, 0, 1, 0, 0, 0},
+#endif /* WITH_WSREP */
   {"binlog-direct-non-transactional-updates", OPT_BINLOG_DIRECT_NON_TRANS_UPDATE,
    "Causes updates to non-transactional engines using statement format to be "
    "written directly to binary log. Before using this option, make sure that "
@@ -7624,6 +8378,19 @@
 #ifdef COMMUNITY_SERVER
   {"Uptime_since_flush_status",(char*) &show_flushstatustime,   SHOW_FUNC},
 #endif
+#ifdef WITH_WSREP
+  {"wsrep_connected",          (char*) &wsrep_connected,         SHOW_BOOL},
+  {"wsrep_ready",              (char*) &wsrep_ready,             SHOW_BOOL},
+  {"wsrep_cluster_state_uuid", (char*) &wsrep_cluster_state_uuid,SHOW_CHAR_PTR},
+  {"wsrep_cluster_conf_id",    (char*) &wsrep_cluster_conf_id,   SHOW_LONGLONG},
+  {"wsrep_cluster_status",     (char*) &wsrep_cluster_status,    SHOW_CHAR_PTR},
+  {"wsrep_cluster_size",       (char*) &wsrep_cluster_size,      SHOW_LONG},
+  {"wsrep_local_index",        (char*) &wsrep_local_index,       SHOW_LONG},
+  {"wsrep_provider_name",      (char*) &wsrep_provider_name,     SHOW_CHAR_PTR},
+  {"wsrep_provider_version",   (char*) &wsrep_provider_version,  SHOW_CHAR_PTR},
+  {"wsrep_provider_vendor",    (char*) &wsrep_provider_vendor,   SHOW_CHAR_PTR},
+  {"wsrep",                    (char*) &wsrep_show_status,       SHOW_FUNC},
+#endif
   {NullS, NullS, SHOW_LONG}
 };
 
@@ -7719,7 +8486,11 @@
   opt_bin_log= 0;
   opt_disable_networking= opt_skip_show_db=0;
   opt_skip_name_resolve= 0;
+#ifndef WITH_WSREP
   opt_ignore_builtin_innodb= 0;
+#else
+  opt_ignore_builtin_innodb= 1;
+#endif /* WITH_WSREP */
   opt_logname= opt_update_logname= opt_binlog_index_name= opt_slow_logname= 0;
   opt_tc_log_file= (char *)"tc.log";      // no hostname in tc_log file name !
   opt_secure_auth= 0;
@@ -7944,6 +8715,10 @@
     tmpenv = DEFAULT_MYSQL_HOME;
   (void) strmake(mysql_home, tmpenv, sizeof(mysql_home)-1);
 #endif
+#ifdef WITH_WSREP
+  if (wsrep_init_vars())
+    return 1;
+#endif
   return 0;
 }
 
@@ -8538,6 +9313,38 @@
     lower_case_table_names= argument ? atoi(argument) : 1;
     lower_case_table_names_used= 1;
     break;
+#ifdef WITH_WSREP
+  case OPT_WSREP_PROVIDER:
+    wsrep_provider_init (opt_wsrep_provider);
+    break;
+  case OPT_WSREP_CLUSTER_ADDRESS:
+    wsrep_cluster_address_init (opt_wsrep_cluster_address);
+    break;
+  case OPT_WSREP_CLUSTER_NAME:
+    wsrep_cluster_name_init (opt_wsrep_cluster_name);
+    break;
+  case OPT_WSREP_NODE_ADDRESS:
+    wsrep_node_address_init (opt_wsrep_node_address);
+    break;
+  case OPT_WSREP_NODE_NAME:
+    wsrep_node_name_init (opt_wsrep_node_name);
+    break;
+  case OPT_WSREP_START_POSITION:
+    wsrep_start_position_init (opt_wsrep_start_pos);
+    break;
+  case OPT_WSREP_SST_METHOD:
+    wsrep_sst_method_init (opt_wsrep_sst_method);
+    break;
+  case OPT_WSREP_SST_RECEIVE_ADDRESS:
+    wsrep_sst_receive_address_ini (opt_wsrep_sst_receive_address);
+    break;
+  case OPT_WSREP_SST_AUTH:
+    wsrep_sst_auth_init (opt_wsrep_sst_auth);
+    break;
+  case OPT_WSREP_SST_DONOR:
+    wsrep_sst_donor_init (opt_wsrep_sst_donor);
+    break;
+#endif /* WITH_WSREP */
 #ifdef HAVE_STACK_TRACE_ON_SEGV
   case OPT_DO_PSTACK:
     sql_print_warning("'--enable-pstack' is deprecated and will be removed "

=== modified file 'sql/protocol.cc'
--- old/sql/protocol.cc	2012-02-15 16:21:38 +0000
+++ new/sql/protocol.cc	2012-04-19 19:26:55 +0000
@@ -431,6 +431,14 @@
 
 void net_end_statement(THD *thd)
 {
+#ifdef WITH_WSREP
+  /*sanity check, can be removed before 1.0 release */
+  if (thd->wsrep_conflict_state== REPLAYING)
+    {
+      sql_print_error("WSREP: attempting net_end_statement while replaying");
+      return;
+    }
+#endif
   DBUG_ASSERT(! thd->main_da.is_sent);
 
   /* Can not be true, but do not take chances in production. */

=== modified file 'sql/repl_failsafe.cc'
--- old/sql/repl_failsafe.cc	2011-06-30 15:37:13 +0000
+++ new/sql/repl_failsafe.cc	2011-10-12 21:45:28 +0000
@@ -1029,8 +1029,11 @@
 err:
   unlock_slave_threads(active_mi);
   pthread_mutex_unlock(&LOCK_active_mi);
+#ifdef WITH_WSREP
+  thd_proc_info(thd, "done starting slave");
+#else /* WITH_WSREP */
   thd_proc_info(thd, 0);
-
+#endif /* WITH_WSREP */
   mysql_close(&mysql); // safe to call since we always do mysql_init()
   if (!error)
     my_ok(thd);

=== modified file 'sql/set_var.cc'
--- old/sql/set_var.cc	2011-07-03 15:47:37 +0000
+++ new/sql/set_var.cc	2012-01-25 20:52:58 +0000
@@ -76,6 +76,10 @@
 extern ulong ndb_report_thresh_binlog_mem_usage;
 #endif
 
+/* WITH WSREP REPLICATION */
+#ifdef WITH_WSREP
+#include "wsrep_mysqld.h"
+#endif
 extern CHARSET_INFO *character_set_filesystem;
 
 
@@ -921,6 +925,96 @@
                                                      SHOW_LONGLONG,
                                                      get_myisam_mmap_size);
 
+#ifdef WITH_WSREP
+static sys_var_str sys_wsrep_provider (&vars, "wsrep_provider",
+                                             wsrep_provider_check,
+                                             wsrep_provider_update,
+                                             wsrep_provider_default,
+                                             (char*)wsrep_provider);
+static sys_var_str sys_wsrep_provider_options(&vars,
+                                              "wsrep_provider_options", 
+                                              wsrep_provider_options_check,
+                                              wsrep_provider_options_update,
+                                              wsrep_provider_default,
+                                              (char*)wsrep_provider_options);
+static sys_var_const_str_ptr sys_wsrep_data_home_dir(&vars,
+            "wsrep_data_home_dir", (char**)&wsrep_data_home_dir);
+static sys_var_str sys_wsrep_cluster_name    (&vars, "wsrep_cluster_name",
+                                              wsrep_cluster_name_check,
+                                              wsrep_cluster_name_update,
+                                              wsrep_cluster_name_default,
+                                              (char*)wsrep_cluster_name);
+static sys_var_str sys_wsrep_cluster_address (&vars, "wsrep_cluster_address",
+                                              wsrep_cluster_address_check,
+                                              wsrep_cluster_address_update,
+                                              wsrep_cluster_address_default,
+                                              (char*)wsrep_cluster_address);
+static sys_var_str sys_wsrep_node_name       (&vars, "wsrep_node_name",
+                                              wsrep_node_name_check,
+                                              wsrep_node_name_update,
+                                              wsrep_node_name_default,
+                                              (char*)wsrep_node_name);
+static sys_var_str sys_wsrep_node_address    (&vars, "wsrep_node_address",
+                                              wsrep_node_address_check,
+                                              wsrep_node_address_update,
+                                              wsrep_node_address_default,
+                                              (char*)wsrep_node_address);
+static sys_var_const_str_ptr sys_wsrep_node_incoming_address(&vars,
+            "wsrep_node_incoming_address", (char**)&wsrep_node_incoming_address);
+static sys_var_long_ptr sys_wsrep_slave_threads(&vars, "wsrep_slave_threads",
+                                                (ulong*)&wsrep_slave_threads);
+// todo: consider converting to writeable class
+static sys_var_const_str_ptr sys_wsrep_dbug_option(&vars, "wsrep_dbug_option",
+                                                   (char**)&wsrep_dbug_option);
+static sys_var_bool_ptr sys_wsrep_debug(&vars, "wsrep_debug", &wsrep_debug);
+static sys_var_bool_ptr sys_wsrep_convert_LOCK_to_trx(&vars,
+            "wsrep_convert_LOCK_to_trx", &wsrep_convert_LOCK_to_trx);
+static sys_var_long_ptr sys_wsrep_retry_autocommit(&vars,
+            "wsrep_retry_autocommit", &wsrep_retry_autocommit);
+static sys_var_bool_ptr sys_wsrep_auto_increment_control(&vars,
+            "wsrep_auto_increment_control", &wsrep_auto_increment_control);
+static sys_var_bool_ptr sys_wsrep_drupal_282555_workaround(&vars,
+            "wsrep_drupal_282555_workaround", &wsrep_drupal_282555_workaround);
+static sys_var_str sys_wsrep_sst_method(&vars, "wsrep_sst_method",
+                                        wsrep_sst_method_check,
+                                        wsrep_sst_method_update,
+                                        wsrep_sst_method_default,
+                                        (char*)wsrep_sst_method);
+static sys_var_str sys_wsrep_sst_receive_address(&vars,
+                                           "wsrep_sst_receive_address",
+                                            wsrep_sst_receive_address_chk,
+                                            wsrep_sst_receive_address_upd,
+                                            wsrep_sst_receive_address_def,
+                                            (char*)wsrep_sst_receive_address);
+static sys_var_str sys_wsrep_sst_auth(&vars, "wsrep_sst_auth",
+                                      wsrep_sst_auth_check,
+                                      wsrep_sst_auth_update,
+                                      wsrep_sst_auth_default,
+                                      (char*)wsrep_sst_auth);
+static sys_var_str sys_wsrep_sst_donor(&vars, "wsrep_sst_donor",
+                                       wsrep_sst_donor_check,
+                                       wsrep_sst_donor_update,
+                                       wsrep_sst_donor_default,
+                                       (char*)wsrep_sst_donor);
+static sys_var_thd_bool sys_wsrep_on (&vars, "wsrep_on", &SV::wsrep_on,
+                                      wsrep_on_update);
+static sys_var_str sys_wsrep_start_position (&vars, "wsrep_start_position",
+                                             wsrep_start_position_check,
+                                             wsrep_start_position_update,
+                                             wsrep_start_position_default,
+                                             (char*)wsrep_start_position);
+static sys_var_ulonglong_ptr sys_wsrep_max_ws_size (&vars, "wsrep_max_ws_size",
+                                      (unsigned long long*)&wsrep_max_ws_size);
+static sys_var_long_ptr sys_wsrep_max_ws_rows (&vars, "wsrep_max_ws_rows",
+                                               (ulong*)&wsrep_max_ws_rows);
+static sys_var_const_str_ptr sys_wsrep_notify_cmd(&vars, "wsrep_notify_cmd",
+                                                (char**)&wsrep_notify_cmd);
+static sys_var_bool_ptr sys_wsrep_certify_nonPK(&vars, "wsrep_certify_nonPK",
+                                                &wsrep_certify_nonPK);
+static sys_var_thd_bool sys_consistent_reads (&vars, "wsrep_causal_reads",
+                                              &SV::wsrep_causal_reads,
+                                              wsrep_causal_reads_update);
+#endif // WITH_WSREP
 
 bool sys_var::check(THD *thd, set_var *var)
 {
@@ -2704,6 +2798,7 @@
   thd->update_charset();
   thd->protocol_text.init(thd);
   thd->protocol_binary.init(thd);
+
   return 0;
 }
 

=== modified file 'sql/set_var.h'
--- old/sql/set_var.h	2011-06-30 15:37:13 +0000
+++ new/sql/set_var.h	2011-10-12 21:45:28 +0000
@@ -1470,3 +1470,6 @@
 bool process_key_caches(process_key_cache_t func);
 void delete_elements(I_List<NAMED_LIST> *list,
 		     void (*free_element)(const char*, uchar*));
+#ifdef WITH_WSREP
+int sql_set_wsrep_variables(THD *thd, List<set_var_base> *var_list);
+#endif

=== modified file 'sql/slave.cc'
--- old/sql/slave.cc	2011-08-26 09:57:29 +0000
+++ new/sql/slave.cc	2012-01-19 22:42:33 +0000
@@ -43,6 +43,9 @@
 #include <mysqld_error.h>
 #include <mysys_err.h>
 
+#ifdef WITH_WSREP
+#include "wsrep_mysqld.h"
+#endif
 #ifdef HAVE_REPLICATION
 
 #include "rpl_tblmap.h"
@@ -3015,6 +3018,11 @@
 #endif
   DBUG_ASSERT(rli->sql_thd == thd);
 
+#ifdef WITH_WSREP
+  thd->wsrep_exec_mode= LOCAL_STATE;
+  /* synchronize with wsrep replication */
+  wsrep_ready_wait ();
+#endif
   DBUG_PRINT("master_info",("log_file_name: %s  position: %s",
                             rli->group_master_log_name,
                             llstr(rli->group_master_log_pos,llbuff)));

=== modified file 'sql/sp_head.cc'
--- old/sql/sp_head.cc	2012-02-17 09:52:41 +0000
+++ new/sql/sp_head.cc	2012-04-19 19:26:55 +0000
@@ -2807,8 +2807,11 @@
   thd_proc_info(thd, "closing tables");
   /* Here we also commit or rollback the current statement. */
   close_thread_tables(thd);
+#ifdef WITH_WSREP
+  /* if (thd->is_applier()) */ thd_proc_info(thd, "closed tables"); /*else*/
+#else /* WITH_WSREP */
   thd_proc_info(thd, 0);
-
+#endif /* WITH_WSREP */
   if (m_lex->query_tables_own_last)
   {
     /*

=== modified file 'sql/sql_base.cc'
--- old/sql/sql_base.cc	2011-08-24 07:18:00 +0000
+++ new/sql/sql_base.cc	2012-01-19 22:42:33 +0000
@@ -29,7 +29,9 @@
 #ifdef  __WIN__
 #include <io.h>
 #endif
-
+#ifdef WITH_WSREP
+#include "wsrep_mysqld.h"
+#endif // WITH_WSREP
 #define FLAGSTR(S,F) ((S) & (F) ? #F " " : "")
 
 /**
@@ -1024,7 +1026,11 @@
     pthread_mutex_lock(&thd->mysys_var->mutex);
     thd->mysys_var->current_mutex= 0;
     thd->mysys_var->current_cond= 0;
+#ifdef WITH_WSREP
+    thd_proc_info(thd, "closed_cached_tables(): wait for refresh");
+#else /* WITH_WSREP */
     thd_proc_info(thd, 0);
+#endif /* WITH_WSREP */
     pthread_mutex_unlock(&thd->mysys_var->mutex);
   }
   DBUG_RETURN(result);
@@ -3688,7 +3694,11 @@
     result=reopen_tables(thd,0,0);
   }
   pthread_mutex_unlock(&LOCK_open);
+#ifdef WITH_WSREP
+  thd_proc_info(thd, "End waiting for tables");
+#else /* WITH_WSREP */
   thd_proc_info(thd, 0);
+#endif /* WITH_WSREP */
   DBUG_RETURN(result);
 }
 
@@ -4907,7 +4917,11 @@
   }
 
  err:
+#ifdef WITH_WSREP
+  thd_proc_info(thd, "exit open_tables()");
+#else /* WITH_WSREP */
   thd_proc_info(thd, 0);
+#endif /* WITH_WSREP */
   free_root(&new_frm_mem, MYF(0));              // Free pre-alloced block
 
   if (query_tables_last_own)
@@ -5099,7 +5113,11 @@
   }
 
  end:
+#ifdef WITH_WSREP
+  thd_proc_info(thd, "End opening table");
+#else /* WITH_WSREP */
   thd_proc_info(thd, 0);
+#endif /* WITH_WSREP */
   DBUG_RETURN(table);
 }
 
@@ -8694,7 +8712,19 @@
         {
           /* Do not handle locks of MERGE children. */
 	  if (thd_table->db_stat && !thd_table->parent)	// If table is open
+#ifdef WITH_WSREP
+          {
+            signalled|= mysql_lock_abort_for_thread(thd, thd_table);
+            if (thd && wsrep_thd_is_brute_force((void *)thd)) 
+            {
+              WSREP_DEBUG("remove_table_from_cache: %llu",
+                          (unsigned long long) thd->real_id);
+              wsrep_abort_thd((void *)thd, (void *)in_use, FALSE);
+            }
+          }
+#else
 	    signalled|= mysql_lock_abort_for_thread(thd, thd_table);
+#endif
         }
       }
       else

=== modified file 'sql/sql_cache.cc'
--- old/sql/sql_cache.cc	2012-02-15 16:21:38 +0000
+++ new/sql/sql_cache.cc	2012-04-19 19:26:55 +0000
@@ -1808,6 +1808,7 @@
 {
   THD *thd= current_thd;
   DBUG_ENTER("Query_cache::invalidate_locked_for_write");
+  const char* tmp = thd_proc_info(thd, "invalidating query cache entries");
   for (; tables_used; tables_used= tables_used->next_local)
   {
     thd_proc_info(thd, "invalidating query cache entries (table)");
@@ -1817,6 +1818,7 @@
       invalidate_table(thd, tables_used->table);
     }
   }
+  thd_proc_info(thd, tmp); // restore original info
   DBUG_VOID_RETURN;
 }
 

=== modified file 'sql/sql_class.cc'
--- old/sql/sql_class.cc	2012-02-17 09:52:41 +0000
+++ new/sql/sql_class.cc	2012-04-19 19:26:55 +0000
@@ -342,7 +342,6 @@
   thd->row_count++;
 }
 
-
 /**
   Dumps a text description of a thread, its security context
   (user, host) and the current query.
@@ -439,6 +438,130 @@
   return buffer;
 }
 
+#ifdef WITH_WSREP
+extern "C" bool wsrep_thd_is_wsrep_on(THD *thd)
+{
+  return thd->variables.wsrep_on;
+}
+
+extern "C" void wsrep_thd_set_exec_mode(THD *thd, enum wsrep_exec_mode mode)
+{
+  thd->wsrep_exec_mode= mode;
+}
+extern "C" void wsrep_thd_set_query_state(
+	THD *thd, enum wsrep_query_state state)
+{
+  thd->wsrep_query_state= state;
+}
+extern "C" void wsrep_thd_set_conflict_state(
+	THD *thd, enum wsrep_conflict_state state)
+{
+  thd->wsrep_conflict_state= state;
+}
+
+
+extern "C" enum wsrep_exec_mode wsrep_thd_exec_mode(THD *thd)
+{
+  return thd->wsrep_exec_mode;
+}
+extern "C" enum wsrep_query_state wsrep_thd_query_state(THD *thd)
+{
+  return thd->wsrep_query_state;
+}
+extern "C" enum wsrep_conflict_state wsrep_thd_conflict_state(THD *thd)
+{
+  return thd->wsrep_conflict_state;
+}
+
+extern "C" wsrep_trx_handle_t* wsrep_thd_trx_handle(THD *thd)
+{
+  return &thd->wsrep_trx_handle;
+}
+
+extern "C"void wsrep_thd_LOCK(THD *thd)
+{
+  pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+}
+extern "C"void wsrep_thd_UNLOCK(THD *thd)
+{
+  pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+}
+extern "C" time_t wsrep_thd_query_start(THD *thd) 
+{
+  return thd->query_start();
+}
+extern "C" uint32 wsrep_thd_wsrep_rand(THD *thd) 
+{
+  return thd->wsrep_rand;
+}
+extern "C" my_thread_id wsrep_thd_thread_id(void *thd) 
+{
+  return ((THD*)thd)->thread_id;
+}
+extern "C" wsrep_seqno_t wsrep_thd_trx_seqno(THD *thd) 
+{
+  return thd->wsrep_trx_seqno;
+}
+extern "C" query_id_t wsrep_thd_query_id(THD *thd) 
+{
+  return thd->query_id;
+}
+extern "C" char *wsrep_thd_query(THD *thd) 
+{
+  return thd->query();
+}
+extern "C" query_id_t wsrep_thd_wsrep_last_query_id(THD *thd) 
+{
+  return thd->wsrep_last_query_id;
+}
+extern "C" void wsrep_thd_set_wsrep_last_query_id(THD *thd, query_id_t id) 
+{
+  thd->wsrep_last_query_id= id;
+}
+extern "C" void wsrep_thd_awake(THD *thd, my_bool signal)
+{
+  if (signal)
+  {
+    pthread_mutex_lock(&thd->LOCK_thd_data);
+    thd->awake(THD::KILL_QUERY);
+    pthread_mutex_unlock(&thd->LOCK_thd_data);
+  }
+  else
+  {
+    pthread_mutex_lock(&LOCK_wsrep_replaying);
+    pthread_cond_broadcast(&COND_wsrep_replaying);
+    pthread_mutex_unlock(&LOCK_wsrep_replaying);
+  }
+}
+
+extern "C" int
+wsrep_trx_order_before(void *thd1, void *thd2)
+{
+	if (((THD*)thd1)->wsrep_trx_seqno < ((THD*)thd2)->wsrep_trx_seqno) {
+		if (wsrep_debug)
+			fprintf(stderr,"\nWSREP BF conflict, order: %lld %lld\n",
+				(long long)((THD*)thd1)->wsrep_trx_seqno,
+				(long long)((THD*)thd2)->wsrep_trx_seqno);
+		return 1;
+	}
+	if (wsrep_debug)
+		fprintf(stderr,"\nWSREP: waiting for BF, trx order: %lld %lld\n",
+			(long long)((THD*)thd1)->wsrep_trx_seqno,
+			(long long)((THD*)thd2)->wsrep_trx_seqno);
+	return 0;
+}
+extern "C" int
+wsrep_trx_is_aborting(void *thd_ptr)
+{
+	if (thd_ptr) {
+		if ((((THD *)thd_ptr)->wsrep_conflict_state == MUST_ABORT) ||
+		    (((THD *)thd_ptr)->wsrep_conflict_state == ABORTING)) {
+		  return 1;
+		}
+	}
+	return 0;
+}
+#endif
 
 /**
   Implementation of Drop_table_error_handler::handle_error().
@@ -597,8 +720,11 @@
   m_status= DA_DISABLED;
 }
 
-
+#ifdef WITH_WSREP
+THD::THD(bool is_applier)
+#else
 THD::THD()
+#endif
    :Statement(&main_lex, &main_mem_root, CONVENTIONAL_EXECUTION,
               /* statement id */ 0),
    Open_tables_state(refresh_version), rli_fake(0),
@@ -623,6 +749,10 @@
    bootstrap(0),
    derived_tables_processing(FALSE),
    spcont(NULL),
+#ifdef WITH_WSREP
+   wsrep_applier(is_applier),
+   wsrep_client_thread(0),
+#endif
    m_parser_state(NULL)
 #if defined(ENABLED_DEBUG_SYNC)
    , debug_sync_control(0)
@@ -704,6 +834,16 @@
   command=COM_CONNECT;
   *scramble= '\0';
 
+#ifdef WITH_WSREP
+  (void)pthread_mutex_init(&LOCK_wsrep_thd, MY_MUTEX_INIT_FAST);
+  (void)pthread_cond_init(&COND_wsrep_thd,NULL);
+  wsrep_trx_handle.trx_id= -1;
+  wsrep_trx_handle.opaque= NULL;
+  wsrep_retry_autocommit= ::wsrep_retry_autocommit;
+  wsrep_retry_counter= 0;
+  wsrep_PA_safe= true;
+  wsrep_seqno_changed= false;
+#endif
   init();
   /* Initialize sub structures */
   init_sql_alloc(&warn_root, WARN_ALLOC_BLOCK_SIZE, WARN_ALLOC_PREALLOC_SIZE);
@@ -736,7 +876,13 @@
   substitute_null_with_insert_id = FALSE;
   thr_lock_info_init(&lock_info); /* safety: will be reset after start */
   thr_lock_owner_init(&main_lock_id, &lock_info);
-
+#ifdef WITH_WSREP
+  main_lock_id.info->mysql_thd= (void *)this;
+  main_lock_id.info->in_lock_tables= false;
+#ifdef WSREP_PROC_INFO
+  wsrep_info[sizeof(wsrep_info) - 1] = '\0'; /* make sure it is 0-terminated */
+#endif /* WSREP_PROC_INFO */
+#endif /* WITH_WSREP */
   m_internal_handler= NULL;
   m_binlog_invoker= FALSE;
   memset(&invoker_user, 0, sizeof(invoker_user));
@@ -875,6 +1021,19 @@
   update_charset();
   reset_current_stmt_binlog_row_based();
   bzero((char *) &status_var, sizeof(status_var));
+#ifdef WITH_WSREP
+  wsrep_exec_mode= wsrep_applier ? REPL_RECV :  LOCAL_STATE;
+  wsrep_conflict_state= NO_CONFLICT;
+  wsrep_query_state= QUERY_IDLE;
+  wsrep_last_query_id= 0;
+  wsrep_trx_seqno= 0;
+  wsrep_converted_lock_session= false;
+  wsrep_retry_autocommit= ::wsrep_retry_autocommit;
+  wsrep_retry_counter= 0;
+  wsrep_rli= NULL;
+  wsrep_PA_safe= true;
+  wsrep_seqno_changed= false;
+#endif
   sql_log_bin_toplevel= options & OPTION_BIN_LOG;
 
 #if defined(ENABLED_DEBUG_SYNC)
@@ -1001,6 +1160,12 @@
   pthread_mutex_unlock(&LOCK_thd_data);
   add_to_status(&global_status_var, &status_var);
 
+#ifdef WITH_WSREP
+  pthread_mutex_lock(&LOCK_wsrep_thd);
+  pthread_mutex_unlock(&LOCK_wsrep_thd);
+  pthread_mutex_destroy(&LOCK_wsrep_thd);
+  if (wsrep_rli) delete wsrep_rli;
+#endif
   /* Close connection */
 #ifndef EMBEDDED_LIBRARY
   if (net.vio)
@@ -3121,7 +3286,12 @@
 
 extern "C" int thd_binlog_format(const MYSQL_THD thd)
 {
+#ifdef WITH_WSREP
+  if ((wsrep_emulate_bin_log || mysql_bin_log.is_open()) &&
+      thd->options & OPTION_BIN_LOG)
+#else
   if (mysql_bin_log.is_open() && (thd->options & OPTION_BIN_LOG))
+#endif
     return (int) thd->variables.binlog_format;
   else
     return BINLOG_FORMAT_UNSPEC;
@@ -3739,9 +3909,12 @@
 int THD::binlog_write_row(TABLE* table, bool is_trans, 
                           MY_BITMAP const* cols, size_t colcnt, 
                           uchar const *record) 
-{ 
+{
+#ifdef WITH_WSREP
+  DBUG_ASSERT(current_stmt_binlog_row_based && (wsrep_emulate_bin_log || mysql_bin_log.is_open()));
+#else
   DBUG_ASSERT(current_stmt_binlog_row_based && mysql_bin_log.is_open());
-
+#endif
   /*
     Pack records into format for transfer. We are allocating more
     memory than needed, but that doesn't matter.
@@ -3770,7 +3943,11 @@
                            const uchar *before_record,
                            const uchar *after_record)
 { 
+#ifdef WITH_WSREP
+  DBUG_ASSERT(current_stmt_binlog_row_based && (wsrep_emulate_bin_log || mysql_bin_log.is_open()));
+#else
   DBUG_ASSERT(current_stmt_binlog_row_based && mysql_bin_log.is_open());
+#endif
 
   size_t const before_maxlen = max_row_length(table, before_record);
   size_t const after_maxlen  = max_row_length(table, after_record);
@@ -3815,7 +3992,11 @@
                            MY_BITMAP const* cols, size_t colcnt,
                            uchar const *record)
 { 
+#ifdef WITH_WSREP
+  DBUG_ASSERT(current_stmt_binlog_row_based && (wsrep_emulate_bin_log || mysql_bin_log.is_open()));
+#else
   DBUG_ASSERT(current_stmt_binlog_row_based && mysql_bin_log.is_open());
+#endif
 
   /* 
      Pack records into format for transfer. We are allocating more
@@ -3845,7 +4026,11 @@
 {
   DBUG_ENTER("THD::binlog_remove_pending_rows_event");
 
+#ifdef WITH_WSREP
+  if (!(wsrep_emulate_bin_log || mysql_bin_log.is_open()))
+#else
   if (!mysql_bin_log.is_open())
+#endif
     DBUG_RETURN(0);
 
   mysql_bin_log.remove_pending_rows_event(this);
@@ -3864,7 +4049,11 @@
     mode: it might be the case that we left row-based mode before
     flushing anything (e.g., if we have explicitly locked tables).
    */
+#ifdef WITH_WSREP
+  if (!(wsrep_emulate_bin_log || mysql_bin_log.is_open()))
+#else
   if (!mysql_bin_log.is_open())
+#endif
     DBUG_RETURN(0);
 
   /*
@@ -3939,8 +4128,11 @@
   DBUG_ENTER("THD::binlog_query");
   DBUG_PRINT("enter", ("qtype: %s  query: '%s'",
                        show_query_type(qtype), query_arg));
+#ifdef WITH_WSREP
+  DBUG_ASSERT(query_arg && (wsrep_emulate_bin_log || mysql_bin_log.is_open()));
+#else
   DBUG_ASSERT(query_arg && mysql_bin_log.is_open());
-
+#endif
   /*
     If we are not in prelocked mode, mysql_unlock_tables() will be
     called after this binlog_query(), so we have to flush the pending

=== modified file 'sql/sql_class.h'
--- old/sql/sql_class.h	2011-08-02 07:33:45 +0000
+++ new/sql/sql_class.h	2012-03-04 20:20:11 +0000
@@ -17,6 +17,31 @@
 
 
 /* Classes in mysql */
+#ifdef WITH_WSREP
+#include "../wsrep/wsrep_api.h"
+  enum wsrep_exec_mode {
+    LOCAL_STATE,
+    REPL_RECV,
+    TOTAL_ORDER,
+    LOCAL_COMMIT,
+  };
+  enum wsrep_query_state {
+    QUERY_IDLE,
+    QUERY_EXEC,
+    QUERY_COMMITTING,
+    QUERY_EXITING,
+    QUERY_ROLLINGBACK,
+  };
+  enum wsrep_conflict_state {
+    NO_CONFLICT,
+    MUST_ABORT,
+    ABORTING,
+    ABORTED,
+    MUST_REPLAY,
+    REPLAYING,
+    RETRY_AUTOCOMMIT,
+  };
+#endif
 
 #ifdef USE_PRAGMA_INTERFACE
 #pragma interface			/* gcc class implementation */
@@ -404,6 +429,11 @@
   DATE_TIME_FORMAT *datetime_format;
   DATE_TIME_FORMAT *time_format;
   my_bool sysdate_is_now;
+
+#ifdef WITH_WSREP
+  my_bool wsrep_on;
+  my_bool wsrep_causal_reads;
+#endif
 };
 
 
@@ -755,6 +785,9 @@
   uint                 length;
   Ha_trx_info         *ha_list;
 };
+#ifdef WITH_WSREP
+void wsrep_cleanup_transaction(THD *thd); // THD.transactions.cleanup calls it
+#endif
 
 enum xa_states {XA_NOTR=0, XA_ACTIVE, XA_IDLE, XA_PREPARED, XA_ROLLBACK_ONLY};
 extern const char *xa_state_names[];
@@ -1492,6 +1525,12 @@
   uint get_binlog_table_maps() const {
     return binlog_table_maps;
   }
+#ifdef WITH_WSREP
+  void wsrep_start_trans_and_stmt();
+  void wsrep_clear_binlog_table_maps() {
+    binlog_table_maps= 0;
+  }
+#endif /* WITH_WSREP */
 #endif /* MYSQL_CLIENT */
 
 public:
@@ -1511,7 +1550,11 @@
     */
     CHANGED_TABLE_LIST* changed_tables;
     MEM_ROOT mem_root; // Transaction-life memory allocation pool
+#ifdef WITH_WSREP 
+    void cleanup(THD *thd)
+#else
     void cleanup()
+#endif
     {
       changed_tables= 0;
       savepoints= 0;
@@ -1526,6 +1569,13 @@
 #ifdef USING_TRANSACTIONS
       free_root(&mem_root,MYF(MY_KEEP_PREALLOC));
 #endif
+
+#ifdef WITH_WSREP
+      // Todo: convert into a plugin method
+      // wsrep's post-commit. LOCAL_COMMIT designates wsrep's commit was ok
+      wsrep_cleanup_transaction(thd);
+#endif  /* WITH_WSREP */
+
     }
     st_transactions()
     {
@@ -1904,6 +1954,29 @@
     query_id_t first_query_id;
   } binlog_evt_union;
 
+#ifdef WITH_WSREP
+  const bool                wsrep_applier; /* dedicated slave applier thread */
+  bool                      wsrep_client_thread; /* to identify client threads*/
+  enum wsrep_exec_mode      wsrep_exec_mode;
+  query_id_t                wsrep_last_query_id;
+  enum wsrep_query_state    wsrep_query_state;
+  enum wsrep_conflict_state wsrep_conflict_state;
+  pthread_mutex_t           LOCK_wsrep_thd;
+  pthread_cond_t            COND_wsrep_thd;
+  wsrep_seqno_t             wsrep_trx_seqno;
+  uint32                    wsrep_rand;
+  Relay_log_info*           wsrep_rli;
+  bool                      wsrep_converted_lock_session;
+  wsrep_trx_handle_t        wsrep_trx_handle;
+  bool                      wsrep_seqno_changed;
+#ifdef WSREP_PROC_INFO
+  char                      wsrep_info[128]; /* string for dynamic proc info */
+#endif /* WSREP_PROC_INFO */
+  ulong                     wsrep_retry_autocommit; // max retry value
+  ulong                     wsrep_retry_counter; // of autocommit
+  bool                      wsrep_PA_safe;
+#endif /* WITH_WSREP */
+
   /**
     Internal parser state.
     Note that since the parser is not re-entrant, we keep only one parser
@@ -1920,7 +1993,11 @@
   struct st_debug_sync_control *debug_sync_control;
 #endif /* defined(ENABLED_DEBUG_SYNC) */
 
+#ifdef WITH_WSREP
+  THD(bool is_applier = false);
+#else
   THD();
+#endif
   ~THD();
 
   void init(void);

=== modified file 'sql/sql_connect.cc'
--- old/sql/sql_connect.cc	2012-02-15 16:21:38 +0000
+++ new/sql/sql_connect.cc	2012-04-19 19:26:55 +0000
@@ -26,6 +26,10 @@
 #define AUTH_PACKET_HEADER_SIZE_PROTO_40    5  
 #define AUTH_PACKET_HEADER_SIZE_CONNJ_SSL   4
 
+#ifdef WITH_WSREP
+#include "wsrep_mysqld.h"
+#endif
+
 #ifdef __WIN__
 extern void win_install_sigabrt_handler();
 #endif
@@ -81,6 +85,9 @@
   }
   thd->user_connect=uc;
   uc->connections++;
+#ifdef WITH_WSREP
+  thd->wsrep_client_thread= 1;
+#endif /* WITH_WSREP */
 end:
   (void) pthread_mutex_unlock(&LOCK_user_conn);
   return return_val;
@@ -283,6 +290,8 @@
               the client. A message is pushed into the error stack.
 */
 
+
+
 int
 check_user(THD *thd, enum enum_server_command command,
 	       const char *passwd, uint passwd_len, const char *db,
@@ -1283,6 +1292,14 @@
 static void end_connection(THD *thd)
 {
   NET *net= &thd->net;
+#ifdef WITH_WSREP
+  wsrep_status_t rcode= wsrep->free_connection(wsrep, thd->thread_id);
+  if (rcode) {
+    WSREP_WARN("wsrep failed to free connection context: %lu, code: %d",
+               thd->thread_id, rcode);
+  }
+  thd->wsrep_client_thread= 0;
+#endif
   plugin_thdvar_cleanup(thd);
   if (thd->user_connect)
     decrease_user_connections(thd->user_connect);
@@ -1456,6 +1473,12 @@
     }
     end_connection(thd);
    
+#ifdef WITH_WSREP
+  pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+  thd->wsrep_query_state= QUERY_EXITING;
+  pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+#endif
+
 end_thread:
     close_connection(thd, 0, 1);
     if (thread_scheduler.end_thread(thd,1))

=== modified file 'sql/sql_delete.cc'
--- old/sql/sql_delete.cc	2011-06-30 15:37:13 +0000
+++ new/sql/sql_delete.cc	2011-10-12 21:45:28 +0000
@@ -403,10 +403,19 @@
   /* See similar binlogging code in sql_update.cc, for comments */
   if ((error < 0) || thd->transaction.stmt.modified_non_trans_table)
   {
+#ifdef WITH_WSREP
+    // truncate command is processed under TO isolation
+    if ((wsrep_emulate_bin_log && thd->lex->sql_command != SQLCOM_TRUNCATE) || 
+        (mysql_bin_log.is_open() &&
+        !(thd->lex->sql_command == SQLCOM_TRUNCATE &&
+          thd->current_stmt_binlog_row_based &&
+          find_temporary_table(thd, table_list))))
+#else
     if (mysql_bin_log.is_open() &&
         !(thd->lex->sql_command == SQLCOM_TRUNCATE &&
           thd->current_stmt_binlog_row_based &&
           find_temporary_table(thd, table_list)))
+#endif
     {
       bool const is_trans=
         thd->lex->sql_command == SQLCOM_TRUNCATE ?
@@ -864,7 +873,11 @@
     /* 
        there is only side effects; to binlog with the error
     */
+#ifdef WITH_WSREP
+    if (wsrep_emulate_bin_log || mysql_bin_log.is_open())
+#else
     if (mysql_bin_log.is_open())
+#endif
     {
       int errcode= query_error_code(thd, thd->killed == THD::NOT_KILLED);
       /* possible error of writing binary log is ignored deliberately */
@@ -1035,7 +1048,11 @@
   }
   if ((local_error == 0) || thd->transaction.stmt.modified_non_trans_table)
   {
+#ifdef WITH_WSREP
+    if (wsrep_emulate_bin_log || mysql_bin_log.is_open())
+#else
     if (mysql_bin_log.is_open())
+#endif
     {
       int errcode= 0;
       if (local_error == 0)

=== modified file 'sql/sql_insert.cc'
--- old/sql/sql_insert.cc	2011-11-10 10:49:31 +0000
+++ new/sql/sql_insert.cc	2012-01-19 23:10:36 +0000
@@ -888,7 +888,11 @@
         thd->transaction.stmt.modified_non_trans_table ||
         was_insert_delayed)
     {
+#ifdef WITH_WSREP
+      if (wsrep_emulate_bin_log || mysql_bin_log.is_open())
+#else
       if (mysql_bin_log.is_open())
+#endif
       {
         int errcode= 0;
 	if (error <= 0)
@@ -2422,8 +2426,11 @@
       pthread_mutex_unlock(&di->thd.mysys_var->mutex);
       pthread_mutex_lock(&di->mutex);
     }
+#ifdef WITH_WSREP
+    thd_proc_info(&(di->thd), "End waiting for INSERT");
+#else /* WITH_WSREP */
     thd_proc_info(&(di->thd), 0);
-
+#endif /* WITH_WSREP */
     if (di->tables_in_use && ! thd->lock)
     {
       bool not_used;
@@ -2723,7 +2730,11 @@
       table->file->extra(HA_EXTRA_WRITE_CANNOT_REPLACE);
     }
 
+#ifdef WITH_WSREP
+    if (log_query && (wsrep_emulate_bin_log || mysql_bin_log.is_open()))
+#else
     if (log_query && mysql_bin_log.is_open())
+#endif
     {
       bool backup_time_zone_used = thd.time_zone_used;
       Time_zone *backup_time_zone = thd.variables.time_zone;
@@ -2804,7 +2815,11 @@
 	pthread_cond_broadcast(&cond_client);	// If waiting clients
     }
   }
+#ifdef WITH_WSREP
+  thd_proc_info(&thd, "insert done");
+#else /* WITH_WSREP */
   thd_proc_info(&thd, 0);
+#endif /* WITH_WSREP */
   pthread_mutex_unlock(&mutex);
 
   /*
@@ -3276,8 +3291,13 @@
     events are in the transaction cache and will be written when
     ha_autocommit_or_rollback() is issued below.
   */
+#ifdef WITH_WSREP
+  if ((wsrep_emulate_bin_log || mysql_bin_log.is_open()) &&
+      (!error || thd->transaction.stmt.modified_non_trans_table))
+#else
   if (mysql_bin_log.is_open() &&
       (!error || thd->transaction.stmt.modified_non_trans_table))
+#endif
   {
     int errcode= 0;
     if (!error)
@@ -3355,7 +3375,11 @@
     transactional_table= table->file->has_transactions();
     if (thd->transaction.stmt.modified_non_trans_table)
     {
+#ifdef WITH_WSREP
+        if (wsrep_emulate_bin_log || mysql_bin_log.is_open())
+#else
         if (mysql_bin_log.is_open())
+#endif
         {
           int errcode= query_error_code(thd, thd->killed == THD::NOT_KILLED);
           /* error of writing binary log is ignored */
@@ -3858,7 +3882,11 @@
                             /* show_database */ TRUE);
   DBUG_ASSERT(result == 0); /* store_create_info() always return 0 */
 
+#ifdef WITH_WSREP
+  if (wsrep_emulate_bin_log || mysql_bin_log.is_open())
+#else
   if (mysql_bin_log.is_open())
+#endif
   {
     result= thd->binlog_query(THD::STMT_QUERY_TYPE,
                               query.ptr(), query.length(),

=== modified file 'sql/sql_parse.cc'
--- old/sql/sql_parse.cc	2011-10-19 02:21:31 +0000
+++ new/sql/sql_parse.cc	2012-05-04 07:24:05 +0000
@@ -31,6 +31,115 @@
 #include "sql_trigger.h"
 #include "debug_sync.h"
 
+#ifdef WITH_WSREP
+#include "wsrep_mysqld.h"
+#include "rpl_rli.h"
+
+
+extern Format_description_log_event *wsrep_format_desc;
+
+/*
+ * Construct Query_log_Event from thd query and serialize it
+ * into buffer.
+ *
+ * Return 0 in case of success, 1 in case of error.
+ */
+static int wsrep_to_buf_helper(THD* thd, uchar** buf, uint* buf_len)
+{
+  IO_CACHE tmp_io_cache;
+  if (open_cached_file(&tmp_io_cache, mysql_tmpdir, TEMP_PREFIX,
+                       65536, MYF(MY_WME)))
+    return 1;
+  Query_log_event ev(thd, thd->query(), thd->query_length(), FALSE, FALSE,
+                     0);
+  int ret(0);
+  if (ev.write(&tmp_io_cache)) ret= 1;
+  if (!ret && wsrep_write_cache(&tmp_io_cache, buf, buf_len)) ret= 1;
+  close_cached_file(&tmp_io_cache);
+  return ret;
+}
+
+int wsrep_to_isolation_begin (THD* thd, const char* db_, const char* table_)
+{
+  if (thd->variables.wsrep_on && thd->wsrep_exec_mode==LOCAL_STATE)
+  {
+    wsrep_status_t ret(WSREP_WARNING);
+    uchar* buf(0);
+    uint buf_len(0);
+    wsrep_key_part_t wkey_part[2];
+    wsrep_key_t wkey = {wkey_part, 2};
+
+    WSREP_DEBUG("TO BEGIN: %lld, %d : %s", (long long)thd->wsrep_trx_seqno,
+                thd->wsrep_exec_mode, thd->query() );
+
+    if (wsrep_prepare_key_for_isolation(db_, table_,
+                                        wkey_part,
+                                        &wkey.key_parts_len)               &&
+        !wsrep_to_buf_helper(thd, &buf, &buf_len)                         &&
+        WSREP_OK == (ret = wsrep->to_execute_start(wsrep, thd->thread_id,
+                                                   &wkey, 1,
+                                                   buf, buf_len,
+                                                   &thd->wsrep_trx_seqno)))
+    {
+      thd->wsrep_exec_mode= TOTAL_ORDER;
+      wsrep_to_isolation++;
+      if (buf) my_free(buf, MYF(0));
+      const char* query = thd->query();
+      WSREP_DEBUG("TO BEGIN: '%s', seqno: %lld, mode: %d", query ? query : "",
+                  (long long)thd->wsrep_trx_seqno, thd->wsrep_exec_mode);
+    }
+    else {
+      WSREP_WARN("TO isolation failed for: %d, sql: %s. Check wsrep "
+                 "connection state and retry the query.",
+                 ret, (thd->query()) ? thd->query() : "void");
+      my_error(ER_LOCK_DEADLOCK, MYF(0), "WSREP replication failed. "
+               "your wsrep connection state and retry the query.");
+      if (buf) my_free(buf, MYF(0));
+      return 1;
+    }
+  }
+  return 0;
+}
+
+#define WSREP_TO_ISOLATION_BEGIN(thd_, db_, table_)                     \
+    if (wsrep_to_isolation_begin (thd_, db_, table_)) goto error;
+
+void wsrep_to_isolation_end(THD* thd, int res)
+{
+  if (thd->variables.wsrep_on && thd->wsrep_exec_mode==TOTAL_ORDER)
+  {
+    if (res) WSREP_WARN("Error executing '%s', seqno: %lld",
+                        thd->query(), (long long)thd->wsrep_trx_seqno);
+
+    wsrep_status_t ret;
+    wsrep_to_isolation--;
+
+    WSREP_DEBUG("TO END: %lld, %d : %s", (long long)thd->wsrep_trx_seqno,
+                thd->wsrep_exec_mode, (thd->query()) ? thd->query() : "void");
+
+    if (WSREP_OK == (ret = wsrep->to_execute_end(wsrep, thd->thread_id)))
+    {
+      thd->wsrep_exec_mode= LOCAL_STATE;
+      WSREP_DEBUG("TO END: %lld", (long long)thd->wsrep_trx_seqno);
+    }
+    else
+    {
+      WSREP_WARN("TO isolation end failed for: %d, sql: %s",
+                 ret, (thd->query()) ? thd->query() : "void");
+    }
+
+    thd->wsrep_trx_seqno= 0;
+  }
+}
+
+#define WSREP_TO_ISOLATION_END(thd_, res_)      \
+    wsrep_to_isolation_end(thd_, res_);
+
+#else
+#define WSREP_TO_ISOLATION_BEGIN(thd_, db_, table_)
+#define WSREP_TO_ISOLATION_END(thd_, res_)
+#endif /* WITH_WSREP */
+
 /**
   @defgroup Runtime_Environment Runtime Environment
   @{
@@ -186,7 +295,6 @@
   DBUG_RETURN(error);
 }
 
-
 bool begin_trans(THD *thd)
 {
   int error=0;
@@ -202,12 +310,24 @@
     close_thread_tables(thd);			// Free tables
   }
   if (end_active_trans(thd))
+    {
     error= -1;
+    }
+#ifdef WITH_WSREP
+  else if (thd->wsrep_client_thread && wsrep_causal_wait(thd))
+  {
+    error= -1;
+  }
+#endif /* WITH_WSREP */
   else
   {
     thd->options|= OPTION_BEGIN;
     thd->server_status|= SERVER_STATUS_IN_TRANS;
   }
+#ifdef WITH_WSREP
+  thd->wsrep_PA_safe= true;
+#endif /* WITH_WSREP */
+
   return error;
 }
 
@@ -378,6 +498,14 @@
   return (sql_command_flags[command] & CF_WRITE_LOGS_COMMAND) != 0;
 }
 
+#ifdef WITH_WSREP
+bool is_show_query(enum enum_sql_command command)
+{
+  DBUG_ASSERT(command >= 0 && command <= SQLCOM_END);
+  return (sql_command_flags[command] & CF_STATUS_COMMAND) != 0;
+}
+#endif
+
 void execute_init_command(THD *thd, sys_var_str *init_command_var,
 			  rw_lock_t *var_mutex)
 {
@@ -808,7 +936,20 @@
   NET *net= &thd->net;
   enum enum_server_command command;
   DBUG_ENTER("do_command");
-
+#ifdef WITH_WSREP
+  pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+  thd->wsrep_query_state= QUERY_IDLE;
+  if (thd->wsrep_conflict_state==MUST_ABORT) 
+  {
+    thd->wsrep_conflict_state= ABORTING;
+
+    pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+    end_trans(thd, ROLLBACK);
+    pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+    thd->wsrep_conflict_state= ABORTED;
+  }
+  pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+#endif
   /*
     indicator of uninitialized lex => normal flow of errors handling
     (see my_message_sql)
@@ -833,6 +974,26 @@
   net_new_transaction(net);
 
   packet_length= my_net_read(net);
+#ifdef WITH_WSREP
+  pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+  /* these THD's are aborted or are aborting during being idle */
+  if (thd->wsrep_conflict_state == ABORTING)
+  {
+    while (thd->wsrep_conflict_state == ABORTING) {
+      pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+      my_sleep(1000);
+      pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+    }
+    thd->store_globals();
+  } 
+  else if (thd->wsrep_conflict_state == ABORTED)
+  {
+    thd->store_globals();
+  }
+
+  thd->wsrep_query_state= QUERY_EXEC;
+  pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+#endif
 #if defined(ENABLED_PROFILING) && defined(COMMUNITY_SERVER)
   thd->profiling.start_new_query();
 #endif
@@ -841,7 +1002,20 @@
     DBUG_PRINT("info",("Got error %d reading command from socket %s",
 		       net->error,
 		       vio_description(net->vio)));
-
+#ifdef WITH_WSREP
+    pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+    if (thd->wsrep_conflict_state == MUST_ABORT)
+    {
+      DBUG_PRINT("wsrep",("aborted for wsrep rollback: %lu", thd->real_id));
+      thd->wsrep_conflict_state= ABORTING;
+
+      pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+      end_trans(thd, ROLLBACK);
+      pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+      thd->wsrep_conflict_state= ABORTED;
+    }
+    pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+#endif
     /* Check if we can continue without closing the connection */
 
     /* The error must be set. */
@@ -858,7 +1032,6 @@
     return_value= FALSE;
     goto out;
   }
-
   packet= (char*) net->read_pos;
   /*
     'packet_length' contains length of data, as it was stored in packet
@@ -886,12 +1059,42 @@
                      vio_description(net->vio), command,
                      command_name[command].str));
 
+#ifdef WITH_WSREP
+  /* 
+   * bail out if DB snapshot has not been installed. We however,
+   * allow queries "SET" and "SHOW", they are trapped later in execute_command()
+   */
+  if (thd->variables.wsrep_on && !thd->wsrep_applier && !wsrep_ready && 
+      command != COM_QUERY        &&
+      command != COM_PING         &&
+      command != COM_QUIT         &&
+      command != COM_PROCESS_INFO &&
+      command != COM_PROCESS_KILL &&
+      command != COM_SET_OPTION   &&
+      command != COM_SHUTDOWN     &&
+      command != COM_SLEEP        &&
+      command != COM_STATISTICS   &&
+      command != COM_TIME         &&
+      command != COM_END
+  ) {
+    my_error(ER_UNKNOWN_COM_ERROR, MYF(0), "WSREP has not yet prepared node for application use");
+    net_end_statement(thd);
+    return_value= FALSE;
+    goto out;
+  }
+#endif
   /* Restore read timeout value */
   my_net_set_read_timeout(net, thd->variables.net_read_timeout);
 
   DBUG_ASSERT(packet_length);
   return_value= dispatch_command(command, thd, packet+1, (uint) (packet_length-1));
+#ifdef WITH_WSREP
+  while (thd->wsrep_conflict_state== RETRY_AUTOCOMMIT)
+  {
+    return_value= dispatch_command(command, thd, packet+1, (uint) (packet_length-1));
 
+  }
+#endif
 out:
 #if defined(ENABLED_PROFILING) && defined(COMMUNITY_SERVER)
   thd->profiling.finish_current_query();
@@ -997,6 +1200,46 @@
   DBUG_ENTER("dispatch_command");
   DBUG_PRINT("info",("packet: '%*.s'; command: %d", packet_length, packet, command));
 
+#ifdef WITH_WSREP
+  if (!(thd->options & (OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN)))
+  {
+    thd->wsrep_PA_safe= true;
+  }
+  pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+  thd->wsrep_query_state= QUERY_EXEC;
+  if (thd->wsrep_conflict_state== RETRY_AUTOCOMMIT)
+  {
+    thd->wsrep_conflict_state= NO_CONFLICT;
+  }
+
+  bool is_autocommit= !(thd->options & (OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN)) &&
+      thd->wsrep_conflict_state == NO_CONFLICT &&
+      !thd->wsrep_applier;
+
+  if (thd->wsrep_conflict_state== MUST_ABORT)
+  {
+    thd->wsrep_conflict_state= ABORTING;
+    pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+    end_trans(thd, ROLLBACK);
+    pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+    thd->wsrep_conflict_state= ABORTED;
+  }
+  if (thd->wsrep_conflict_state== ABORTED) 
+  {
+    my_error(ER_LOCK_DEADLOCK, MYF(0), "wsrep aborted transaction");
+    pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+    thd->killed= THD::NOT_KILLED;
+    thd->mysys_var->abort= 0;
+    goto dispatch_end;
+  }
+  pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+#endif
+  if (thd->killed == THD::KILL_QUERY || thd->killed == THD::KILL_BAD_DATA) 
+  {
+    thd->killed= THD::NOT_KILLED;
+    thd->mysys_var->abort= 0;
+  }
+
   thd->command=command;
   /*
     Commands which always take a long time are logged into
@@ -1312,7 +1555,9 @@
       */
       statistic_increment(thd->status_var.questions, &LOCK_status);
       thd->query_id= next_query_id();
+#ifndef WITH_WSREP
       thd->set_time(); /* Reset the query start time. */
+#endif
       /* TODO: set thd->lex->sql_command to SQLCOM_END here */
       VOID(pthread_mutex_unlock(&LOCK_thread_count));
       mysql_parse(thd, beginning_of_next_stmt, length, &end_of_stmt);
@@ -1671,6 +1916,20 @@
     my_message(ER_UNKNOWN_COM_ERROR, ER(ER_UNKNOWN_COM_ERROR), MYF(0));
     break;
   }
+#ifdef WITH_WSREP
+ dispatch_end:
+
+  /* wsrep BF abort in query exec phase */
+  pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+  if (thd->wsrep_conflict_state == MUST_ABORT) {
+    pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+    ha_rollback_trans(thd, 0);
+    thd->transaction.stmt.reset();
+    WSREP_DEBUG("abort in exec query state, avoiding autocommit");
+    goto wsrep_must_abort;
+  }
+  pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+#endif /* WITH_WSREP */
 
   /* report error issued during command execution */
   if (thd->killed_errno())
@@ -1691,13 +1950,132 @@
 
   thd->transaction.stmt.reset();
 
+#ifdef WITH_WSREP
+ wsrep_must_abort:
+  pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+  if (thd->wsrep_conflict_state == MUST_ABORT) {
+    thd->wsrep_conflict_state= ABORTING;
+    pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+
+    WSREP_DEBUG("in dispatch_command, aborting %s",
+              (thd->query()) ? thd->query() : "void");
+    end_trans(thd, ROLLBACK);
+
+    if (thd->get_binlog_table_maps()) {
+        thd->wsrep_clear_binlog_table_maps();
+    }
+    pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+    thd->wsrep_conflict_state= ABORTED;
+  }
+  pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+
+  if (thd->variables.wsrep_on) {
+    pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+    /* checking if BF trx must be replayed */
+    if (thd->wsrep_conflict_state== MUST_REPLAY) {
+      if (thd->wsrep_exec_mode!= REPL_RECV) {
+        if (thd->main_da.is_sent) {
+          WSREP_ERROR("replay issue, thd has reported status already");
+        }
+        thd->main_da.reset_diagnostics_area();
+
+        thd->wsrep_conflict_state= REPLAYING;
+        pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+
+        mysql_reset_thd_for_next_command(thd);
+        close_thread_tables(thd);
+
+        thd_proc_info(thd, "wsrep replaying trx");
+        WSREP_DEBUG("replay trx");
+        struct wsrep_thd_shadow shadow;
+        wsrep_prepare_bf_thd(thd, &shadow);
+        int rcode = wsrep->replay_trx(wsrep,
+                                      &thd->wsrep_trx_handle,
+                                      (void *)thd);
+
+        wsrep_return_from_bf_mode(thd, &shadow);
+        if (thd->wsrep_conflict_state!= REPLAYING)
+          WSREP_WARN("lost replaying mode: %d", thd->wsrep_conflict_state );
+
+        pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+
+        switch (rcode) {
+        case WSREP_OK:
+          thd->wsrep_conflict_state= NO_CONFLICT;
+          wsrep->post_commit(wsrep, &thd->wsrep_trx_handle);
+          WSREP_DEBUG("trx_replay successful for: %llu",
+                      (long long)thd->real_id);
+          break;
+        case WSREP_TRX_FAIL:
+          if (thd->main_da.is_sent) {
+            WSREP_ERROR("replay failed, thd has reported status");
+          }
+          else
+          {
+            WSREP_DEBUG("replay failed, rolling back");
+            my_error(ER_LOCK_DEADLOCK, MYF(0), "wsrep aborted transaction");
+          }
+          thd->wsrep_conflict_state= ABORTED;
+          wsrep->post_rollback(wsrep, &thd->wsrep_trx_handle);
+          break;
+        default:
+          WSREP_ERROR("trx_replay failed for: %d", rcode);
+          /* we're now in inconsistent state, must abort */
+          unireg_abort(1);
+          break;
+        }
+	(void)pthread_mutex_lock(&LOCK_wsrep_replaying);
+	wsrep_replaying--;
+	WSREP_DEBUG("replaying decreased: %d, thd: %lu", 
+		  wsrep_replaying, thd->thread_id);
+	(void)pthread_cond_broadcast(&COND_wsrep_replaying);
+	(void)pthread_mutex_unlock(&LOCK_wsrep_replaying);
+      }
+    }
+    /* setting error code for BF aborted trxs */
+    if (thd->wsrep_conflict_state == ABORTED)
+    {
+      mysql_reset_thd_for_next_command(thd);
+      thd->killed= THD::NOT_KILLED;
+      if (is_autocommit &&
+          (thd->wsrep_retry_counter < thd->wsrep_retry_autocommit))
+      {
+        WSREP_DEBUG("wsrep retrying AC query: %s", 
+                  (thd->query()) ? thd->query() : "void");
+        thd->wsrep_conflict_state= RETRY_AUTOCOMMIT;
+        thd->wsrep_retry_counter++;            // grow
+      }
+      else
+      {
+        my_error(ER_LOCK_DEADLOCK, MYF(0), "wsrep aborted transaction");
+        thd->killed= THD::NOT_KILLED;
+        thd->wsrep_conflict_state= NO_CONFLICT;
+        thd->wsrep_retry_counter= 0;             //  reset
+      }
+    }
+    else
+    {
+      set_if_smaller(thd->wsrep_retry_counter, 0); // reset; eventually ok
+    }
+
+    if ((thd->wsrep_conflict_state != REPLAYING) &&
+        (thd->wsrep_conflict_state != RETRY_AUTOCOMMIT)) {
+        net_end_statement(thd);
+        query_cache_end_of_result(thd);
+    }
+    pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+  }
+  else {
+#endif /* WITH_WSREP */
   net_end_statement(thd);
   query_cache_end_of_result(thd);
+#ifdef WITH_WSREP
+  }
+#endif /* WITH_WSREP */
 
   thd->proc_info= "closing tables";
   /* Free tables */
   close_thread_tables(thd);
-
   log_slow_statement(thd);
 
   thd_proc_info(thd, "cleaning up");
@@ -1706,9 +2084,14 @@
   VOID(pthread_mutex_lock(&LOCK_thread_count)); // For process list
   thread_running--;
   VOID(pthread_mutex_unlock(&LOCK_thread_count));
+#ifdef WITH_WSREP
+  thd_proc_info(thd, "sleeping");
+#else /* WITH_WSREP */
   thd_proc_info(thd, 0);
+#endif /* WITH_WSREP */
   thd->packet.shrink(thd->variables.net_buffer_length);	// Reclaim some memory
   free_root(thd->mem_root,MYF(MY_KEEP_PREALLOC));
+
   DBUG_RETURN(error);
 }
 
@@ -2104,7 +2487,6 @@
 #ifdef WITH_PARTITION_STORAGE_ENGINE
   thd->work_part_info= 0;
 #endif
-
   /*
     In many cases first table of main SELECT_LEX have special meaning =>
     check that it is first table in global list and relink it first in 
@@ -2263,6 +2645,42 @@
 #ifdef HAVE_REPLICATION
   } /* endif unlikely slave */
 #endif
+#ifdef WITH_WSREP
+  /*
+    change LOCK TABLE WRITE to transaction
+  */
+  if (lex->sql_command== SQLCOM_LOCK_TABLES && wsrep_convert_LOCK_to_trx)
+  {
+        for (TABLE_LIST *table= all_tables; table; table= table->next_global)
+        {
+          if (table->lock_type >= TL_WRITE_ALLOW_WRITE)
+          {
+            lex->sql_command= SQLCOM_BEGIN;
+            thd->wsrep_converted_lock_session= true;
+            break;
+          }
+        }
+  }
+  if (lex->sql_command== SQLCOM_UNLOCK_TABLES && 
+      thd->wsrep_converted_lock_session)
+  {
+    thd->wsrep_converted_lock_session= false;
+    lex->sql_command= SQLCOM_COMMIT;
+    lex->tx_release= 0;
+  }
+
+  /* 
+   * bail out if DB snapshot has not been installed. We however,
+   * allow SET and SHOW queries
+   */
+  if (thd->variables.wsrep_on && !thd->wsrep_applier && !wsrep_ready &&
+      lex->sql_command != SQLCOM_SET_OPTION &&
+      !is_show_query(lex->sql_command))
+  {
+    my_error(ER_UNKNOWN_COM_ERROR, MYF(0), "WSREP has not yet prepared node for application use");
+    goto error;
+  }
+#endif /* WITH_WSREP */
   status_var_increment(thd->status_var.com_stat[lex->sql_command]);
 
   DBUG_ASSERT(thd->transaction.stmt.modified_non_trans_table == FALSE);
@@ -2276,6 +2694,9 @@
 #endif
   case SQLCOM_SHOW_STATUS_PROC:
   case SQLCOM_SHOW_STATUS_FUNC:
+#ifdef WITH_WSREP
+    if (wsrep_causal_wait(thd)) goto error;
+#endif /* WITH_WSREP */
     if (!(res= check_table_access(thd, SELECT_ACL, all_tables, UINT_MAX, FALSE)))
       res= execute_sqlcom_select(thd, all_tables);
     break;
@@ -2283,6 +2704,9 @@
   {
     system_status_var old_status_var= thd->status_var;
     thd->initial_status_var= &old_status_var;
+#ifdef WITH_WSREP
+    if (wsrep_causal_wait(thd)) goto error;
+#endif /* WITH_WSREP */
     if (!(res= check_table_access(thd, SELECT_ACL, all_tables, UINT_MAX, FALSE)))
       res= execute_sqlcom_select(thd, all_tables);
     /* Don't log SHOW STATUS commands to slow query log */
@@ -2307,12 +2731,22 @@
   case SQLCOM_SHOW_PLUGINS:
   case SQLCOM_SHOW_FIELDS:
   case SQLCOM_SHOW_KEYS:
+#ifndef WITH_WSREP
   case SQLCOM_SHOW_VARIABLES:
   case SQLCOM_SHOW_CHARSETS:
   case SQLCOM_SHOW_COLLATIONS:
   case SQLCOM_SHOW_STORAGE_ENGINES:
   case SQLCOM_SHOW_PROFILE:
+#endif /* WITH_WSREP */
   case SQLCOM_SELECT:
+#ifdef WITH_WSREP
+    if (wsrep_causal_wait(thd)) goto error;
+  case SQLCOM_SHOW_VARIABLES:
+  case SQLCOM_SHOW_CHARSETS:
+  case SQLCOM_SHOW_COLLATIONS:
+  case SQLCOM_SHOW_STORAGE_ENGINES:
+  case SQLCOM_SHOW_PROFILE:
+#endif /* WITH_WSREP */
     thd->status_var.last_query_cost= 0.0;
     if (all_tables)
     {
@@ -2845,15 +3279,19 @@
       if (create_info.options & HA_LEX_CREATE_TMP_TABLE)
         thd->options|= OPTION_KEEP_LOG;
       /* regular create */
+      WSREP_TO_ISOLATION_BEGIN(thd, create_table->db, create_table->table_name)
       if (create_info.options & HA_LEX_CREATE_TABLE_LIKE)
+      {
         res= mysql_create_like_table(thd, create_table, select_tables,
                                      &create_info);
+      }
       else
       {
         res= mysql_create_table(thd, create_table->db,
                                 create_table->table_name, &create_info,
                                 &alter_info, 0, 0);
       }
+      WSREP_TO_ISOLATION_END(thd, res)
       if (!res)
 	my_ok(thd);
     }
@@ -2887,6 +3325,8 @@
       goto error; /* purecov: inspected */
     if (end_active_trans(thd))
       goto error;
+    WSREP_TO_ISOLATION_BEGIN(thd, first_table->db, first_table->table_name)
+      if (create_info.options & HA_LEX_CREATE_TABLE_LIKE)
     /*
       Currently CREATE INDEX or DROP INDEX cause a full table rebuild
       and thus classify as slow administrative statements just like
@@ -2902,6 +3342,7 @@
     res= mysql_alter_table(thd, first_table->db, first_table->table_name,
                            &create_info, first_table, &alter_info,
                            0, (ORDER*) 0, 0);
+    WSREP_TO_ISOLATION_END(thd, res)
     break;
   }
 #ifdef HAVE_REPLICATION
@@ -3009,6 +3450,8 @@
       }
 
       thd->enable_slow_log= opt_log_slow_admin_statements;
+
+      WSREP_TO_ISOLATION_BEGIN(thd, first_table->db, first_table->table_name)
       res= mysql_alter_table(thd, select_lex->db, lex->name.str,
                              &create_info,
                              first_table,
@@ -3016,6 +3459,7 @@
                              select_lex->order_list.elements,
                              (ORDER *) select_lex->order_list.first,
                              lex->ignore);
+      WSREP_TO_ISOLATION_END(thd, res)
       break;
     }
   case SQLCOM_RENAME_TABLE:
@@ -3044,8 +3488,21 @@
         goto error;
     }
 
-    if (end_active_trans(thd) || mysql_rename_tables(thd, first_table, 0))
+    if (end_active_trans(thd))
       goto error;
+
+#ifndef WITH_WSREP
+    if (mysql_rename_tables(thd, first_table, 0))
+    {
+      goto error;
+    }
+#else
+    int res;
+    WSREP_TO_ISOLATION_BEGIN(thd, first_table->db, first_table->table_name)
+    res= mysql_rename_tables(thd, first_table, 0);
+    WSREP_TO_ISOLATION_END(thd, res)
+    if (res) goto error;
+#endif /* WITH_WSREP */
     break;
   }
 #ifndef EMBEDDED_LIBRARY
@@ -3071,6 +3528,9 @@
     goto error;
 #else
     {
+#ifdef WITH_WSREP
+      if (wsrep_causal_wait(thd)) goto error;
+#endif /* WITH_WSREP */
       /* Ignore temporary tables if this is "SHOW CREATE VIEW" */
       if (lex->only_view)
         first_table->skip_temporary= 1;
@@ -3083,6 +3543,9 @@
   case SQLCOM_CHECKSUM:
   {
     DBUG_ASSERT(first_table == all_tables && first_table != 0);
+#ifdef WITH_WSREP
+    if (wsrep_causal_wait(thd)) goto error;
+#endif /* WITH_WSREP */
     if (check_table_access(thd, SELECT_ACL | EXTRA_ACL, all_tables,
                            UINT_MAX, FALSE))
       goto error; /* purecov: inspected */
@@ -3096,7 +3559,9 @@
                            UINT_MAX, FALSE))
       goto error; /* purecov: inspected */
     thd->enable_slow_log= opt_log_slow_admin_statements;
+    WSREP_TO_ISOLATION_BEGIN(thd, first_table->db, first_table->table_name)
     res= mysql_repair_table(thd, first_table, &lex->check_opt);
+    WSREP_TO_ISOLATION_END(thd, res)
     /* ! we write after unlocking the table */
     if (!res && !lex->no_write_to_binlog)
     {
@@ -3149,9 +3614,11 @@
                            UINT_MAX, FALSE))
       goto error; /* purecov: inspected */
     thd->enable_slow_log= opt_log_slow_admin_statements;
+    WSREP_TO_ISOLATION_BEGIN(thd, first_table->db, first_table->table_name)
     res= (specialflag & (SPECIAL_SAFE_MODE | SPECIAL_NO_NEW_FUNC)) ?
       mysql_recreate_table(thd, first_table) :
       mysql_optimize_table(thd, first_table, &lex->check_opt);
+    WSREP_TO_ISOLATION_END(thd, res)
     /* ! we write after unlocking the table */
     if (!res && !lex->no_write_to_binlog)
     {
@@ -3418,7 +3885,9 @@
     }
     if (!(need_start_waiting= !wait_if_global_read_lock(thd, 0, 1)))
       goto error;
+    WSREP_TO_ISOLATION_BEGIN(thd, first_table->db, first_table->table_name)
     res= mysql_truncate(thd, first_table, 0);
+    WSREP_TO_ISOLATION_END(thd, res)
     break;
   case SQLCOM_DELETE:
   {
@@ -3508,9 +3977,12 @@
       /* So that DROP TEMPORARY TABLE gets to binlog at commit/rollback */
       thd->options|= OPTION_KEEP_LOG;
     }
+
+    WSREP_TO_ISOLATION_BEGIN(thd, first_table->db, first_table->table_name)
     /* DDL and binlog write order protected by LOCK_open */
     res= mysql_rm_table(thd, first_table, lex->drop_if_exists,
 			lex->drop_temporary);
+    WSREP_TO_ISOLATION_END(thd, res)
   }
   break;
   case SQLCOM_SHOW_PROCESSLIST:
@@ -3553,7 +4025,9 @@
     LEX_STRING db_str= { (char *) select_lex->db, strlen(select_lex->db) };
 
     if (!mysql_change_db(thd, &db_str, FALSE))
+    {
       my_ok(thd);
+    }
 
     break;
   }
@@ -3582,7 +4056,7 @@
         !(need_start_waiting= !wait_if_global_read_lock(thd, 0, 1)))
       goto error;
 
-    res= mysql_load(thd, lex->exchange, first_table, lex->field_list,
+      res= mysql_load(thd, lex->exchange, first_table, lex->field_list,
                     lex->update_list, lex->value_list, lex->duplicates,
                     lex->ignore, (bool) lex->local_file);
     break;
@@ -3720,8 +4194,11 @@
     if (check_access(thd,CREATE_ACL,lex->name.str, 0, 1, 0,
                      is_schema_db(lex->name.str, lex->name.length)))
       break;
+
+    WSREP_TO_ISOLATION_BEGIN(thd, lex->name.str, NULL)  
     res= mysql_create_db(thd,(lower_case_table_names == 2 ? alias :
                               lex->name.str), &create_info, 0);
+    WSREP_TO_ISOLATION_END(thd, res)
     break;
   }
   case SQLCOM_DROP_DB:
@@ -3761,7 +4238,10 @@
                  ER(ER_LOCK_OR_ACTIVE_TRANSACTION), MYF(0));
       goto error;
     }
+
+    WSREP_TO_ISOLATION_BEGIN(thd, lex->name.str, NULL)
     res= mysql_rm_db(thd, lex->name.str, lex->drop_if_exists, 0);
+    WSREP_TO_ISOLATION_END(thd, res)
     break;
   }
   case SQLCOM_ALTER_DB_UPGRADE:
@@ -3805,7 +4285,9 @@
       goto error;
     }
 
+    WSREP_TO_ISOLATION_BEGIN(thd, db->str, NULL)
     res= mysql_upgrade_db(thd, db);
+    WSREP_TO_ISOLATION_END(thd, res)
     if (!res)
       my_ok(thd);
     break;
@@ -3844,7 +4326,10 @@
                  ER(ER_LOCK_OR_ACTIVE_TRANSACTION), MYF(0));
       goto error;
     }
+
+    WSREP_TO_ISOLATION_BEGIN(thd, db->str, NULL)
     res= mysql_alter_db(thd, db->str, &create_info);
+    WSREP_TO_ISOLATION_END(thd, res)
     break;
   }
   case SQLCOM_SHOW_CREATE_DB:
@@ -3876,6 +4361,8 @@
     if (res)
       break;
 
+    WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
+
     switch (lex->sql_command) {
     case SQLCOM_CREATE_EVENT:
     {
@@ -3892,6 +4379,7 @@
     default:
       DBUG_ASSERT(0);
     }
+    WSREP_TO_ISOLATION_END(thd, res)
     DBUG_PRINT("info",("DDL error code=%d", res));
     if (!res)
       my_ok(thd);
@@ -3910,10 +4398,12 @@
                                    lex->spname->m_name);
     break;
   case SQLCOM_DROP_EVENT:
+    WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
     if (!(res= Events::drop_event(thd,
                                   lex->spname->m_db, lex->spname->m_name,
                                   lex->drop_if_exists)))
       my_ok(thd);
+    WSREP_TO_ISOLATION_END(thd, res)
     break;
 #else
     my_error(ER_NOT_SUPPORTED_YET,MYF(0),"embedded server");
@@ -3924,8 +4414,10 @@
     if (check_access(thd,INSERT_ACL,"mysql",0,1,0,0))
       break;
 #ifdef HAVE_DLOPEN
+    WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
     if (!(res = mysql_create_function(thd, &lex->udf)))
       my_ok(thd);
+    WSREP_TO_ISOLATION_END(thd, res)
 #else
     my_error(ER_CANT_OPEN_LIBRARY, MYF(0), lex->udf.dl, 0, "feature disabled");
     res= TRUE;
@@ -3940,9 +4432,11 @@
       break;
     if (end_active_trans(thd))
       goto error;
+    WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
     /* Conditionally writes to binlog */
     if (!(res= mysql_create_user(thd, lex->users_list)))
       my_ok(thd);
+    WSREP_TO_ISOLATION_END(thd, res)
     break;
   }
   case SQLCOM_DROP_USER:
@@ -3953,8 +4447,10 @@
     if (end_active_trans(thd))
       goto error;
     /* Conditionally writes to binlog */
+    WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
     if (!(res= mysql_drop_user(thd, lex->users_list)))
       my_ok(thd);
+    WSREP_TO_ISOLATION_END(thd, res)
     break;
   }
   case SQLCOM_RENAME_USER:
@@ -3965,8 +4461,10 @@
     if (end_active_trans(thd))
       goto error;
     /* Conditionally writes to binlog */
+    WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
     if (!(res= mysql_rename_user(thd, lex->users_list)))
       my_ok(thd);
+    WSREP_TO_ISOLATION_END(thd, res)
     break;
   }
   case SQLCOM_REVOKE_ALL:
@@ -3981,8 +4479,10 @@
     thd->binlog_invoker();
 
     /* Conditionally writes to binlog */
+    WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
     if (!(res = mysql_revoke_all(thd, lex->users_list)))
       my_ok(thd);
+    WSREP_TO_ISOLATION_END(thd, res)
     break;
   }
   case SQLCOM_REVOKE:
@@ -4047,10 +4547,12 @@
                                 lex->type == TYPE_ENUM_PROCEDURE, 0))
 	  goto error;
         /* Conditionally writes to binlog */
+        WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
         res= mysql_routine_grant(thd, all_tables,
                                  lex->type == TYPE_ENUM_PROCEDURE, 
                                  lex->users_list, grants,
                                  lex->sql_command == SQLCOM_REVOKE, TRUE);
+        WSREP_TO_ISOLATION_END(thd, res)
         if (!res)
           my_ok(thd);
       }
@@ -4060,9 +4562,11 @@
                         all_tables, 0, UINT_MAX, 0))
 	  goto error;
         /* Conditionally writes to binlog */
+        WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
         res= mysql_table_grant(thd, all_tables, lex->users_list,
 			       lex->columns, lex->grant,
 			       lex->sql_command == SQLCOM_REVOKE);
+        WSREP_TO_ISOLATION_END(thd, res)
       }
     }
     else
@@ -4074,9 +4578,18 @@
         goto error;
       }
       else
+#ifdef WITH_WSREP
+        {
+          // needed to add a block to make all this happen in else branch
+          WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
+#endif
 	/* Conditionally writes to binlog */
 	res = mysql_grant(thd, select_lex->db, lex->users_list, lex->grant,
 			  lex->sql_command == SQLCOM_REVOKE);
+#ifdef WITH_WSREP
+          WSREP_TO_ISOLATION_END(thd, res)
+        }
+#endif
       if (!res)
       {
 	if (lex->sql_command == SQLCOM_GRANT)
@@ -4193,9 +4706,15 @@
       able to open it (with SQLCOM_HA_OPEN) in the first place.
     */
     unit->set_limit(select_lex);
+#ifdef WITH_WSREP
+    { const char* tmp_info = thd_proc_info(thd, "mysql_ha_read()");
+#endif /* WITH_WSREP */
     res= mysql_ha_read(thd, first_table, lex->ha_read_mode, lex->ident.str,
                        lex->insert_list, lex->ha_rkey_mode, select_lex->where,
                        unit->select_limit_cnt, unit->offset_limit_cnt);
+#ifdef WITH_WSREP
+    thd_proc_info(thd, tmp_info); }
+#endif /* WITH_WSREP */
     break;
 
   case SQLCOM_BEGIN:
@@ -4218,13 +4737,26 @@
     if (end_trans(thd, lex->tx_release ? COMMIT_RELEASE :
                               lex->tx_chain ? COMMIT_AND_CHAIN : COMMIT))
       goto error;
+#ifdef WITH_WSREP
+    if (thd->wsrep_conflict_state == NO_CONFLICT ||
+        thd->wsrep_conflict_state == REPLAYING) {
+      my_ok(thd);
+    }
+#else
     my_ok(thd);
+#endif /* WITH_WSREP */
     break;
   case SQLCOM_ROLLBACK:
     if (end_trans(thd, lex->tx_release ? ROLLBACK_RELEASE :
                               lex->tx_chain ? ROLLBACK_AND_CHAIN : ROLLBACK))
       goto error;
+#ifdef WITH_WSREP
+    if (thd->wsrep_conflict_state == NO_CONFLICT) {
+      my_ok(thd);
+    }
+#else
     my_ok(thd);
+#endif /* WITH_WSREP */
     break;
   case SQLCOM_RELEASE_SAVEPOINT:
   {
@@ -4377,6 +4909,7 @@
     if (sp_process_definer(thd))
       goto create_sp_error;
 
+    WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
     res= (sp_result= lex->sphead->create(thd));
     switch (sp_result) {
     case SP_OK: {
@@ -4445,6 +4978,7 @@
       my_error(ER_SP_STORE_FAILED, MYF(0), SP_TYPE_STRING(lex), name);
     break;
     } /* end switch */
+    WSREP_TO_ISOLATION_END(thd, res)
 
     /*
       Capture all errors within this CASE and
@@ -4603,6 +5137,7 @@
         }
         else
         {
+          WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
           /*
             Note that if you implement the capability of ALTER FUNCTION to
             alter the body of the function, this command should be made to
@@ -4619,6 +5154,7 @@
                                        type,
                                        lex->spname,
                                        &lex->sp_chistics);
+          WSREP_TO_ISOLATION_END(thd, res)
         }
       }
       switch (sp_result)
@@ -4657,6 +5193,7 @@
 
         if (end_active_trans(thd)) 
           goto error;
+        WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
 #ifndef NO_EMBEDDED_ACCESS_CHECKS
 	if (sp_automatic_privileges && !opt_noacl &&
 	    sp_revoke_privileges(thd, db, name, 
@@ -4674,6 +5211,7 @@
                   TYPE_ENUM_FUNCTION;
 
         sp_result= sp_drop_routine(thd, type, lex->spname);
+        WSREP_TO_ISOLATION_END(thd, res)
       }
       else
       {
@@ -4687,11 +5225,14 @@
 	    if (check_access(thd, DELETE_ACL, "mysql", 0, 1, 0, 0))
 	      goto error;
 
+            WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
 	    if (!(res = mysql_drop_function(thd, &lex->spname->m_name)))
 	    {
+              WSREP_TO_ISOLATION_END(thd, res)
 	      my_ok(thd);
 	      break;
 	    }
+            WSREP_TO_ISOLATION_END(thd, res)
 	  }
 	}
 #endif
@@ -4793,7 +5334,9 @@
       if (end_active_trans(thd))
         goto error;
 
+      WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
       res= mysql_create_view(thd, first_table, thd->lex->create_view_mode);
+      WSREP_TO_ISOLATION_END(thd, res)
       break;
     }
   case SQLCOM_DROP_VIEW:
@@ -4802,7 +5345,9 @@
           end_active_trans(thd))
         goto error;
       /* Conditionally writes to binlog. */
+      WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
       res= mysql_drop_view(thd, first_table, thd->lex->drop_mode);
+      WSREP_TO_ISOLATION_END(thd, res)
       break;
     }
   case SQLCOM_CREATE_TRIGGER:
@@ -4811,7 +5356,9 @@
       goto error;
 
     /* Conditionally writes to binlog. */
+    WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
     res= mysql_create_or_drop_trigger(thd, all_tables, 1);
+    WSREP_TO_ISOLATION_END(thd, res)
 
     break;
   }
@@ -4821,7 +5368,9 @@
       goto error;
 
     /* Conditionally writes to binlog. */
+    WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
     res= mysql_create_or_drop_trigger(thd, all_tables, 0);
+    WSREP_TO_ISOLATION_END(thd, res)
     break;
   }
   case SQLCOM_XA_START:
@@ -5026,13 +5575,18 @@
       my_ok(thd);
     break;
   case SQLCOM_INSTALL_PLUGIN:
+    WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
     if (! (res= mysql_install_plugin(thd, &thd->lex->comment,
                                      &thd->lex->ident)))
       my_ok(thd);
+    WSREP_TO_ISOLATION_END(thd, res)
+
     break;
   case SQLCOM_UNINSTALL_PLUGIN:
+    WSREP_TO_ISOLATION_BEGIN(thd, NULL, NULL)
     if (! (res= mysql_uninstall_plugin(thd, &thd->lex->comment)))
       my_ok(thd);
+    WSREP_TO_ISOLATION_END(thd, res)
     break;
   case SQLCOM_BINLOG_BASE64_EVENT:
   {
@@ -5828,6 +6382,20 @@
   thd->auto_inc_intervals_in_cur_stmt_for_binlog.empty();
   thd->stmt_depends_on_first_successful_insert_id_in_prev_stmt= 0;
 
+#if defined(WITH_WSREP)
+  if (wsrep_auto_increment_control)
+  {
+    if (thd->variables.auto_increment_offset !=
+        global_system_variables.auto_increment_offset)
+      thd->variables.auto_increment_offset=
+        global_system_variables.auto_increment_offset;
+    if (thd->variables.auto_increment_increment !=
+        global_system_variables.auto_increment_increment)
+      thd->variables.auto_increment_increment=
+        global_system_variables.auto_increment_increment;
+  }
+#endif
+
   thd->query_start_used= 0;
   thd->is_fatal_error= thd->time_zone_used= 0;
   /*
@@ -7089,6 +7657,16 @@
         unlock_global_read_lock(thd);
         return 1;
       }
+#ifdef WITH_WSREP
+      /*
+        We need to do it second time after wsrep appliers were blocked in
+        make_global_read_lock_block_commit(thd) above since they could have
+        modified the tables too.
+      */
+      if (close_cached_tables(thd, tables, FALSE, (options & REFRESH_FAST) ?
+                              FALSE : TRUE, TRUE))
+          result= 1;
+#endif /* WITH_WSREP */
     }
     else
     {
@@ -7830,6 +8408,529 @@
   return definer;
 }
 
+#ifdef WITH_WSREP
+static enum wsrep_status wsrep_apply_sql(
+   THD *thd, const char *sql, size_t sql_len, time_t timeval, uint32 randseed) 
+{
+  int error;
+  enum wsrep_status ret_code= WSREP_OK;
+
+  DBUG_ENTER("wsrep_bf_execute_cb");
+  thd->wsrep_exec_mode= REPL_RECV;
+  thd->net.vio= 0;
+  thd->start_time= timeval;
+  thd->wsrep_rand= randseed;
+
+  thd->options|= OPTION_NOT_AUTOCOMMIT;
+
+  DBUG_PRINT("wsrep", ("SQL: %s", sql));
+
+  pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+  thd->wsrep_query_state= QUERY_EXEC;
+  /* preserve replaying mode */
+  if (thd->wsrep_conflict_state!= REPLAYING)
+    thd->wsrep_conflict_state= NO_CONFLICT;
+  pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+
+  if ((error= dispatch_command(COM_QUERY, thd, (char*)sql, sql_len))) {
+    WSREP_WARN("BF SQL apply failed: %d, seqno: %lld",
+               thd->wsrep_conflict_state, (long long)thd->wsrep_trx_seqno);
+    DBUG_RETURN(WSREP_FATAL);
+  }
+
+  pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+  if (thd->wsrep_conflict_state!= NO_CONFLICT && 
+      thd->wsrep_conflict_state!= REPLAYING) {
+    ret_code= WSREP_FATAL;
+    WSREP_DEBUG("BF thd ending, with: %d, seqno %lld",
+                thd->wsrep_conflict_state, (long long)thd->wsrep_trx_seqno);
+  }
+  pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+
+  assert(thd->wsrep_exec_mode== REPL_RECV);
+  DBUG_RETURN(ret_code);
+}
+
+void wsrep_write_rbr_buf(
+    THD *thd, const void* rbr_buf, size_t buf_len)
+{
+  char filename[PATH_MAX]= {0};
+  int len= snprintf(filename, PATH_MAX, "%s/GRA_%ld_%lld.log",
+                    wsrep_data_home_dir, thd->thread_id,
+                    (long long)thd->wsrep_trx_seqno);
+  if (len >= PATH_MAX)
+  {
+    WSREP_ERROR("RBR dump path too long: %d, skipping dump.", len);
+    return;
+  }
+
+  FILE *of= fopen(filename, "wb");
+  if (of)
+  {
+    fwrite (rbr_buf, buf_len, 1, of);
+    fclose(of);
+  }
+  else
+  {
+    WSREP_ERROR("Failed to open file '%s': %d (%s)",
+                filename, errno, strerror(errno));
+  }
+}
+
+static inline wsrep_status_t wsrep_apply_rbr(
+    THD *thd, const uchar *rbr_buf, size_t buf_len)
+{
+  char *buf= (char *)rbr_buf;
+  int rcode= 0;
+  int event= 1;
+
+  DBUG_ENTER("wsrep_apply_rbr");
+
+  if (thd->killed == THD::KILL_CONNECTION)
+  {
+    WSREP_INFO("applier has been aborted, skipping apply_rbr, seqno: %lld",
+               (long long) thd->wsrep_trx_seqno);
+    DBUG_RETURN(WSREP_FATAL);
+  }
+
+  pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+  thd->wsrep_query_state= QUERY_EXEC;
+  if (thd->wsrep_conflict_state!= REPLAYING)
+    thd->wsrep_conflict_state= NO_CONFLICT;
+  pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+
+  if (!buf_len) WSREP_WARN("empty rbr buffer to apply, seqno: %lld",
+                           (long long) thd->wsrep_trx_seqno);
+
+  if ((rcode= begin_trans(thd)))
+    WSREP_WARN("begin for RBR apply failed, seqno: %lld, code: %d",
+               (long long) thd->wsrep_trx_seqno, rcode);
+
+  while(buf_len)
+  {
+    int exec_res;
+    int error = 0;
+    Log_event* ev=  wsrep_read_log_event(&buf, &buf_len, wsrep_format_desc);
+
+    switch (ev->get_type_code()) {
+    case WRITE_ROWS_EVENT:
+    case UPDATE_ROWS_EVENT:
+    case DELETE_ROWS_EVENT:
+      DBUG_ASSERT(buf_len != 0 ||
+                  ((Rows_log_event *) ev)->get_flags(Rows_log_event::STMT_END_F));
+      break;
+    case TABLE_MAP_EVENT:
+      break;
+    case QUERY_EVENT:
+      WSREP_DEBUG("query event: %s", ((Query_log_event*)ev)->query);
+      break;
+    default:
+      WSREP_WARN("Unknown event type code %d, discarding",
+                 ev->get_type_code());
+      goto cleanup;
+    }
+
+
+    thd->server_id = ev->server_id; // use the original server id for logging
+    thd->set_time();                // time the query
+    thd->lex->current_select= 0;
+    if (!ev->when)
+      ev->when = time(NULL);
+    ev->thd = thd;
+    exec_res = ev->apply_event(thd->wsrep_rli);
+    DBUG_PRINT("info", ("exec_event result: %d", exec_res));
+
+    if (exec_res)
+    {
+      WSREP_WARN("RBR event %d apply warning: %d, seqno: %lld",
+                 event, exec_res, (long long) thd->wsrep_trx_seqno);
+      rcode= exec_res;
+      /* stop processing for the first error */
+      delete ev;
+      goto error;
+    }
+    event++;
+
+    if (thd->wsrep_conflict_state!= NO_CONFLICT && 
+        thd->wsrep_conflict_state!= REPLAYING)
+      WSREP_WARN("conflict state after RBR event applying: %d, seqno: %lld",
+                 thd->wsrep_query_state, (long long)thd->wsrep_trx_seqno);
+
+    if (thd->wsrep_conflict_state == MUST_ABORT) {
+      WSREP_WARN("RBR event apply failed, rolling back, seqno: %lld",
+                 (long long) thd->wsrep_trx_seqno);
+      end_trans(thd, ROLLBACK);
+      thd->wsrep_conflict_state= NO_CONFLICT;
+      DBUG_RETURN(WSREP_FATAL);
+    }
+
+  cleanup:
+    if (ev->get_type_code() != TABLE_MAP_EVENT &&
+        ((Rows_log_event *) ev)->get_flags(Rows_log_event::STMT_END_F))
+    {
+      // TODO: combine with commit on higher level common for the query ws
+
+      thd->wsrep_rli->cleanup_context(thd, 0);
+
+      if (error == 0)
+      {
+        thd->clear_error();
+      }
+      else
+        WSREP_ERROR("Error in %s event: commit of row events failed, seqno: "
+                    "%lld",
+                    ev->get_type_str(), (long long)thd->wsrep_trx_seqno);
+    }
+    delete ev;
+  }
+
+ error:
+  pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+  thd->wsrep_query_state= QUERY_IDLE;
+  pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+
+  assert(thd->wsrep_exec_mode== REPL_RECV);
+
+  if (thd->killed == THD::KILL_CONNECTION)
+    WSREP_INFO("applier aborted: %lld", (long long)thd->wsrep_trx_seqno);
+
+  if (rcode) DBUG_RETURN(WSREP_FATAL);
+  DBUG_RETURN(WSREP_OK);
+}
+
+wsrep_status_t wsrep_apply_cb(void* const ctx,
+                              const void* const buf, size_t const buf_len,
+                              wsrep_seqno_t const global_seqno)
+{
+  THD* const thd((THD*)ctx);
+
+  thd->wsrep_trx_seqno= global_seqno;
+
+#ifdef WSREP_PROC_INFO
+  snprintf(thd->wsrep_info, sizeof(thd->wsrep_info) - 1,
+           "applying write set %lld: %p, %zu",
+           (long long)thd->wsrep_trx_seqno, buf, buf_len);
+  thd_proc_info(thd, thd->wsrep_info);
+#else
+  thd_proc_info(thd, "applying write set");
+#endif /* WSREP_PROC_INFO */
+
+  wsrep_status_t const rcode(wsrep_apply_rbr(thd, (const uchar*)buf, buf_len));
+
+#ifdef WSREP_PROC_INFO
+  snprintf(thd->wsrep_info, sizeof(thd->wsrep_info) - 1,
+           "applied write set %lld", (long long)thd->wsrep_trx_seqno);
+  thd_proc_info(thd, thd->wsrep_info);
+#else
+  thd_proc_info(thd, "applied write set");
+#endif /* WSREP_PROC_INFO */
+
+  if (WSREP_OK != rcode) wsrep_write_rbr_buf(thd, buf, buf_len);
+
+  return rcode;
+}
+
+/* a common wrapper for end_trans() function - to put all necessary stuff */
+static inline wsrep_status_t
+wsrep_end_trans (THD* const thd, enum enum_mysql_completiontype const end)
+{
+  if (0 == end_trans(thd, end))
+  {
+      return WSREP_OK;
+  }
+  else
+  {
+      return WSREP_FATAL;
+  }
+}
+
+wsrep_status_t wsrep_commit(THD* const thd, wsrep_seqno_t const global_seqno)
+{
+#ifdef WSREP_PROC_INFO
+  snprintf(thd->wsrep_info, sizeof(thd->wsrep_info) - 1,
+           "committing %lld", (long long)thd->wsrep_trx_seqno);
+  thd_proc_info(thd, thd->wsrep_info);
+#else
+  thd_proc_info(thd, "committing");
+#endif /* WSREP_PROC_INFO */
+
+  wsrep_status_t const rcode(wsrep_apply_sql(thd, "COMMIT", 6, 0, 0));
+//  wsrep_status_t const rcode(wsrep_end_trans (thd, COMMIT));
+
+#ifdef WSREP_PROC_INFO
+  snprintf(thd->wsrep_info, sizeof(thd->wsrep_info) - 1,
+           "committed %lld", (long long)thd->wsrep_trx_seqno);
+  thd_proc_info(thd, thd->wsrep_info);
+#else
+  thd_proc_info(thd, "committed");
+#endif /* WSREP_PROC_INFO */
+
+  if (WSREP_OK == rcode)
+  {
+    // TODO: mark snapshot with global_seqno.
+  }
+
+  return rcode;
+}
+
+wsrep_status_t wsrep_rollback(THD* const thd, wsrep_seqno_t const global_seqno)
+{
+#ifdef WSREP_PROC_INFO
+  snprintf(thd->wsrep_info, sizeof(thd->wsrep_info) - 1,
+           "rolling back %lld", (long long)thd->wsrep_trx_seqno);
+  thd_proc_info(thd, thd->wsrep_info);
+#else
+  thd_proc_info(thd, "rolling back");
+#endif /* WSREP_PROC_INFO */
+
+  wsrep_status_t const rcode(wsrep_apply_sql(thd, "ROLLBACK", 8, 0, 0));
+//  wsrep_status_t const rcode(wsrep_end_trans (thd, ROLLBACK));
+
+#ifdef WSREP_PROC_INFO
+  snprintf(thd->wsrep_info, sizeof(thd->wsrep_info) - 1,
+           "rolled back %lld", (long long)thd->wsrep_trx_seqno);
+  thd_proc_info(thd, thd->wsrep_info);
+#else
+  thd_proc_info(thd, "rolled back");
+#endif /* WSREP_PROC_INFO */
+
+  return rcode;
+}
+
+wsrep_status_t wsrep_commit_cb(void*         const ctx,
+                               wsrep_seqno_t const global_seqno,
+                               bool          const commit)
+{
+  THD* const thd((THD*)ctx);
+
+  assert(global_seqno == thd->wsrep_trx_seqno);
+
+  if (commit)
+    return wsrep_commit(thd, global_seqno);
+  else
+    return wsrep_rollback(thd, global_seqno);
+}
+
+Relay_log_info* wsrep_relay_log_init(const char* log_fname)
+{
+  Relay_log_info* rli= new Relay_log_info;
+
+  rli->no_storage= true;
+  if (!rli->relay_log.description_event_for_exec)
+  {
+    rli->relay_log.description_event_for_exec=
+      new Format_description_log_event(4);
+  }
+
+  rli->sql_thd= current_thd;
+  return rli;
+}
+
+
+void wsrep_prepare_bf_thd(THD *thd, struct wsrep_thd_shadow* shadow)
+{
+  shadow->options       = thd->options;
+  shadow->wsrep_exec_mode = thd->wsrep_exec_mode;
+  shadow->vio           = thd->net.vio;
+
+  if (opt_log_slave_updates)
+    thd->options|= OPTION_BIN_LOG;
+  else
+    thd->options&= ~OPTION_BIN_LOG;
+
+  if (!thd->wsrep_rli) thd->wsrep_rli= wsrep_relay_log_init("wsrep_relay");
+
+  thd->wsrep_exec_mode= REPL_RECV;
+  thd->net.vio= 0;
+  thd->clear_error();
+
+  thd->options|= OPTION_NOT_AUTOCOMMIT;
+
+  shadow->tx_isolation        = thd->variables.tx_isolation;
+  thd->variables.tx_isolation = ISO_READ_COMMITTED;
+  thd->session_tx_isolation   = ISO_READ_COMMITTED;
+}
+
+void wsrep_return_from_bf_mode(THD *thd, struct wsrep_thd_shadow* shadow)
+{
+  thd->options                = shadow->options;
+  thd->wsrep_exec_mode        = shadow->wsrep_exec_mode;
+  thd->net.vio                = shadow->vio;
+  thd->variables.tx_isolation = shadow->tx_isolation;
+
+}
+
+void wsrep_replication_process(THD *thd)
+{
+  int rcode;
+  DBUG_ENTER("wsrep_replication_process");
+  struct wsrep_thd_shadow shadow;
+  wsrep_prepare_bf_thd(thd, &shadow);
+
+  wsrep_format_desc= new Format_description_log_event(4);
+
+  rcode = wsrep->recv(wsrep, (void *)thd);
+  DBUG_PRINT("wsrep",("wsrep_repl returned: %d", rcode));
+
+  WSREP_INFO("applier thread exiting (code:%d)", rcode);
+
+  switch (rcode) {
+  case WSREP_OK:
+  case WSREP_NOT_IMPLEMENTED:
+  case WSREP_CONN_FAIL:
+    /* provider does not support slave operations / disconnected from group,
+     * just close applier thread */
+    break;
+  case WSREP_NODE_FAIL:
+    /* data inconsistency => SST is needed */
+    /* Note: we cannot just blindly restart replication here,
+     * SST might require server restart if storage engines must be
+     * initialized after SST */
+    WSREP_ERROR("node consistency compromised, aborting");
+    wsrep_kill_mysql(thd);
+    break;
+  case WSREP_WARNING:
+  case WSREP_TRX_FAIL:
+  case WSREP_TRX_MISSING:
+    /* these suggests a bug in provider code */
+    WSREP_WARN("bad return from recv() call: %d", rcode);
+    /* fall through to node shutdown */
+  case WSREP_FATAL:
+    /* Cluster connectivity is lost.
+     *
+     * If applier was killed on purpose (KILL_CONNECTION), we
+     * avoid mysql shutdown. This is because the killer will then handle
+     * shutdown processing (or replication restarting)
+     */
+    if (thd->killed != THD::KILL_CONNECTION)
+    {
+      wsrep_kill_mysql(thd);
+    }
+    break;
+  }
+
+  if (thd->killed != THD::KILL_CONNECTION)
+  {
+    (void) pthread_mutex_lock(&LOCK_thread_count);
+    wsrep_close_applier(thd);
+    (void) pthread_cond_broadcast(&COND_thread_count);
+    (void) pthread_mutex_unlock(&LOCK_thread_count);
+  }
+  wsrep_return_from_bf_mode(thd, &shadow);
+  DBUG_VOID_RETURN;
+}
+
+void wsrep_rollback_process(THD *thd)
+{
+  DBUG_ENTER("wsrep_rollback_process");
+
+  pthread_mutex_lock(&LOCK_wsrep_rollback);
+  wsrep_aborting_thd= NULL;
+
+  while (thd->killed == THD::NOT_KILLED) {
+    thd_proc_info(thd, "wsrep aborter idle");
+    thd->mysys_var->current_mutex= &LOCK_wsrep_rollback;
+    thd->mysys_var->current_cond=  &COND_wsrep_rollback;
+
+    pthread_cond_wait(&COND_wsrep_rollback,&LOCK_wsrep_rollback);
+
+    WSREP_DEBUG("WSREP rollback thread wakes for signal");
+
+    pthread_mutex_lock(&thd->mysys_var->mutex);
+    thd_proc_info(thd, "wsrep aborter active");
+    thd->mysys_var->current_mutex= 0;
+    thd->mysys_var->current_cond=  0;
+    pthread_mutex_unlock(&thd->mysys_var->mutex);
+
+    /* check for false alarms */
+    if (!wsrep_aborting_thd)
+    {
+      WSREP_DEBUG("WSREP rollback thread has empty abort queue");
+    }
+    /* process all entries in the queue */
+    while (wsrep_aborting_thd) {
+      THD *aborting;
+      wsrep_aborting_thd_t next = wsrep_aborting_thd->next;
+      aborting = wsrep_aborting_thd->aborting_thd;
+      my_free(wsrep_aborting_thd, MYF(0));
+      wsrep_aborting_thd= next;
+      /*
+       * must release mutex, appliers my want to add more
+       * aborting thds in our work queue, while we rollback
+       */
+      pthread_mutex_unlock(&LOCK_wsrep_rollback);
+
+      pthread_mutex_lock(&aborting->LOCK_wsrep_thd);
+      if (aborting->wsrep_conflict_state== ABORTED)
+      {
+        WSREP_DEBUG("WSREP, thd already aborted: %llu state: %d", 
+                    (long long)aborting->real_id,
+                    aborting->wsrep_conflict_state);
+
+        pthread_mutex_unlock(&aborting->LOCK_wsrep_thd);
+        pthread_mutex_lock(&LOCK_wsrep_rollback);
+        continue;
+      }
+      aborting->wsrep_conflict_state= ABORTING;
+
+      pthread_mutex_unlock(&aborting->LOCK_wsrep_thd);
+
+      aborting->store_globals();
+
+      end_trans(aborting, ROLLBACK);
+
+      pthread_mutex_lock(&aborting->LOCK_wsrep_thd);
+      aborting->wsrep_conflict_state= ABORTED;
+      WSREP_DEBUG("WSREP rollbacker aborted thd: %llu",
+                  (long long)aborting->real_id);
+      pthread_mutex_unlock(&aborting->LOCK_wsrep_thd);
+      pthread_mutex_lock(&LOCK_wsrep_rollback);
+    }
+  }
+
+  pthread_mutex_unlock(&LOCK_wsrep_rollback);
+  sql_print_information("WSREP: rollbacker thread exiting");
+
+  DBUG_PRINT("wsrep",("wsrep rollbacker thread exiting"));
+  DBUG_VOID_RETURN;
+}
+extern "C"
+int wsrep_thd_is_brute_force(void *thd_ptr)
+{
+  if (thd_ptr) {
+    switch (((THD *)thd_ptr)->wsrep_exec_mode) {
+    case LOCAL_STATE:  
+    {
+      if (((THD *)thd_ptr)->wsrep_conflict_state== REPLAYING) 
+      {
+        return 1;
+      }
+      return 0;
+    }
+    case REPL_RECV:    return 1;
+    case TOTAL_ORDER:  return 2;
+    case LOCAL_COMMIT: return 3;
+    }
+  }
+  return 0;
+}
+extern "C"
+int wsrep_abort_thd(void *bf_thd_ptr, void *victim_thd_ptr, my_bool signal)
+{
+  THD *victim_thd = (THD *) victim_thd_ptr;
+  THD *bf_thd     = (THD *) bf_thd_ptr;
+  DBUG_ENTER("wsrep_abort_thd");
+
+  if (victim_thd)
+  {
+    WSREP_DEBUG("wsrep_abort_thd, by: %llu, victim: %llu", (bf_thd) ?
+                (long long)bf_thd->real_id : 0, (long long)victim_thd->real_id);
+    ha_wsrep_abort_transaction(bf_thd, victim_thd, signal);
+  }
+
+  DBUG_RETURN(1);
+}
+#endif /* WITH_WSREP */
 
 /**
   Retuns information about user or current user.

=== modified file 'sql/sql_plugin.cc'
--- old/sql/sql_plugin.cc	2011-07-03 15:47:37 +0000
+++ new/sql/sql_plugin.cc	2011-10-12 21:45:28 +0000
@@ -42,8 +42,16 @@
   { array_elements(global_plugin_typelib_names)-1,
     "", global_plugin_typelib_names, NULL };
 
-
+#ifndef WITH_WSREP
 char *opt_plugin_load= NULL;
+#else
+static const char*
+plugin_load_defaults= "innodb=ha_innodb_plugin.so;"
+                      "innodb_trx=ha_innodb_plugin.so;"
+                      "innodb_locks=ha_innodb_plugin.so;"
+                      "innodb_lock_waits=ha_innodb_plugin.so;";
+char *opt_plugin_load= const_cast<char*>(plugin_load_defaults);
+#endif
 char *opt_plugin_dir_ptr;
 char opt_plugin_dir[FN_REFLEN];
 /*
@@ -2518,10 +2526,10 @@
 {
   plugin_ref old_table_plugin= thd->variables.table_plugin;
   DBUG_ENTER("plugin_thdvar_init");
-  
+
   thd->variables.table_plugin= NULL;
   cleanup_variables(thd, &thd->variables);
-  
+
   thd->variables= global_system_variables;
   thd->variables.table_plugin= NULL;
 
@@ -2530,11 +2538,17 @@
   thd->variables.dynamic_variables_size= 0;
   thd->variables.dynamic_variables_ptr= 0;
 
-  pthread_mutex_lock(&LOCK_plugin);  
+#ifdef WITH_WSREP
+  if (!thd->wsrep_applier) {
+#endif
+  pthread_mutex_lock(&LOCK_plugin);
   thd->variables.table_plugin=
         my_intern_plugin_lock(NULL, global_system_variables.table_plugin);
   intern_plugin_unlock(NULL, old_table_plugin);
   pthread_mutex_unlock(&LOCK_plugin);
+#ifdef WITH_WSREP
+  }
+#endif
   DBUG_VOID_RETURN;
 }
 

=== modified file 'sql/sql_repl.cc'
--- old/sql/sql_repl.cc	2011-06-30 15:37:13 +0000
+++ new/sql/sql_repl.cc	2011-10-12 21:45:28 +0000
@@ -1007,8 +1007,11 @@
                  ER(ER_SLAVE_WAS_NOT_RUNNING));
   }
   unlock_slave_threads(mi);
+#ifdef WITH_WSREP
+  thd_proc_info(thd, "exit stop_slave()");
+#else /* WITH_WSREP */
   thd_proc_info(thd, 0);
-
+#endif /* WITH_WSREP */
   if (slave_errno)
   {
     if (net_report)
@@ -1392,7 +1395,11 @@
   pthread_mutex_unlock(&mi->rli.data_lock);
 
   unlock_slave_threads(mi);
+#ifdef WITH_WSREP
+  thd_proc_info(thd, "exit change_master()");
+#else /* WITH_WSREP */
   thd_proc_info(thd, 0);
+#endif /* WITH_WSREP */
   my_ok(thd);
   DBUG_RETURN(FALSE);
 }

=== modified file 'sql/sql_show.cc'
--- old/sql/sql_show.cc	2012-02-16 10:35:30 +0000
+++ new/sql/sql_show.cc	2012-04-19 19:26:55 +0000
@@ -32,6 +32,10 @@
 #include <my_dir.h>
 #include "debug_sync.h"
 
+#if !defined(MYSQL_MAX_VARIABLE_VALUE_LEN)
+#define MYSQL_MAX_VARIABLE_VALUE_LEN 1024
+#endif // !defined(MYSQL_MAX_VARIABLE_VALUE_LEN)
+
 #define STR_OR_NIL(S) ((S) ? (S) : "<nil>")
 
 #ifdef WITH_PARTITION_STORAGE_ENGINE
@@ -6735,7 +6739,8 @@
 {
   {"VARIABLE_NAME", 64, MYSQL_TYPE_STRING, 0, 0, "Variable_name",
    SKIP_OPEN_TABLE},
-  {"VARIABLE_VALUE", 1024, MYSQL_TYPE_STRING, 0, 1, "Value", SKIP_OPEN_TABLE},
+  {"VARIABLE_VALUE", MYSQL_MAX_VARIABLE_VALUE_LEN, MYSQL_TYPE_STRING, 0, 1,
+   "Value", SKIP_OPEN_TABLE},
   {0, 0, MYSQL_TYPE_STRING, 0, 0, 0, SKIP_OPEN_TABLE}
 };
 

=== modified file 'sql/sql_table.cc'
--- old/sql/sql_table.cc	2012-02-15 16:21:38 +0000
+++ new/sql/sql_table.cc	2012-04-19 19:26:55 +0000
@@ -6859,12 +6859,18 @@
       error= 0;
       break;
     }
+#ifdef WITH_WSREP
+    bool do_log_write(true);
+#endif // WITH_WSREP
     if (error == HA_ERR_WRONG_COMMAND)
     {
       error= 0;
       push_warning_printf(thd, MYSQL_ERROR::WARN_LEVEL_NOTE,
 			  ER_ILLEGAL_HA, ER(ER_ILLEGAL_HA),
 			  table->alias);
+#ifdef WITH_WSREP
+      do_log_write= false;
+#endif // WITH_WSREP
     }
 
     /*
@@ -6929,11 +6935,20 @@
       push_warning_printf(thd, MYSQL_ERROR::WARN_LEVEL_NOTE,
 			  ER_ILLEGAL_HA, ER(ER_ILLEGAL_HA),
 			  table->alias);
+#ifdef WITH_WSREP
+      do_log_write= false;
+#endif // WITH_WSREP
     }
 
     if (!error)
     {
+#ifdef WITH_WSREP
+      if (do_log_write) {
+#endif // WITH_WSREP
       error= write_bin_log(thd, TRUE, thd->query(), thd->query_length());
+#ifdef WITH_WSREP
+      }
+#endif // !WITH_WSREP
       if (!error)
         my_ok(thd);
     }

=== modified file 'sql/sql_update.cc'
--- old/sql/sql_update.cc	2011-06-30 15:37:13 +0000
+++ new/sql/sql_update.cc	2011-10-12 21:45:28 +0000
@@ -857,7 +857,11 @@
   */
   if ((error < 0) || thd->transaction.stmt.modified_non_trans_table)
   {
+#ifdef WITH_WSREP
+    if (wsrep_emulate_bin_log || mysql_bin_log.is_open())
+#else
     if (mysql_bin_log.is_open())
+#endif
     {
       int errcode= 0;
       if (error < 0)
@@ -1912,7 +1916,11 @@
       The query has to binlog because there's a modified non-transactional table
       either from the query's list or via a stored routine: bug#13270,23333
     */
+#ifdef WITH_WSREP
+    if (wsrep_emulate_bin_log || mysql_bin_log.is_open())
+#else
     if (mysql_bin_log.is_open())
+#endif
     {
       /*
         THD::killed status might not have been set ON at time of an error
@@ -2141,7 +2149,11 @@
               thd->transaction.stmt.modified_non_trans_table);
   if (local_error == 0 || thd->transaction.stmt.modified_non_trans_table)
   {
+#ifdef WITH_WSREP
+    if (wsrep_emulate_bin_log || mysql_bin_log.is_open())
+#else
     if (mysql_bin_log.is_open())
+#endif
     {
       int errcode= 0;
       if (local_error == 0)

=== added file 'sql/wsrep_check_opts.cc'
--- old/sql/wsrep_check_opts.cc	1970-01-01 00:00:00 +0000
+++ new/sql/wsrep_check_opts.cc	2012-01-21 19:48:04 +0000
@@ -0,0 +1,387 @@
+/* Copyright 2011 Codership Oy <http://www.codership.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+#include "wsrep_mysqld.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+
+/* This file is about checking for correctness of mysql configuration options */
+
+struct opt
+{
+    const char* const name;
+    const char*       value;
+};
+
+/* A list of options to check.
+ * At first we assume default values and then see if they are changed on CLI or
+ * in my.cnf */
+static struct opt opts[] =
+{
+    { "wsrep_slave_threads",     "1" }, // mysqld.cc
+    { "bind_address",      "0.0.0.0" }, // mysqld.cc
+    { "wsrep_sst_method","mysqldump" }, // mysqld.cc
+    { "wsrep_sst_receive_address","AUTO"}, // mysqld.cc
+    { "binlog_format",         "ROW" }, // mysqld.cc
+    { "wsrep_provider",       "none" }, // mysqld.cc
+    { "query_cache_type",        "0" }, // mysqld.cc
+    { "query_cache_size",        "0" }, // mysqld.cc
+    { "locked_in_memory",        "0" }, // mysqld.cc
+    { "wsrep_cluster_address",   "0" }, // mysqld.cc
+    { "locks_unsafe_for_binlog", "0" }, // ha_innodb.cc
+    { "autoinc_lock_mode",       "1" }, // ha_innodb.cc
+    { 0, 0 }
+};
+
+enum
+{
+    WSREP_SLAVE_THREADS,
+    BIND_ADDRESS,
+    WSREP_SST_METHOD,
+    WSREP_SST_RECEIVE_ADDRESS,
+    BINLOG_FORMAT,
+    WSREP_PROVIDER,
+    QUERY_CACHE_TYPE,
+    QUERY_CACHE_SIZE,
+    LOCKED_IN_MEMORY,
+    WSREP_CLUSTER_ADDRESS,
+    LOCKS_UNSAFE_FOR_BINLOG,
+    AUTOINC_LOCK_MODE
+};
+
+
+/* A class to make a copy of argv[] vector */
+struct argv_copy
+{
+    int    const argc_;
+    char**       argv_;
+
+    argv_copy (int const argc, const char* const argv[]) :
+        argc_ (argc),
+        argv_ (reinterpret_cast<char**>(calloc(argc_, sizeof(char*))))
+    {
+        if (argv_)
+        {
+            for (int i = 0; i < argc_; ++i)
+            {
+                argv_[i] = strdup(argv[i]);
+
+                if (!argv_[i])
+                {
+                    argv_free (); // free whatever bee allocated
+                    return;
+                }
+            }
+        }
+    }
+
+    ~argv_copy () { argv_free (); }
+
+private:
+    argv_copy (const argv_copy&);
+    argv_copy& operator= (const argv_copy&);
+
+    void argv_free()
+    {
+        if (argv_)
+        {
+            for (int i = 0; (i < argc_) && argv_[i] ; ++i) free (argv_[i]);
+            free (argv_);
+            argv_ = 0;
+        }
+    }
+};
+
+/* a short corresponding to '--' byte sequence */
+static short const long_opt_prefix ('-' + ('-' << 8));
+
+/* Normalizes long options to have '_' instead of '-' */
+static int
+normalize_opts (argv_copy& a)
+{
+    if (a.argv_)
+    {
+        for (int i = 0; i < a.argc_; ++i)
+        {
+            char* ptr = a.argv_[i];
+            if (long_opt_prefix == *(short*)ptr) // long option
+            {
+                ptr += 2;
+                const char* end = strchr(ptr, '=');
+
+                if (!end) end = ptr + strlen(ptr);
+
+                for (; ptr != end; ++ptr) if ('-' == *ptr) *ptr = '_';
+            }
+        }
+
+        return 0;
+    }
+
+    return EINVAL;
+}
+
+/* Find required options in the argument list and change their values */
+static int
+find_opts (argv_copy& a, struct opt* const opts)
+{
+    for (int i = 0; i < a.argc_; ++i)
+    {
+        char* ptr = a.argv_[i] + 2; // we're interested only in long options
+
+        struct opt* opt = opts;
+        for (; 0 != opt->name; ++opt)
+        {
+            if (!strstr(ptr, opt->name)) continue; // try next option
+
+            /* 1. try to find value after the '=' */
+            opt->value = strchr(ptr, '=') + 1;
+
+            /* 2. if no '=', try next element in the argument vector */
+            if (reinterpret_cast<void*>(1) == opt->value)
+            {
+                /* also check that the next element is not an option itself */
+                if (i + 1 < a.argc_ && *(a.argv_[i + 1]) != '-')
+                {
+                    ++i;
+                    opt->value = a.argv_[i];
+                }
+                else opt->value = ""; // no value supplied (like boolean opt)
+            }
+
+            break; // option found, break inner loop
+        }
+    }
+
+    return 0;
+}
+
+/* Parses string for an integer. Returns 0 on success. */
+int get_long_long (const struct opt& opt, long long* const val, int const base)
+{
+    const char* const str = opt.value;
+
+    if ('\0' != *str)
+    {
+        char* endptr;
+
+        *val = strtoll (str, &endptr, base);
+
+        if ('k' == *endptr || 'K' == *endptr) 
+        { 
+            *val *= 1024L;
+            endptr++;
+        } 
+        else if ('m' == *endptr || 'M' == *endptr) 
+        {
+            *val *= 1024L * 1024L;
+            endptr++;
+        }
+        else if ('g' == *endptr || 'G' == *endptr) 
+        {
+            *val *= 1024L * 1024L * 1024L;
+            endptr++;
+        }
+
+        if ('\0' == *endptr) return 0; // the whole string was a valid integer
+    }
+
+    WSREP_ERROR ("Bad value for *%s: '%s'. Should be integer.",
+                 opt.name, opt.value);
+
+    return EINVAL;
+}
+
+/* This is flimzy coz hell knows how mysql interprets boolean strings...
+ * and, no, I'm not going to become versed in how mysql handles options -
+ * I'd rather sing.
+
+ Aha, http://dev.mysql.com/doc/refman/5.1/en/dynamic-system-variables.html:
+ Variables that have a type of boolean can be set to 0, 1, ON or OFF. (If you
+ set them on the command line or in an option file, use the numeric values.)
+
+ So it is '0' for FALSE, '1' or empty string for TRUE
+
+ */
+int get_bool (const struct opt& opt, bool* const val)
+{
+    const char* str = opt.value;
+
+    while (isspace(*str)) ++str; // skip initial whitespaces
+
+    ssize_t str_len = strlen(str);
+    switch (str_len)
+    {
+    case 0:
+        *val = true;
+        return 0;
+    case 1:
+        if ('0' == *str || '1' == *str)
+        {
+            *val = ('1' == *str);
+            return 0;
+        }
+    }
+
+    WSREP_ERROR ("Bad value for *%s: '%s'. Should be '0', '1' or empty string.",
+                 opt.name, opt.value);
+
+    return EINVAL;
+}
+
+static int
+check_opts (int const argc, const char* const argv[], struct opt opts[])
+{
+    /* First, make a copy of argv to be able to manipulate it */
+    argv_copy a(argc, argv);
+
+    if (!a.argv_)
+    {
+        WSREP_ERROR ("Could not copy argv vector: not enough memory.");
+        return ENOMEM;
+    }
+
+    int err = normalize_opts (a);
+    if (err)
+    {
+        WSREP_ERROR ("Failed to normalize options.");
+        return err;
+    }
+
+    err = find_opts (a, opts);
+    if (err)
+    {
+        WSREP_ERROR ("Failed to parse options.");
+        return err;
+    }
+
+    /* At this point we have updated default values in our option list to
+       what has been specified on the command line / my.cnf */
+
+    long long slave_threads;
+    err = get_long_long (opts[WSREP_SLAVE_THREADS], &slave_threads, 10);
+    if (err) return err;
+
+    int rcode = 0;
+
+    if (slave_threads > 1)
+        /* Need to check AUTOINC_LOCK_MODE and LOCKS_UNSAFE_FOR_BINLOG */
+    {
+        long long autoinc_lock_mode;
+        err = get_long_long (opts[AUTOINC_LOCK_MODE], &autoinc_lock_mode, 10);
+        if (err) return err;
+
+        bool locks_unsafe_for_binlog;
+        err = get_bool (opts[LOCKS_UNSAFE_FOR_BINLOG],&locks_unsafe_for_binlog);
+        if (err) return err;
+
+        if (autoinc_lock_mode != 2)
+        {
+            WSREP_ERROR ("Parallel applying (wsrep_slave_threads > 1) requires"
+                         " innodb_autoinc_lock_mode = 2.");
+            rcode = EINVAL;
+        }
+    }
+
+    long long query_cache_size, query_cache_type;
+    if ((err = get_long_long (opts[QUERY_CACHE_SIZE], &query_cache_size, 10)))
+        return err;
+    if ((err = get_long_long (opts[QUERY_CACHE_TYPE], &query_cache_type, 10)))
+        return err;
+
+    if (0 != query_cache_size && 0 != query_cache_type)
+    {
+        WSREP_ERROR ("Query cache is not supported (size=%lld type=%lld)",
+                     query_cache_size, query_cache_type);
+        rcode = EINVAL;
+    }
+
+    bool locked_in_memory;
+    err = get_bool (opts[LOCKED_IN_MEMORY], &locked_in_memory);
+    if (err) { WSREP_ERROR("get_bool error: %s", strerror(err)); return err; }
+    if (locked_in_memory)
+    {
+        WSREP_ERROR ("Memory locking is not supported (locked_in_memory=%s)",
+                     locked_in_memory ? "ON" : "OFF");
+        rcode = EINVAL;
+    }
+
+    if (!strcasecmp(opts[WSREP_SST_METHOD].value,"mysqldump"))
+    {
+        if (!strcasecmp(opts[BIND_ADDRESS].value, "127.0.0.1") ||
+            !strcasecmp(opts[BIND_ADDRESS].value, "localhost"))
+        {
+            WSREP_ERROR ("wsrep_sst_method is set to 'mysqldump' yet "
+                         "mysqld bind_address is set to '%s', which makes it "
+                         "impossible to receive state transfer from another "
+                         "node, since mysqld won't accept such connections. "
+                         "If you wish to use mysqldump state transfer method, "
+                         "set bind_address to allow mysql client connections "
+                         "from other cluster members (e.g. 0.0.0.0).",
+                         opts[BIND_ADDRESS].value);
+            rcode = EINVAL;
+        }
+    }
+    else
+    {
+        // non-mysqldump SST requires wsrep_cluster_address on startup
+        if (strlen(opts[WSREP_CLUSTER_ADDRESS].value) == 0)
+        {
+            WSREP_ERROR ("%s SST method requires wsrep_cluster_address to be "
+                         "configured on startup.",opts[WSREP_SST_METHOD].value);
+            rcode = EINVAL;
+        }
+    }
+
+    if (strcasecmp(opts[WSREP_SST_RECEIVE_ADDRESS].value, "AUTO"))
+    {
+        if (!strncasecmp(opts[WSREP_SST_RECEIVE_ADDRESS].value,
+                         "127.0.0.1", strlen("127.0.0.1"))       ||
+            !strncasecmp(opts[WSREP_SST_RECEIVE_ADDRESS].value,
+                         "localhost", strlen("localhost")))
+        {
+            WSREP_WARN  ("wsrep_sst_receive_address is set to '%s' which "
+                         "makes it impossible for another host to reach this "
+                         "one. Please set it to the address which this node "
+                         "can be connected at by other cluster members.",
+                         opts[WSREP_SST_RECEIVE_ADDRESS].value);
+//            rcode = EINVAL;
+        }
+    }
+
+    if (strcasecmp(opts[WSREP_PROVIDER].value, "none"))
+    {
+        if (strcasecmp(opts[BINLOG_FORMAT].value, "ROW"))
+        {
+            WSREP_ERROR ("Only binlog_format = 'ROW' is currently supported. "
+                         "Configured value: '%s'. Please adjust your "
+                         "configuration.", opts[BINLOG_FORMAT].value);
+
+            rcode = EINVAL;
+        }
+    }
+
+    return rcode;
+}
+
+int
+wsrep_check_opts (int const argc, char* const* const argv)
+{
+    return check_opts (argc, argv, opts);
+}
+

=== added file 'sql/wsrep_hton.cc'
--- old/sql/wsrep_hton.cc	1970-01-01 00:00:00 +0000
+++ new/sql/wsrep_hton.cc	2012-05-04 07:24:05 +0000
@@ -0,0 +1,366 @@
+/* Copyright 2008 Codership Oy <http://www.codership.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+#include "wsrep_mysqld.h"
+#include "wsrep_priv.h"
+#include <cstdio>
+#include <cstdlib>
+
+extern handlerton *binlog_hton;
+extern int binlog_close_connection(handlerton *hton, THD *thd);
+extern ulonglong thd_to_trx_id(THD *thd);
+
+extern "C" int thd_binlog_format(const MYSQL_THD thd); 
+// todo: share interface with ha_innodb.c 
+
+enum wsrep_trx_status wsrep_run_wsrep_commit(THD *thd, handlerton *hton, bool all);
+
+/*
+  a post-commit cleanup on behalf of wsrep. Can't be a part of hton struct.
+  Is called by THD::transactions.cleanup()
+*/
+void wsrep_cleanup_transaction(THD *thd)
+{
+  if (thd->wsrep_exec_mode == LOCAL_COMMIT)
+  {
+    if (thd->variables.wsrep_on &&
+        thd->wsrep_conflict_state != MUST_REPLAY &&
+        thd->wsrep_seqno_changed)
+    {
+      if (wsrep->post_commit(wsrep, &thd->wsrep_trx_handle))
+      {
+        DBUG_PRINT("wsrep", ("set committed fail"));
+        WSREP_WARN("set committed fail: %llu %d", 
+                   (long long)thd->real_id, thd->main_da.status());
+      }
+      thd_binlog_trx_reset(thd);
+      thd->wsrep_seqno_changed = false;
+    }
+    thd->wsrep_exec_mode= LOCAL_STATE;
+  }
+}
+
+/*
+  wsrep hton
+*/
+handlerton *wsrep_hton;
+
+/*
+  wsrep exploits binlog's caches even if binlogging itself is not 
+  activated. In such case connection close needs calling
+  actual binlog's method.
+  Todo: split binlog hton from its caches to use ones by wsrep
+  without referring to binlog's stuff.
+*/
+static int
+wsrep_close_connection(handlerton*  hton, THD* thd)
+{
+  DBUG_ENTER("wsrep_close_connection");
+  if (thd_get_ha_data(thd, binlog_hton) != NULL)
+		binlog_hton->close_connection (binlog_hton, thd);
+  DBUG_RETURN(0);
+} 
+
+/*
+  prepare/wsrep_run_wsrep_commit can fail in two ways
+  - certification test or an equivalent. As a result,
+    the current transaction just rolls back
+    Error codes:
+           WSREP_TRX_ROLLBACK, WSREP_TRX_ERROR
+  - a post-certification failure makes this server unable to
+    commit its own WS and therefore the server must abort
+*/
+static int wsrep_prepare(handlerton *hton, THD *thd, bool all)
+{
+#ifndef DBUG_OFF
+  wsrep_seqno_t old = thd->wsrep_trx_seqno;
+#endif
+  DBUG_ENTER("wsrep_prepare");
+  if ((all || 
+      !thd_test_options(thd, OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN)) &&
+      (thd->variables.wsrep_on && !wsrep_trans_cache_is_empty(thd)))
+  {
+    switch (wsrep_run_wsrep_commit(thd, hton, all))
+    {
+    case WSREP_TRX_OK:
+      DBUG_ASSERT(thd->wsrep_trx_seqno > old || thd->wsrep_exec_mode == REPL_RECV);
+      break;
+    case WSREP_TRX_ROLLBACK:
+    case WSREP_TRX_ERROR:
+      DBUG_RETURN(1);
+    }
+  }
+  DBUG_RETURN(0);
+}
+
+static int wsrep_savepoint_set(handlerton *hton, THD *thd,  void *sv)
+{
+  return 0;
+}
+static int wsrep_savepoint_rollback(handlerton *hton, THD *thd, void *sv)
+{
+  return 0;
+}
+
+static int wsrep_rollback(handlerton *hton, THD *thd, bool all)
+{
+  DBUG_ENTER("wsrep_rollback");
+  pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+  if ((all || !thd_test_options(thd, OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN)) &&
+      (thd->variables.wsrep_on && thd->wsrep_conflict_state != MUST_REPLAY))
+  {
+    if (wsrep->post_rollback(wsrep, &thd->wsrep_trx_handle))
+    {
+      DBUG_PRINT("wsrep", ("setting rollback fail"));
+      WSREP_ERROR("settting rollback fail: thd: %llu SQL: %s", 
+		  (long long)thd->real_id, thd->query());
+    }
+  }
+ 
+  int rcode = 0;
+  if (!wsrep_emulate_bin_log) 
+  {
+    if (all) thd_binlog_trx_reset(thd);
+  }
+
+  pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+  DBUG_RETURN(rcode);
+}
+
+int wsrep_commit(handlerton *hton, THD *thd, bool all)
+{
+  DBUG_ENTER("wsrep_commit");
+  
+  DBUG_RETURN(0);
+}
+
+enum wsrep_trx_status
+wsrep_run_wsrep_commit(
+    THD *thd, handlerton *hton, bool all)
+{
+  int rcode         = -1;
+  uint data_len     = 0;
+  uchar *rbr_data   = NULL;
+  IO_CACHE *cache;
+
+  if (thd->main_da.is_error()) {
+    WSREP_ERROR("commit issue, error: %d %s", thd->main_da.sql_errno(), thd->main_da.message());
+  }
+
+  DBUG_ENTER("wsrep_run_wsrep_commit");
+  if (thd->wsrep_exec_mode == REPL_RECV) {
+
+    pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+    if (thd->wsrep_conflict_state == MUST_ABORT) {
+      if (wsrep_debug)
+	WSREP_INFO("WSREP: must abort for BF");
+      DBUG_PRINT("wsrep", ("BF apply commit fail"));
+      thd->wsrep_conflict_state = NO_CONFLICT;
+      pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+      //
+      // TODO: test all calls of the rollback.
+      // rollback must happen automagically innobase_rollback(hton, thd, 1);
+      //
+      DBUG_RETURN(WSREP_TRX_ERROR);
+    }
+    pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+  }
+  if (thd->wsrep_exec_mode != LOCAL_STATE) {
+    DBUG_RETURN(WSREP_TRX_OK);
+  }
+
+  DBUG_PRINT("wsrep", ("replicating commit"));
+
+  pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+  if (thd->wsrep_conflict_state == MUST_ABORT) {
+    DBUG_PRINT("wsrep", ("replicate commit fail"));
+    thd->wsrep_conflict_state = ABORTED;
+    pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+    if (wsrep_debug) {
+      WSREP_INFO("innobase_commit, abort %s",
+		 (thd->query()) ? thd->query() : "void");
+    }
+    DBUG_RETURN(WSREP_TRX_ROLLBACK);
+  }
+
+  pthread_mutex_lock(&LOCK_wsrep_replaying);
+
+  while (wsrep_replaying > 0                       && 
+         thd->wsrep_conflict_state == NO_CONFLICT  &&
+         thd->killed == THD::NOT_KILLED            &&
+         !shutdown_in_progress) {
+
+    pthread_mutex_unlock(&LOCK_wsrep_replaying);
+    pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+
+    pthread_mutex_lock(&thd->mysys_var->mutex);
+    thd_proc_info(thd, "wsrep waiting on replaying");
+    thd->mysys_var->current_mutex= &LOCK_wsrep_replaying;
+    thd->mysys_var->current_cond=  &COND_wsrep_replaying;
+    pthread_mutex_unlock(&thd->mysys_var->mutex);
+
+    pthread_mutex_lock(&LOCK_wsrep_replaying);
+    // Using timedwait is a hack to avoid deadlock in case if BF victim
+    // misses the signal.
+    struct timespec wtime = {0, 1000000};
+    pthread_cond_timedwait(&COND_wsrep_replaying, &LOCK_wsrep_replaying,
+                           &wtime);
+    WSREP_DEBUG("commit waiting for replaying: %d, thd: (%lu) conflict: %d", 
+		wsrep_replaying, thd->thread_id, thd->wsrep_conflict_state);
+
+    pthread_mutex_unlock(&LOCK_wsrep_replaying);
+
+    pthread_mutex_lock(&thd->mysys_var->mutex);
+    thd->mysys_var->current_mutex= 0;
+    thd->mysys_var->current_cond=  0;
+    pthread_mutex_unlock(&thd->mysys_var->mutex);
+
+    pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+    pthread_mutex_lock(&LOCK_wsrep_replaying);
+  }
+  pthread_mutex_unlock(&LOCK_wsrep_replaying);
+
+  if (thd->wsrep_conflict_state == MUST_ABORT) {
+    DBUG_PRINT("wsrep", ("replicate commit fail"));
+    thd->wsrep_conflict_state = ABORTED;
+    pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+    if (wsrep_debug) {
+      WSREP_DEBUG("innobase_commit abort after replaying wait %s",
+                  (thd->query()) ? thd->query() : "void");
+    }
+    DBUG_RETURN(WSREP_TRX_ROLLBACK);
+  }
+  thd->wsrep_query_state = QUERY_COMMITTING;
+  pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+
+  cache = get_trans_log(thd);
+  rcode = 0;
+  if (cache) {
+    thd->binlog_flush_pending_rows_event(true);
+    rcode = wsrep_write_cache(cache, &rbr_data, &data_len);
+    if (rcode) {
+      WSREP_ERROR("rbr write fail, data_len: %d, %d", data_len, rcode);
+      if (data_len) my_free(rbr_data, MYF(0));
+      DBUG_RETURN(WSREP_TRX_ROLLBACK);
+    }
+  }
+  if (!rcode) {
+    rcode = wsrep->pre_commit(
+                              wsrep,
+                              (wsrep_conn_id_t)thd->thread_id,
+                              &thd->wsrep_trx_handle,
+                              rbr_data,
+                              data_len,
+                              (thd->wsrep_PA_safe) ? WSREP_FLAG_PA_SAFE : 0ULL,
+                              &thd->wsrep_trx_seqno);
+    if (rcode == WSREP_TRX_MISSING) {
+      rcode = WSREP_OK;
+    } else if (rcode == WSREP_BF_ABORT) {
+      pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+      thd->wsrep_conflict_state = MUST_REPLAY;
+      pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+      pthread_mutex_lock(&LOCK_wsrep_replaying);
+      wsrep_replaying++;
+      WSREP_DEBUG("replaying increased: %d, thd: %lu",
+                  wsrep_replaying, thd->thread_id);
+      pthread_mutex_unlock(&LOCK_wsrep_replaying);
+    }
+    thd->wsrep_seqno_changed = true;
+  } else {
+    WSREP_ERROR("I/O error reading from thd's binlog iocache: "
+                "errno=%d, io cache code=%d", my_errno, cache->error);
+    if (data_len) my_free(rbr_data, MYF(0));
+    DBUG_ASSERT(0); // failure like this can not normally happen
+    DBUG_RETURN(WSREP_TRX_ERROR);
+  }
+
+  if (data_len) {
+    my_free(rbr_data, MYF(0));
+  }
+
+  switch(rcode) {
+  case 0:
+    thd->wsrep_exec_mode = LOCAL_COMMIT;
+    DBUG_PRINT("wsrep", ("replicating commit success"));
+    break;
+  case WSREP_TRX_FAIL:
+  case WSREP_BF_ABORT:
+    WSREP_DEBUG("commit failed for reason: %d, seqno: %lld",
+                rcode, (long long)thd->wsrep_trx_seqno);
+    DBUG_PRINT("wsrep", ("replicating commit fail"));
+
+    pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+    thd->wsrep_query_state= QUERY_EXEC;
+
+    if (thd->wsrep_conflict_state == MUST_ABORT) {
+      thd->wsrep_conflict_state= ABORTED;
+    }
+    pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+
+    DBUG_RETURN(WSREP_TRX_ROLLBACK);
+
+  case WSREP_CONN_FAIL:
+    WSREP_ERROR("connection failure");
+    DBUG_RETURN(WSREP_TRX_ERROR);
+  default:
+    WSREP_ERROR("unknown connection failure");
+    DBUG_RETURN(WSREP_TRX_ERROR);
+  }
+  pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+  thd->wsrep_query_state= QUERY_EXEC;
+  pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+
+  DBUG_RETURN(WSREP_TRX_OK);
+}
+
+
+static int wsrep_hton_init(void *p)
+{
+  wsrep_hton= (handlerton *)p;
+  wsrep_hton->state=opt_bin_log ? SHOW_OPTION_YES : SHOW_OPTION_NO;
+  wsrep_hton->db_type=DB_TYPE_WSREP;
+  wsrep_hton->savepoint_offset= sizeof(my_off_t);
+  wsrep_hton->close_connection= wsrep_close_connection;
+  wsrep_hton->savepoint_set= wsrep_savepoint_set;
+  wsrep_hton->savepoint_rollback= wsrep_savepoint_rollback;
+  wsrep_hton->commit= wsrep_commit;
+  wsrep_hton->rollback= wsrep_rollback;
+  wsrep_hton->prepare= wsrep_prepare;
+  wsrep_hton->flags= HTON_NOT_USER_SELECTABLE | HTON_HIDDEN; // todo: fix flags
+  return 0;
+}
+
+
+
+struct st_mysql_storage_engine wsrep_storage_engine=
+{ MYSQL_HANDLERTON_INTERFACE_VERSION };
+
+
+mysql_declare_plugin(wsrep)
+{
+  MYSQL_STORAGE_ENGINE_PLUGIN,
+  &wsrep_storage_engine,
+  "wsrep",
+  "Codership Oy",
+  "A pseudo storage engine to represent transactions in multi-master synchornous replication",
+  PLUGIN_LICENSE_GPL,
+  wsrep_hton_init, /* Plugin Init */
+  NULL, /* Plugin Deinit */
+  0x0100 /* 1.0 */,
+  NULL,                       /* status variables                */
+  NULL,                       /* system variables                */
+  NULL                        /* config options                  */
+}
+mysql_declare_plugin_end;

=== added file 'sql/wsrep_mysqld.cc'
--- old/sql/wsrep_mysqld.cc	1970-01-01 00:00:00 +0000
+++ new/sql/wsrep_mysqld.cc	2012-05-04 07:10:04 +0000
@@ -0,0 +1,648 @@
+/* Copyright 2008 Codership Oy <http://www.codership.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+#undef SAFE_MUTEX
+#include "wsrep_priv.h"
+#include <cstdio>
+#include <cstdlib>
+
+wsrep_t *wsrep                  = NULL;
+my_bool wsrep_emulate_bin_log   = FALSE; // activating parts of binlog interface
+
+/*
+ * Begin configuration options and their default values
+ */
+
+const char* wsrep_data_home_dir = NULL;
+
+#define WSREP_NODE_INCOMING_AUTO "AUTO"
+const char* wsrep_node_incoming_address = WSREP_NODE_INCOMING_AUTO;
+const char* wsrep_dbug_option   = "";
+
+long    wsrep_slave_threads            = 1; // # of slave action appliers wanted
+my_bool wsrep_debug                    = 0; // enable debug level logging
+my_bool wsrep_convert_LOCK_to_trx      = 1; // convert locking sessions to trx
+ulong   wsrep_retry_autocommit         = 5; // retry aborted autocommit trx
+my_bool wsrep_auto_increment_control   = 1; // control auto increment variables
+my_bool wsrep_drupal_282555_workaround = 1; // retry autoinc insert after dupkey
+my_bool wsrep_incremental_data_collection = 0; // incremental data collection
+long long wsrep_max_ws_size            = 1073741824LL; //max ws (RBR buffer) size
+long    wsrep_max_ws_rows              = 65536; // max number of rows in ws
+int     wsrep_to_isolation             = 0; // # of active TO isolation threads
+my_bool wsrep_certify_nonPK            = 1; // certify, even when no primary key
+long    wsrep_max_protocol_version     = 1; // maximum protocol version to use
+
+
+/*
+ * End configuration options
+ */
+
+static wsrep_uuid_t cluster_uuid = WSREP_UUID_UNDEFINED;
+static char         cluster_uuid_str[40]= { 0, };
+static const char*  cluster_status_str[WSREP_VIEW_MAX] =
+{
+    "Primary",
+    "non-Primary",
+    "Disconnected"
+};
+
+static char provider_name[256]= { 0, };
+static char provider_version[256]= { 0, };
+static char provider_vendor[256]= { 0, };
+
+/*
+ * wsrep status variables
+ */
+my_bool     wsrep_connected          = FALSE;
+my_bool     wsrep_ready              = FALSE; // node can accept queries
+const char* wsrep_cluster_state_uuid = cluster_uuid_str;
+long long   wsrep_cluster_conf_id    = WSREP_SEQNO_UNDEFINED;
+const char* wsrep_cluster_status = cluster_status_str[WSREP_VIEW_DISCONNECTED];
+long        wsrep_cluster_size       = 0;
+long        wsrep_local_index        = -1;
+const char* wsrep_provider_name      = provider_name;
+const char* wsrep_provider_version   = provider_version;
+const char* wsrep_provider_vendor    = provider_vendor;
+/* End wsrep status variables */
+
+
+wsrep_uuid_t     local_uuid   = WSREP_UUID_UNDEFINED;
+wsrep_seqno_t    local_seqno  = WSREP_SEQNO_UNDEFINED;
+wsp::node_status local_status;
+long             wsrep_protocol_version = 1;
+
+// action execute callback
+extern wsrep_status_t wsrep_apply_cb(void *ctx,
+                                     const void* buf, size_t buf_len,
+                                     wsrep_seqno_t global_seqno);
+
+extern wsrep_status_t wsrep_commit_cb  (void *ctx,
+                                        wsrep_seqno_t global_seqno,
+                                        bool commit);
+
+static void wsrep_log_cb(wsrep_log_level_t level, const char *msg) {
+  switch (level) {
+  case WSREP_LOG_INFO:
+    sql_print_information("WSREP: %s", msg);
+    break;
+  case WSREP_LOG_WARN:
+    sql_print_warning("WSREP: %s", msg);
+    break;
+  case WSREP_LOG_ERROR:
+  case WSREP_LOG_FATAL:
+    sql_print_error("WSREP: %s", msg);
+    break;
+  case WSREP_LOG_DEBUG:
+    if (wsrep_debug) sql_print_information ("[Debug] WSREP: %s", msg);
+  default:
+    break;
+  }
+}
+
+static void wsrep_log_states (wsrep_log_level_t level,
+                              wsrep_uuid_t* group_uuid,
+                              wsrep_seqno_t group_seqno,
+                              wsrep_uuid_t* node_uuid,
+                              wsrep_seqno_t node_seqno)
+{
+  char uuid_str[37];
+  char msg[256];
+
+  wsrep_uuid_print (group_uuid, uuid_str, sizeof(uuid_str));
+  snprintf (msg, 255, "WSREP: Group state: %s:%lld",
+            uuid_str, (long long)group_seqno);
+  wsrep_log_cb (level, msg);
+
+  wsrep_uuid_print (node_uuid, uuid_str, sizeof(uuid_str));
+  snprintf (msg, 255, "WSREP: Local state: %s:%lld",
+            uuid_str, (long long)node_seqno);
+  wsrep_log_cb (level, msg);
+}
+
+static void wsrep_view_handler_cb (void* app_ctx,
+                                   void* recv_ctx,
+                                   const wsrep_view_info_t* view,
+                                   const char* state,
+                                   size_t state_len,
+                                   void** sst_req,
+                                   ssize_t* sst_req_len)
+{
+  wsrep_member_status_t new_status= local_status.get();
+
+  if (memcmp(&cluster_uuid, &view->uuid, sizeof(wsrep_uuid_t)))
+  {
+    cluster_uuid= view->uuid;
+    wsrep_uuid_print (&cluster_uuid, cluster_uuid_str,
+                      sizeof(cluster_uuid_str));
+  }
+
+  wsrep_cluster_conf_id= view->view;
+  wsrep_cluster_status= cluster_status_str[view->status];
+  wsrep_cluster_size= view->memb_num;
+  wsrep_local_index= view->my_idx;
+
+  WSREP_INFO("New cluster view: global state: %s:%lld, view# %lld: %s, "
+             "number of nodes: %ld, my index: %ld, protocol version %d",
+             wsrep_cluster_state_uuid, (long long)view->seqno,
+             (long long)wsrep_cluster_conf_id, wsrep_cluster_status,
+             wsrep_cluster_size, wsrep_local_index, view->proto_ver);
+
+  /* Proceed further only if view is PRIMARY */
+  if (WSREP_VIEW_PRIMARY != view->status) {
+    wsrep_ready= FALSE;
+    new_status= WSREP_MEMBER_UNDEFINED;
+    /* Always record local_uuid and local_seqno in non-prim since this
+     * may lead to re-initializing provider and start position is
+     * determined according to these variables */
+    // WRONG! local_uuid should be the last primary configuration uuid we were
+    // a member of. local_seqno should be updated in commit calls.
+    // local_uuid= cluster_uuid;
+    // local_seqno= view->first - 1;
+    goto out;
+  }
+
+  switch (view->proto_ver)
+  {
+  case 0:
+  case 1:
+      // version change
+      if (view->proto_ver != wsrep_protocol_version)
+      {
+          my_bool wsrep_ready_saved= wsrep_ready;
+          wsrep_ready= FALSE;
+          WSREP_INFO("closing client connections for "
+                     "protocol change %ld -> %d",
+                     wsrep_protocol_version, view->proto_ver);
+          wsrep_close_client_connections(TRUE);
+          wsrep_protocol_version= view->proto_ver;
+          wsrep_ready= wsrep_ready_saved;
+      }
+      break;
+  default:
+      WSREP_ERROR("Unsupported application protocol version: %d",
+                  view->proto_ver);
+      unireg_abort(1);
+  }
+
+  if (view->state_gap)
+  {
+    WSREP_WARN("Gap in state sequence. Need state transfer.");
+
+    /* After that wsrep will call wsrep_sst_prepare. */
+    /* keep ready flag 0 until we receive the snapshot */
+    wsrep_ready= FALSE;
+
+    /* Close client connections to ensure that they don't interfere
+     * with SST */
+    WSREP_DEBUG("[debug]: closing client connections for PRIM");
+    wsrep_close_client_connections(TRUE);
+
+    *sst_req_len= wsrep_sst_prepare (sst_req);
+
+    if (*sst_req_len < 0)
+    {
+      int err = *sst_req_len;
+      WSREP_ERROR("SST preparation failed: %d (%s)", -err, strerror(-err));
+      new_status= WSREP_MEMBER_UNDEFINED;
+    }
+    else
+    {
+      new_status= WSREP_MEMBER_JOINER;
+    }
+  }
+  else
+  {
+    /*
+     *  NOTE: Initialize wsrep_group_uuid here only if it wasn't initialized
+     *  before - OR - it was reinitilized on startup (lp:992840)
+     */
+    if (!memcmp (&local_uuid, &WSREP_UUID_UNDEFINED, sizeof(wsrep_uuid_t)) ||
+	0 == wsrep_cluster_conf_id)
+    {
+      if (wsrep_init_first())
+      {
+        wsrep_SE_init_grab();
+        // Signal init thread to continue
+        wsrep_sst_complete (&cluster_uuid, view->seqno, false);
+        // and wait for SE initialization
+        wsrep_SE_init_wait();
+      }
+      else
+      {
+        local_uuid=  cluster_uuid;
+        local_seqno= view->seqno;
+      }
+
+      new_status= WSREP_MEMBER_JOINED;
+    }
+    else // just some sanity check
+    {
+      if (memcmp (&local_uuid, &cluster_uuid, sizeof (wsrep_uuid_t)))
+      {
+        WSREP_ERROR("Undetected state gap. Can't continue.");
+        wsrep_log_states (WSREP_LOG_FATAL, &cluster_uuid, view->seqno,
+                          &local_uuid, -1);
+        abort();
+      }
+    }
+  }
+
+  if (wsrep_auto_increment_control)
+  {
+    global_system_variables.auto_increment_offset= view->my_idx + 1;
+    global_system_variables.auto_increment_increment= view->memb_num;
+  }
+
+out:
+
+  local_status.set(new_status, view);
+}
+
+static pthread_mutex_t ready_lock = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t  ready_cond = PTHREAD_COND_INITIALIZER;
+
+// Wait until wsrep has reached ready state
+void wsrep_ready_wait ()
+{
+  if (pthread_mutex_lock (&ready_lock)) abort();
+  while (!wsrep_ready)
+    {
+      WSREP_INFO("Waiting to reach ready state");
+      pthread_cond_wait (&ready_cond, &ready_lock);
+    }
+  WSREP_INFO("ready state reached");
+  pthread_mutex_unlock (&ready_lock);
+}
+
+static void wsrep_synced_cb(void* app_ctx)
+{
+  WSREP_INFO("Synchronized with group, ready for connections");
+  if (pthread_mutex_lock (&ready_lock)) abort();
+  if (!wsrep_ready)
+  {
+    wsrep_ready= TRUE;
+    pthread_cond_signal (&ready_cond);
+  }
+  local_status.set(WSREP_MEMBER_SYNCED);
+  pthread_mutex_unlock (&ready_lock);
+}
+
+int wsrep_init()
+{
+  int rcode= -1;
+
+  wsrep_ready= FALSE;
+  assert(wsrep_provider);
+  assert(wsrep_cluster_address);
+
+  if ((rcode= wsrep_load(wsrep_provider, &wsrep, wsrep_log_cb)) != WSREP_OK)
+  {
+    if (strcasecmp(wsrep_provider, WSREP_NONE))
+    {
+      WSREP_ERROR("wsrep_load(%s) failed: %s (%d). Reverting to no provider.",
+                  wsrep_provider, strerror(rcode), rcode);
+      strcpy((char*)wsrep_provider, WSREP_NONE); // damn it's a dirty hack
+      (void) wsrep_init();
+      return rcode;
+    }
+    else /* this is for recursive call above */
+    {
+      WSREP_ERROR("Could not revert to no provider: %s (%d). Need to abort.",
+                  strerror(rcode), rcode);
+      unireg_abort(1);
+    }
+  }
+
+  if (strlen(wsrep_provider)== 0 ||
+      !strcmp(wsrep_provider, WSREP_NONE))
+  {
+    // enable normal operation in case no provider is specified
+    wsrep_ready= TRUE;
+  }
+  else
+  {
+    strncpy(provider_name,    wsrep->provider_name,    sizeof(provider_name) - 1);
+    strncpy(provider_version, wsrep->provider_version, sizeof(provider_version) - 1);
+    strncpy(provider_vendor,  wsrep->provider_vendor,  sizeof(provider_vendor) - 1);
+  }
+
+  struct wsrep_init_args wsrep_args;
+
+  if (!wsrep_data_home_dir || strlen(wsrep_data_home_dir) == 0)
+    wsrep_data_home_dir = mysql_real_data_home;
+
+  if (!wsrep_node_incoming_address ||
+      !strcmp (wsrep_node_incoming_address, WSREP_NODE_INCOMING_AUTO)) {
+    static char inc_addr[256];
+    size_t inc_addr_max = sizeof (inc_addr);
+    size_t ret = default_address (inc_addr, inc_addr_max);
+    if (ret > 0 && ret < inc_addr_max) {
+      wsrep_node_incoming_address = inc_addr;
+    }
+    else {
+      wsrep_node_incoming_address = NULL;
+    }
+  }
+
+  char node_addr[256] = {0, };
+  if (!wsrep_node_address || !strcmp(wsrep_node_address, ""))
+  {
+    size_t node_addr_max= sizeof(node_addr);
+    size_t ret= default_ip(node_addr, node_addr_max);
+    if (!(ret > 0 && ret < node_addr_max))
+    {
+      WSREP_WARN("Failed to autoguess base node address");
+      node_addr[0]= 0;
+    }
+  }
+  else if (wsrep_node_address)
+  {
+    strncpy(node_addr, wsrep_node_address, sizeof(node_addr) - 1);
+  }
+
+  wsrep_args.data_dir        = wsrep_data_home_dir;
+  wsrep_args.node_name       = wsrep_node_name;
+  wsrep_args.node_address    = node_addr;
+  wsrep_args.node_incoming   = wsrep_node_incoming_address;
+  wsrep_args.options         = wsrep_provider_options;
+  wsrep_args.proto_ver       = wsrep_max_protocol_version;
+
+  wsrep_args.state_uuid      = &local_uuid;
+  wsrep_args.state_seqno     = local_seqno;
+
+  wsrep_args.logger_cb       = wsrep_log_cb;
+  wsrep_args.view_handler_cb = wsrep_view_handler_cb;
+  wsrep_args.apply_cb        = wsrep_apply_cb;
+  wsrep_args.commit_cb       = wsrep_commit_cb;
+  wsrep_args.sst_donate_cb   = wsrep_sst_donate_cb;
+  wsrep_args.synced_cb       = wsrep_synced_cb;
+
+  rcode= wsrep->init(wsrep, &wsrep_args);
+
+  if (rcode)
+  {
+    DBUG_PRINT("wsrep",("wsrep::init() failed: %d", rcode));
+    WSREP_ERROR("wsrep::init() failed: %d, must shutdown", rcode);
+    free(wsrep);
+    wsrep = NULL;
+  }
+
+  return rcode;
+}
+
+
+void wsrep_init_startup (bool first)
+{
+  if (wsrep_init()) unireg_abort(1);
+
+  wsrep_thr_lock_init(wsrep_thd_is_brute_force, wsrep_abort_thd,
+                      wsrep_debug, wsrep_convert_LOCK_to_trx);
+
+  if (first) wsrep_sst_grab(); // do it so we can wait for SST below
+
+  if (!wsrep_start_replication()) unireg_abort(1);
+
+  wsrep_create_rollbacker();
+  wsrep_create_appliers(1);
+
+  if (first && !wsrep_sst_wait()) unireg_abort(1);// wait until SST is completed
+}
+
+
+void wsrep_deinit()
+{
+  wsrep_unload(wsrep);
+  wsrep= 0;
+  provider_name[0]=    '\0';
+  provider_version[0]= '\0';
+  provider_vendor[0]=  '\0';
+}
+
+void wsrep_stop_replication(THD *thd)
+{
+  WSREP_INFO("Stop replication");
+  if (!wsrep)
+  {
+    WSREP_INFO("Provider was not loaded, in stop replication");
+    return;
+  }
+
+  /* disconnect from group first to get wsrep_ready == FALSE */
+  WSREP_DEBUG("Provider disconnect");
+  wsrep->disconnect(wsrep);
+
+  wsrep_connected= FALSE;
+
+  wsrep_close_client_connections(TRUE);
+
+  /* wait until appliers have stopped */
+  wsrep_wait_appliers_close(thd);
+
+  return;
+}
+
+
+bool wsrep_start_replication()
+{
+  wsrep_status_t rcode;
+
+  /*
+    if provider is trivial, don't even try to connect,
+    but resume local node operation
+  */
+  if (strlen(wsrep_provider)== 0 ||
+      !strcmp(wsrep_provider, WSREP_NONE))
+  {
+    // enable normal operation in case no provider is specified
+    wsrep_ready= TRUE;
+    return true;
+  }
+
+  if (strlen(wsrep_cluster_address)== 0)
+  {
+    // if provider is non-trivial, but no address is specified, wait for address
+    wsrep_ready= FALSE;
+    return true;
+  }
+
+  WSREP_INFO("Start replication");
+
+  if ((rcode = wsrep->connect(wsrep,
+                              wsrep_cluster_name,
+                              wsrep_cluster_address,
+                              wsrep_sst_donor)))
+  {
+    if (-ESOCKTNOSUPPORT == rcode)
+    {
+      DBUG_PRINT("wsrep",("unrecognized cluster address: '%s', rcode: %d",
+                          wsrep_cluster_address, rcode));
+      WSREP_ERROR("unrecognized cluster address: '%s', rcode: %d",
+                  wsrep_cluster_address, rcode);
+    }
+    else
+    {
+      DBUG_PRINT("wsrep",("wsrep->connect() failed: %d", rcode));
+      WSREP_ERROR("wsrep::connect() failed: %d", rcode);
+    }
+
+    return false;
+  }
+  else
+  {
+    wsrep_connected= TRUE;
+
+    uint64_t caps = wsrep->capabilities (wsrep);
+
+    wsrep_incremental_data_collection =
+        (caps & WSREP_CAP_WRITE_SET_INCREMENTS);
+
+    char* opts= wsrep->options_get(wsrep);
+    if (opts)
+    {
+      wsrep_provider_options_init(opts);
+      free(opts);
+    }
+    else
+    {
+      WSREP_WARN("Failed to get wsrep options");
+    }
+  }
+
+  return true;
+}
+
+bool
+wsrep_causal_wait (THD* thd)
+{
+  if (thd->variables.wsrep_causal_reads && thd->variables.wsrep_on &&
+      !thd->active_transaction())
+  {
+    // This allows autocommit SELECTs and a first SELECT after SET AUTOCOMMIT=0
+    // TODO: modify to check if thd has locked any rows.
+    wsrep_seqno_t  seqno;
+    wsrep_status_t ret= wsrep->causal_read (wsrep, &seqno);
+
+    if (unlikely(WSREP_OK != ret))
+    {
+      const char* msg;
+      int err;
+
+      // Possibly relevant error codes:
+      // ER_CHECKREAD, ER_ERROR_ON_READ, ER_INVALID_DEFAULT, ER_EMPTY_QUERY,
+      // ER_FUNCTION_NOT_DEFINED, ER_NOT_ALLOWED_COMMAND, ER_NOT_SUPPORTED_YET,
+      // ER_FEATURE_DISABLED, ER_QUERY_INTERRUPTED
+
+      switch (ret)
+      {
+      case WSREP_NOT_IMPLEMENTED:
+        msg= "consistent reads by wsrep backend. "
+             "Please unset wsrep_causal_reads variable.";
+        err= ER_NOT_SUPPORTED_YET;
+        break;
+      default:
+        msg= "Causal wait failed.";
+        err= ER_ERROR_ON_READ;
+      }
+
+      my_error(err, MYF(0), msg);
+
+      return true;
+    }
+  }
+
+  return false;
+}
+
+
+
+bool wsrep_prepare_key_for_isolation(const char* db,
+                                     const char* table,
+                                     wsrep_key_part_t* key,
+                                     size_t* key_len)
+{
+    if (*key_len < 2) return false;
+
+    switch (wsrep_protocol_version)
+    {
+    case 0:
+        *key_len= 0;
+        break;
+    case 1:
+    {
+        *key_len= 0;
+        if (db)
+        {
+            // sql_print_information("%s.%s", db, table);
+            if (db)
+            {
+                key[*key_len].buf= db;
+                key[*key_len].buf_len= strlen(db);
+                ++(*key_len);
+                if (table)
+                {
+                    key[*key_len].buf=     table;
+                    key[*key_len].buf_len= strlen(table);
+                    ++(*key_len);
+                }
+            }
+        }
+        break;
+    }
+    default:
+        return false;
+    }
+
+    return true;
+}
+
+bool wsrep_prepare_key_for_innodb(const uchar* cache_key,
+				  size_t cache_key_len,
+                                  const uchar* row_id,
+                                  size_t row_id_len,
+                                  wsrep_key_part_t* key,
+                                  size_t* key_len)
+{
+    if (*key_len < 3) return false;
+
+    *key_len= 0;
+    switch (wsrep_protocol_version)
+    {
+    case 0:
+    {
+        key[*key_len].buf     = cache_key;
+        key[*key_len].buf_len = cache_key_len;
+        ++(*key_len);
+        break;
+    }
+    case 1:
+    {
+        key[*key_len].buf     = cache_key;
+        key[*key_len].buf_len = strlen( (char*)cache_key );
+        ++(*key_len);
+        key[*key_len].buf     = cache_key + strlen( (char*)cache_key ) + 1;
+        key[*key_len].buf_len = strlen( (char*)(key[*key_len].buf) );
+        ++(*key_len);
+        break;
+    }
+    default:
+        return false;
+    }
+
+    key[*key_len].buf     = row_id;
+    key[*key_len].buf_len = row_id_len;
+    ++(*key_len);
+
+    return true;
+}

=== added file 'sql/wsrep_mysqld.h'
--- old/sql/wsrep_mysqld.h	1970-01-01 00:00:00 +0000
+++ new/sql/wsrep_mysqld.h	2012-05-05 23:54:15 +0000
@@ -0,0 +1,198 @@
+/* Copyright 2008 Codership Oy <http://www.codership.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+#ifndef WSREP_MYSQLD_H
+#define WSREP_MYSQLD_H
+
+//#include <my_global.h>
+#include <mysql_priv.h>
+#include "../wsrep/wsrep_api.h"
+
+class set_var;
+
+// Global wsrep parameters
+extern wsrep_t*    wsrep;
+
+// MySQL wsrep options
+extern const char* wsrep_provider;
+extern const char* wsrep_provider_options;
+extern const char* wsrep_cluster_name;
+extern const char* wsrep_cluster_address;
+extern const char* wsrep_node_name;
+extern const char* wsrep_node_address;
+extern const char* wsrep_node_incoming_address;
+extern const char* wsrep_data_home_dir;
+extern const char* wsrep_dbug_option;
+extern long        wsrep_slave_threads;
+extern my_bool     wsrep_debug;
+extern my_bool     wsrep_convert_LOCK_to_trx;
+extern ulong       wsrep_retry_autocommit;
+extern my_bool     wsrep_auto_increment_control;
+extern my_bool     wsrep_drupal_282555_workaround;
+extern my_bool     wsrep_incremental_data_collection;
+extern const char* wsrep_sst_method;
+extern const char* wsrep_sst_receive_address;
+extern const char* wsrep_sst_auth;
+extern const char* wsrep_sst_donor;
+extern const char* wsrep_start_position;
+extern long long   wsrep_max_ws_size;
+extern long        wsrep_max_ws_rows;
+extern const char* wsrep_notify_cmd;
+extern my_bool     wsrep_certify_nonPK;
+extern long        wsrep_max_protocol_version;
+extern long        wsrep_protocol_version;
+
+
+// MySQL status variables
+extern my_bool     wsrep_connected;
+extern my_bool     wsrep_ready;
+extern const char* wsrep_cluster_state_uuid;
+extern long long   wsrep_cluster_conf_id;
+extern const char* wsrep_cluster_status;
+extern long        wsrep_cluster_size;
+extern long        wsrep_local_index;
+extern const char* wsrep_provider_name;
+extern const char* wsrep_provider_version;
+extern const char* wsrep_provider_vendor;
+extern int         wsrep_show_status(THD *thd, SHOW_VAR *var, char *buff);
+
+// MySQL variables funcs
+extern int  wsrep_init_vars();
+extern void wsrep_on_update               (THD* thd, enum_var_type var_type);
+extern void wsrep_causal_reads_update     (THD* thd, enum_var_type var_type);
+extern int  wsrep_start_position_check    (THD* thd, set_var* var);
+extern bool wsrep_start_position_update   (THD* thd, set_var* var);
+extern void wsrep_start_position_default  (THD* thd, enum_var_type var_type);
+extern void wsrep_start_position_init     (const char* opt);
+extern int  wsrep_provider_check          (THD* thd, set_var* var);
+extern bool wsrep_provider_update         (THD* thd, set_var* var);
+extern void wsrep_provider_default        (THD* thd, enum_var_type var_type);
+extern void wsrep_provider_init           (const char* opt);
+extern int  wsrep_provider_options_check  (THD* thd, set_var* var);
+extern bool wsrep_provider_options_update (THD* thd, set_var* var);
+extern void wsrep_provider_options_default(THD* thd, enum_var_type var_type);
+extern void wsrep_provider_options_init   (const char* opt);
+extern int  wsrep_cluster_address_check   (THD* thd, set_var* var);
+extern bool wsrep_cluster_address_update  (THD* thd, set_var* var);
+extern void wsrep_cluster_address_default (THD* thd, enum_var_type var_type);
+extern void wsrep_cluster_address_init    (const char* opt);
+extern int  wsrep_cluster_name_check      (THD* thd, set_var* var);
+extern bool wsrep_cluster_name_update     (THD* thd, set_var* var);
+extern void wsrep_cluster_name_default    (THD* thd, enum_var_type var_type);
+extern void wsrep_cluster_name_init       (const char* opt);
+extern int  wsrep_node_name_check         (THD* thd, set_var* var);
+extern bool wsrep_node_name_update        (THD* thd, set_var* var);
+extern void wsrep_node_name_default       (THD* thd, enum_var_type var_type);
+extern void wsrep_node_name_init          (const char* opt);
+extern int  wsrep_node_address_check      (THD* thd, set_var* var);
+extern bool wsrep_node_address_update     (THD* thd, set_var* var);
+extern void wsrep_node_address_default    (THD* thd, enum_var_type var_type);
+extern void wsrep_node_address_init       (const char* opt);
+extern int  wsrep_sst_method_check        (THD* thd, set_var* var);
+extern bool wsrep_sst_method_update       (THD* thd, set_var* var);
+extern void wsrep_sst_method_default      (THD* thd, enum_var_type var_type);
+extern void wsrep_sst_method_init         (const char* opt);
+extern int  wsrep_sst_receive_address_chk (THD* thd, set_var* var);
+extern bool wsrep_sst_receive_address_upd (THD* thd, set_var* var);
+extern void wsrep_sst_receive_address_def (THD* thd, enum_var_type var_type);
+extern void wsrep_sst_receive_address_ini (const char* opt);
+extern int  wsrep_sst_auth_check          (THD* thd, set_var* var);
+extern bool wsrep_sst_auth_update         (THD* thd, set_var* var);
+extern void wsrep_sst_auth_default        (THD* thd, enum_var_type var_type);
+extern void wsrep_sst_auth_init           (const char* opt);
+extern int  wsrep_sst_donor_check         (THD* thd, set_var* var);
+extern bool wsrep_sst_donor_update        (THD* thd, set_var* var);
+extern void wsrep_sst_donor_default       (THD* thd, enum_var_type var_type);
+extern void wsrep_sst_donor_init          (const char* opt);
+
+extern bool wsrep_init_first(); // initialize wsrep before storage
+                                // engines (true) or after (false)
+extern int  wsrep_init();
+extern void wsrep_deinit();
+
+/* wsrep initialization sequence at startup
+ * @param first wsrep_init_first() value */
+extern void wsrep_init_startup(bool first);
+
+extern void wsrep_close_client_connections(my_bool wait_to_end);
+extern void wsrep_close_applier(THD *thd);
+extern void wsrep_wait_appliers_close(THD *thd); 
+extern void wsrep_create_appliers(long threads = wsrep_slave_threads);
+extern void wsrep_create_rollbacker();
+extern void wsrep_kill_mysql(THD *thd);
+
+/* new defines */
+extern void wsrep_stop_replication(THD *thd);
+extern bool wsrep_start_replication();
+extern bool wsrep_causal_wait(THD* thd);
+extern int  wsrep_check_opts (int argc, char* const* argv);
+extern void wsrep_prepend_PATH (const char* path);
+
+/* Other global variables */
+extern wsrep_seqno_t wsrep_locked_seqno;
+
+// MySQL logging functions don't seem to understand long long length modifer.
+// This is a workaround. It also prefixes all messages with "WSREP"
+#define WSREP_LOG(fun, ...)                                       \
+    {                                                             \
+        char msg[256] = {'\0'};                                   \
+        snprintf(msg, sizeof(msg) - 1, ## __VA_ARGS__);           \
+        fun("WSREP: %s", msg);                                    \
+    }
+
+#define WSREP_DEBUG(...)                                                \
+    if (wsrep_debug)     WSREP_LOG(sql_print_information, ##__VA_ARGS__)
+#define WSREP_INFO(...)  WSREP_LOG(sql_print_information, ##__VA_ARGS__)
+#define WSREP_WARN(...)  WSREP_LOG(sql_print_warning,     ##__VA_ARGS__)
+#define WSREP_ERROR(...) WSREP_LOG(sql_print_error,       ##__VA_ARGS__)
+
+/*! Synchronizes applier thread start with init thread */
+extern void wsrep_sst_grab();
+/*! Init thread waits for SST completion */
+extern bool wsrep_sst_wait();
+/*! Signals wsrep that initialization is complete, writesets can be applied */
+extern void wsrep_sst_continue();
+
+extern void wsrep_SE_init_grab(); /*! grab init critical section */
+extern void wsrep_SE_init_wait(); /*! wait for SE init to complete */
+extern void wsrep_SE_init_done(); /*! signal that SE init is complte */
+extern void wsrep_SE_initialized(); /*! mark SE initialization complete */
+
+extern void wsrep_ready_wait();
+
+enum wsrep_trx_status {
+    WSREP_TRX_OK,
+    WSREP_TRX_ROLLBACK,
+    WSREP_TRX_ERROR,
+  };
+
+extern enum wsrep_trx_status
+wsrep_run_wsrep_commit(THD *thd, handlerton *hton, bool all);
+
+/*!
+ * @param db      Database string
+ * @param table   Table string
+ * @param key     Array of wsrep_key_t
+ * @param key_len In: number of elements in key array, Out: number of
+ *                elements populated
+ *
+ * @return true if preparation was successful, otherwise false.
+ */
+bool wsrep_prepare_key_for_isolation(const char* db,
+                                     const char* table,
+                                     wsrep_key_part_t* key,
+                                     size_t *key_len);
+
+#endif /* WSREP_MYSQLD_H */

=== added file 'sql/wsrep_notify.cc'
--- old/sql/wsrep_notify.cc	1970-01-01 00:00:00 +0000
+++ new/sql/wsrep_notify.cc	2012-02-15 17:10:00 +0000
@@ -0,0 +1,106 @@
+/* Copyright 2010 Codership Oy <http://www.codership.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+#include "wsrep_priv.h"
+
+const char* wsrep_notify_cmd="";
+
+static const char* _status_str(wsrep_member_status_t status)
+{
+  switch (status)
+  {
+  case WSREP_MEMBER_UNDEFINED: return "Undefined";
+  case WSREP_MEMBER_JOINER:    return "Joiner";
+  case WSREP_MEMBER_DONOR:     return "Donor";
+  case WSREP_MEMBER_JOINED:    return "Joined";
+  case WSREP_MEMBER_SYNCED:    return "Synced";
+  default:                     return "Error(?)";
+  }
+}
+
+void wsrep_notify_status (wsrep_member_status_t    status,
+                          const wsrep_view_info_t* view)
+{
+  if (!wsrep_notify_cmd || 0 == strlen(wsrep_notify_cmd))
+  {
+    WSREP_INFO("wsrep_notify_cmd is not defined, skipping notification.");
+    return;
+  }
+
+  char  cmd_buf[1 << 16]; // this can be long
+  long  cmd_len = sizeof(cmd_buf) - 1;
+  char* cmd_ptr = cmd_buf;
+  long  cmd_off = 0;
+
+  cmd_off += snprintf (cmd_ptr + cmd_off, cmd_len - cmd_off, "%s",
+                       wsrep_notify_cmd);
+
+  if (status >= WSREP_MEMBER_UNDEFINED && status < WSREP_MEMBER_ERROR)
+  {
+    cmd_off += snprintf (cmd_ptr + cmd_off, cmd_len - cmd_off, " --status %s",
+                         _status_str(status));
+  }
+  else
+  {
+    /* here we preserve provider error codes */
+    cmd_off += snprintf (cmd_ptr + cmd_off, cmd_len - cmd_off,
+                         " --status 'Error(%d)'", status);
+  }
+
+  if (0 != view)
+  {
+    char uuid_str[40];
+
+    wsrep_uuid_print (&view->uuid, uuid_str, sizeof(uuid_str));
+    cmd_off += snprintf (cmd_ptr + cmd_off, cmd_len - cmd_off,
+                         " --uuid %s", uuid_str);
+
+    cmd_off += snprintf (cmd_ptr + cmd_off, cmd_len - cmd_off,
+                         " --primary %s", view->view >= 0 ? "yes" : "no");
+
+    cmd_off += snprintf (cmd_ptr + cmd_off, cmd_len - cmd_off,
+                         " --index %d", view->my_idx);
+
+    cmd_off += snprintf (cmd_ptr + cmd_off, cmd_len - cmd_off, " --members");
+
+    for (int i = 0; i < view->memb_num; i++)
+    {
+      wsrep_uuid_print (&view->members[i].id, uuid_str, sizeof(uuid_str));
+      cmd_off += snprintf (cmd_ptr + cmd_off, cmd_len - cmd_off,
+                           "%c%s/%s/%s", i > 0 ? ',' : ' ',
+                           uuid_str, view->members[i].name,
+                           view->members[i].incoming);
+    }
+  }
+
+  if (cmd_off == cmd_len)
+  {
+    WSREP_ERROR("Notification buffer too short (%ld). Aborting notification.",
+               cmd_len);
+    return;
+  }
+
+  wsp::process p(cmd_ptr, "r");
+
+  p.wait();
+  int err = p.error();
+
+  if (err)
+  {
+    WSREP_ERROR("Notification command failed: %d (%s): \"%s\"",
+                err, strerror(err), cmd_ptr);
+  }
+}
+

=== added file 'sql/wsrep_priv.h'
--- old/sql/wsrep_priv.h	1970-01-01 00:00:00 +0000
+++ new/sql/wsrep_priv.h	2012-01-19 16:57:41 +0000
@@ -0,0 +1,230 @@
+/* Copyright 2010 Codership Oy <http://www.codership.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+//! @file declares symbols private to wsrep integration layer
+
+#ifndef WSREP_PRIV_H
+#define WSREP_PRIV_H
+
+#include "wsrep_mysqld.h"
+#include "../wsrep/wsrep_api.h"
+
+#include <pthread.h>
+#include <cstdio>
+
+extern ssize_t wsrep_sst_prepare   (void** msg);
+extern int     wsrep_sst_donate_cb (void* app_ctx,
+                                    void* recv_ctx,
+                                    const void* msg, size_t msg_len,
+                                    const wsrep_uuid_t* current_uuid,
+                                    wsrep_seqno_t       current_seqno,
+                                    const char* state, size_t state_len,
+                                    bool bypass);
+
+extern size_t default_ip (char* buf, size_t buf_len);
+extern size_t default_address(char* buf, size_t buf_len);
+
+extern wsrep_uuid_t          local_uuid;
+extern wsrep_seqno_t         local_seqno;
+
+/*! SST thread signals init thread about sst completion */
+extern void wsrep_sst_complete(wsrep_uuid_t* uuid, wsrep_seqno_t seqno, bool);
+
+extern void wsrep_notify_status (wsrep_member_status_t new_status,
+                                 const wsrep_view_info_t* view = 0);
+
+namespace wsp {
+class node_status
+{
+public:
+  node_status() : status(WSREP_MEMBER_UNDEFINED) {}
+  void set(wsrep_member_status_t new_status,
+           const wsrep_view_info_t* view = 0)
+  {
+    if (status != new_status || 0 != view)
+    {
+      wsrep_notify_status(new_status, view);
+      status = new_status;
+    }
+  }
+  wsrep_member_status_t get() const { return status; }
+private:
+  wsrep_member_status_t status;
+};
+} /* namespace wsp */
+
+extern wsp::node_status local_status;
+
+namespace wsp {
+/* A small class to run external programs. */
+class process
+{
+private:
+    const char* const str_;
+    FILE*       io_;
+    int         err_;
+    pid_t       pid_;
+
+public:
+/*! @arg type is a pointer to a null-terminated string which  must  contain
+         either  the  letter  'r'  for  reading  or the letter 'w' for writing.
+ */
+    process  (const char* cmd, const char* type);
+    ~process ();
+
+    FILE* pipe () { return io_;  }
+    int   error() { return err_; }
+    int   wait ();
+    const char* cmd() { return str_; }
+};
+
+class lock
+{
+  pthread_mutex_t* const mtx_;
+
+public:
+
+  lock (pthread_mutex_t* mtx) : mtx_(mtx)
+  {
+    int err = pthread_mutex_lock (mtx_);
+
+    if (err)
+    {
+      WSREP_ERROR("Mutex lock failed: %s", strerror(err));
+      abort();
+    }
+  }
+
+  virtual ~lock ()
+  {
+    int err = pthread_mutex_unlock (mtx_);
+
+    if (err)
+    {
+      WSREP_ERROR("Mutex unlock failed: %s", strerror(err));
+      abort();
+    }
+  }
+
+  inline void wait (pthread_cond_t* cond)
+  {
+    pthread_cond_wait (cond, mtx_);
+  }
+
+private:
+
+  lock (const lock&);
+  lock& operator=(const lock&);
+
+};
+
+class monitor
+{
+  int             mutable refcnt;
+  pthread_mutex_t mutable mtx;
+  pthread_cond_t  mutable cond;
+
+public:
+
+  monitor() : refcnt(0)
+  {
+    pthread_mutex_init (&mtx, NULL);
+    pthread_cond_init  (&cond, NULL);
+  }
+
+  ~monitor()
+  {
+    pthread_mutex_destroy (&mtx);
+    pthread_cond_destroy  (&cond);
+  }
+
+  void enter() const
+  {
+    lock l(&mtx);
+
+    while (refcnt)
+    {
+      l.wait(&cond);
+    }
+    refcnt++;
+  }
+
+  void leave() const
+  {
+    lock l(&mtx);
+
+    refcnt--;
+    if (refcnt == 0)
+    {
+      pthread_cond_signal (&cond);
+    }
+  }
+
+private:
+
+  monitor (const monitor&);
+  monitor& operator= (const monitor&);
+};
+
+class critical
+{
+  const monitor& mon;
+
+public:
+
+  critical(const monitor& m) : mon(m) { mon.enter(); }
+
+  ~critical() { mon.leave(); }
+
+private:
+
+  critical (const critical&);
+  critical& operator= (const critical&);
+};
+
+class thd
+{
+  class thd_init
+  {
+  public:
+    thd_init()  { my_thread_init(); }
+    ~thd_init() { my_thread_end();  }
+  }
+  init;
+
+  thd (const thd&);
+  thd& operator= (const thd&);
+
+public:
+
+  thd();
+  ~thd();
+  THD* const ptr;
+};
+
+class string
+{
+public:
+    string() : string_(0) {}
+    void set(char* str) { if (string_) free (string_); string_ = str; }
+    ~string() { set (0); }
+private:
+    char* string_;
+};
+
+} // namespace wsrep
+
+#endif /* WSREP_PRIV_H */

=== added file 'sql/wsrep_sst.cc'
--- old/sql/wsrep_sst.cc	1970-01-01 00:00:00 +0000
+++ new/sql/wsrep_sst.cc	2012-05-05 23:54:15 +0000
@@ -0,0 +1,1013 @@
+/* Copyright 2008-2011 Codership Oy <http://www.codership.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+#undef SAFE_MUTEX
+#include "wsrep_priv.h"
+#include <cstdio>
+#include <cstdlib>
+
+extern const char wsrep_defaults_file[];
+
+#define WSREP_SST_MYSQLDUMP "mysqldump"
+#define WSREP_SST_SKIP "skip"
+#define WSREP_SST_DEFAULT WSREP_SST_MYSQLDUMP
+static char sst_method[256] = { 0, };
+const char* wsrep_sst_method = sst_method;
+
+#define WSREP_SST_ADDRESS_AUTO "AUTO"
+static char sst_receive_address[512] = { 0, };
+const char* wsrep_sst_receive_address = sst_receive_address;
+
+static char  sst_auth[16] = { 0, };
+const  char* wsrep_sst_auth = sst_auth;
+
+static char sst_donor[WSREP_MEMBER_NAME_LEN] = { 0, };
+const char* wsrep_sst_donor = sst_donor;
+
+// to show when wsrep_sst_auth is set
+static const char* const sst_auth_set = "********";
+// container for real auth string
+static const char* sst_auth_real = 0;
+
+static bool check_privileges (THD* thd)
+{
+    if (!(thd->security_ctx->master_access & SUPER_ACL)) {
+        my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "SUPER");
+        return 1;
+    }
+    return 0;
+}
+
+static bool check_value (set_var* var, size_t max_size)
+{
+    char   buff[FN_REFLEN];
+    String str(buff, sizeof(buff), system_charset_info), *res;
+    const char* c_str = NULL;
+
+    if ((res = var->value->val_str(&str)) &&
+        (c_str = res->c_ptr()) &&
+        strlen(c_str) < max_size)
+    {
+        return 0;
+    }
+    else
+    {
+        my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), var->var->name, 
+                 c_str ? c_str : "NULL");
+        return 1;
+    }
+}
+
+int  wsrep_sst_method_check (THD* thd, set_var* var)
+{
+    return (check_privileges(thd) || check_value(var, sizeof(sst_method)));
+}
+
+bool wsrep_sst_method_update (THD* thd, set_var* var)
+{
+    strcpy (sst_method, var->value->str_value.c_ptr());
+    return 0;
+}
+
+void wsrep_sst_method_default (THD* thd, enum_var_type var_type)
+{
+    strncpy (sst_method, WSREP_SST_DEFAULT, sizeof(sst_method) - 1);
+}
+
+void wsrep_sst_method_init (const char* opt)
+{
+    if (opt && strlen(opt) < sizeof(sst_method))
+    {
+        strcpy (sst_method, opt);
+    }
+    else
+    {
+        WSREP_ERROR("Bad value for wsrep_sst_method: '%s'", opt ? opt : "NULL");
+    }
+}
+
+static bool sst_receive_address_chk (const char* str)
+{
+    if (!strncasecmp(str, "127.0.0.1", strlen("127.0.0.1")) ||
+        !strncasecmp(str, "localhost", strlen("localhost")))
+    {
+        return 1;
+    }
+
+    return 0;
+}
+
+int  wsrep_sst_receive_address_chk (THD* thd, set_var* var)
+{
+    if (check_privileges(thd) ||
+        check_value(var, sizeof(sst_receive_address)))
+    {
+        return 1;
+    }
+
+    const char* c_str = var->value->str_value.c_ptr();
+
+    if (sst_receive_address_chk (c_str))
+    {
+        my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), var->var->name, 
+                 c_str ? c_str : "NULL");
+        return 1;
+    }
+
+    return 0;
+}
+
+bool wsrep_sst_receive_address_upd (THD* thd, set_var* var)
+{
+    strcpy (sst_receive_address, var->value->str_value.c_ptr());
+    return 0;
+}
+
+void wsrep_sst_receive_address_def (THD* thd, enum_var_type var_type)
+{
+    strncpy (sst_receive_address, WSREP_SST_ADDRESS_AUTO,
+             sizeof(sst_receive_address) - 1);
+}
+
+void wsrep_sst_receive_address_ini (const char* opt)
+{
+    if (opt && strlen(opt) < sizeof(sst_method) &&
+        ! sst_receive_address_chk (opt))
+    {
+        strcpy (sst_receive_address, opt);
+    }
+    else
+    {
+        WSREP_ERROR("Bad value for wsrep_sst_receive_address: '%s'",
+                    opt ? opt : "NULL");
+    }
+}
+
+int wsrep_sst_auth_check (THD* thd, set_var* var)
+{
+    return check_privileges(thd);
+}
+
+static bool sst_auth_real_set (const char* value)
+{
+    const char* v = strdup (value);
+
+    if (v)
+    {
+        if (sst_auth_real) free (const_cast<char*>(sst_auth_real));
+        sst_auth_real = v;
+
+        memset (sst_auth, 0, sizeof(sst_auth));
+
+        if (strlen(sst_auth_real))
+            strncpy (sst_auth, sst_auth_set, sizeof(sst_auth) - 1);
+
+        return 0;
+    }
+
+    return 1;
+}
+
+bool wsrep_sst_auth_update (THD* thd, set_var* var)
+{
+    const char* value = var->value->str_value.c_ptr();
+
+    return sst_auth_real_set (value);
+}
+
+void wsrep_sst_auth_default (THD* thd, enum_var_type var_type)
+{
+    sst_auth_real_set ("root:");
+}
+
+void wsrep_sst_auth_init (const char* value)
+{
+    if (value) sst_auth_real_set (value);
+}
+
+int  wsrep_sst_donor_check (THD* thd, set_var* var)
+{
+    return (check_privileges(thd) || check_value(var, sizeof(sst_donor)));
+}
+
+bool wsrep_sst_donor_update (THD* thd, set_var* var)
+{
+    strcpy (sst_donor, var->value->str_value.c_ptr());
+    return 0;
+}
+
+void wsrep_sst_donor_default (THD* thd, enum_var_type var_type)
+{
+    memset (sst_donor, '\0', sizeof(sst_donor));
+}
+
+void wsrep_sst_donor_init (const char* opt)
+{
+    if (opt && strlen(opt) < sizeof(sst_donor))
+    {
+        strcpy (sst_donor, opt);
+    }
+    else
+    {
+        WSREP_ERROR("Bad value for wsrep_sst_donor: '%s'", opt ? opt : "NULL");
+    }
+}
+
+static wsrep_uuid_t cluster_uuid = WSREP_UUID_UNDEFINED;
+
+bool wsrep_init_first()
+{
+  return (wsrep_provider != NULL
+          && strcmp (wsrep_provider, WSREP_NONE)
+          && strcmp (wsrep_sst_method, WSREP_SST_SKIP)
+          && strcmp (wsrep_sst_method, WSREP_SST_MYSQLDUMP));
+}
+
+static pthread_mutex_t sst_lock = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t  sst_cond = PTHREAD_COND_INITIALIZER;
+static bool            sst_complete = false;
+static bool            sst_needed   = false;
+
+void wsrep_sst_grab ()
+{
+    WSREP_INFO("wsrep_sst_grab()");
+  if (pthread_mutex_lock (&sst_lock)) abort();
+  sst_complete = false;
+  pthread_mutex_unlock (&sst_lock);
+}
+
+// Wait for end of SST
+bool wsrep_sst_wait ()
+{
+  if (pthread_mutex_lock (&sst_lock)) abort();
+  while (!sst_complete)
+  {
+    WSREP_INFO("Waiting for SST to complete.");
+    pthread_cond_wait (&sst_cond, &sst_lock);
+  }
+
+  if (local_seqno >= 0)
+  {
+    WSREP_INFO("SST complete, seqno: %lld", (long long) local_seqno);
+  }
+  else
+  {
+    WSREP_ERROR("SST failed: %d (%s)",
+                int(-local_seqno), strerror(-local_seqno));
+  }
+
+  pthread_mutex_unlock (&sst_lock);
+
+  return (local_seqno >= 0);
+}
+
+// Signal end of SST
+void wsrep_sst_complete (wsrep_uuid_t* sst_uuid,
+                         wsrep_seqno_t sst_seqno,
+                         bool          needed)
+{
+  if (pthread_mutex_lock (&sst_lock)) abort();
+  if (!sst_complete)
+  {
+    sst_complete = true;
+    sst_needed   = needed;
+    local_uuid   = *sst_uuid;
+    local_seqno  = sst_seqno;
+    pthread_cond_signal (&sst_cond);
+  }
+  else
+  {
+    WSREP_WARN("Nobody is waiting for SST.");
+  }
+  pthread_mutex_unlock (&sst_lock);
+}
+
+// Let applier threads to continue
+void wsrep_sst_continue ()
+{
+  if (sst_needed)
+  {
+    WSREP_INFO("Signaling provider to continue.");
+    wsrep->sst_received (wsrep, &local_uuid, local_seqno, NULL, 0);
+  }
+}
+
+struct sst_thread_arg
+{
+  const char*     cmd;
+  int             err;
+  char*           ret_str;
+  pthread_mutex_t lock;
+  pthread_cond_t  cond;
+
+  sst_thread_arg (const char* c) : cmd(c), err(-1), ret_str(0)
+  {
+    pthread_mutex_init (&lock, NULL);
+    pthread_cond_init  (&cond, NULL);
+  }
+
+  ~sst_thread_arg()
+  {
+    pthread_cond_destroy  (&cond);
+    pthread_mutex_unlock  (&lock);
+    pthread_mutex_destroy (&lock);
+  }
+};
+
+static int sst_scan_uuid_seqno (const char* str,
+                                wsrep_uuid_t* uuid, wsrep_seqno_t* seqno)
+{
+  int offt = wsrep_uuid_scan (str, strlen(str), uuid);
+  if (offt > 0 && strlen(str) > (unsigned int)offt && ':' == str[offt])
+  {
+    *seqno = strtoll (str + offt + 1, NULL, 10);
+    if (*seqno != LLONG_MAX || errno != ERANGE)
+    {
+      return 0;
+    }
+  }
+
+  WSREP_ERROR("Failed to parse uuid:seqno pair: '%s'", str);
+  return EINVAL;
+}
+
+// get rid of trailing \n
+static char* my_fgets (char* buf, size_t buf_len, FILE* stream)
+{
+   char* ret= fgets (buf, buf_len, stream);
+
+   if (ret)
+   {
+       size_t len = strlen(ret);
+       if (len > 0 && ret[len - 1] == '\n') ret[len - 1] = '\0';
+   }
+
+   return ret;
+}
+
+static void* sst_joiner_thread (void* a)
+{
+  sst_thread_arg* arg= (sst_thread_arg*) a;
+  int err= 1;
+
+  {
+    const char magic[] = "ready";
+    const size_t magic_len = sizeof(magic) - 1;
+    const size_t out_len = 512;
+    char out[out_len];
+
+    WSREP_INFO("Running: '%s'", arg->cmd);
+
+    wsp::process proc (arg->cmd, "r");
+
+    if (proc.pipe() && !proc.error())
+    {
+      const char* tmp= my_fgets (out, out_len, proc.pipe());
+
+      if (!tmp || strlen(tmp) < (magic_len + 2) ||
+          strncasecmp (tmp, magic, magic_len))
+      {
+        WSREP_ERROR("Failed to read '%s <addr>' from: %s\n\tRead: '%s'",
+                    magic, arg->cmd, tmp);
+        proc.wait();
+        if (proc.error()) err = proc.error();
+      }
+      else
+      {
+        err = 0;
+      }
+    }
+    else
+    {
+      err = proc.error();
+      WSREP_ERROR("Failed to execute: %s : %d (%s)",
+                  arg->cmd, err, strerror(err));
+    }
+
+    // signal sst_prepare thread with ret code,
+    // it will go on sending SST request
+    pthread_mutex_lock   (&arg->lock);
+    if (!err)
+    {
+      arg->ret_str = strdup (out + magic_len + 1);
+      if (!arg->ret_str) err = ENOMEM;
+    }
+    arg->err = -err;
+    pthread_cond_signal  (&arg->cond);
+    pthread_mutex_unlock (&arg->lock); //! @note arg is unusable after that.
+
+    if (err) return NULL; /* lp:808417 - return immediately, don't signal
+                           * initializer thread to ensure single thread of
+                           * shutdown. */
+
+    wsrep_uuid_t  ret_uuid  = WSREP_UUID_UNDEFINED;
+    wsrep_seqno_t ret_seqno = WSREP_SEQNO_UNDEFINED;
+
+    // in case of successfull receiver start, wait for SST completion/end
+    char* tmp = my_fgets (out, out_len, proc.pipe());
+
+    proc.wait();
+    err= EINVAL;
+
+    if (!tmp)
+    {
+      WSREP_ERROR("Failed to read uuid:seqno from joiner script.");
+      if (proc.error()) err = proc.error();
+    }
+    else
+    {
+      err= sst_scan_uuid_seqno (out, &ret_uuid, &ret_seqno);
+    }
+
+    if (err)
+    {
+      ret_uuid=  WSREP_UUID_UNDEFINED;
+      ret_seqno= -err;
+    }
+
+    // Tell initializer thread that SST is complete
+    wsrep_sst_complete (&ret_uuid, ret_seqno, true);
+  }
+
+  return NULL;
+}
+
+static ssize_t sst_prepare_other (const char*  method,
+                                  const char*  addr_in,
+                                  const char** addr_out)
+{
+  ssize_t cmd_len= 1024;
+  char    cmd_str[cmd_len];
+  const char* sst_dir= mysql_real_data_home;
+
+  int ret= snprintf (cmd_str, cmd_len,
+                     "wsrep_sst_%s 'joiner' '%s' '%s' '%s' '%s' '%d' 2>sst.err",
+                     method, addr_in, sst_auth_real, sst_dir,
+                     wsrep_defaults_file, (int)getpid());
+
+  if (ret < 0 || ret >= cmd_len)
+  {
+    WSREP_ERROR("sst_prepare_other(): snprintf() failed: %d", ret);
+    return (ret < 0 ? ret : -EMSGSIZE);
+  }
+
+  pthread_t tmp;
+  sst_thread_arg arg(cmd_str);
+  pthread_mutex_lock (&arg.lock);
+  pthread_create (&tmp, NULL, sst_joiner_thread, &arg);
+  pthread_cond_wait (&arg.cond, &arg.lock);
+
+  *addr_out= arg.ret_str;
+
+  if (!arg.err)
+    ret = strlen(*addr_out);
+  else
+  {
+    assert (arg.err < 0);
+    ret = arg.err;
+  }
+
+  pthread_detach (tmp);
+
+  return ret;
+}
+
+//extern ulong my_bind_addr;
+extern uint  mysqld_port;
+
+/*! Just tells donor where to sent mysqldump */
+static ssize_t sst_prepare_mysqldump (const char*  addr_in,
+                                      const char** addr_out)
+{
+  ssize_t ret = strlen (addr_in);
+
+  if (!strrchr(addr_in, ':'))
+  {
+    ssize_t s = ret + 7;
+    char* tmp = (char*) malloc (s);
+
+    if (tmp)
+    {
+      ret= snprintf (tmp, s, "%s:%u", addr_in, mysqld_port);
+
+      if (ret > 0 && ret < s)
+      {
+        *addr_out= tmp;
+        return ret;
+      }
+      if (ret > 0) /* buffer too short */ ret = -EMSGSIZE;
+      free (tmp);
+    }
+    else {
+      ret= -ENOMEM;
+    }
+
+    WSREP_ERROR ("Could not prepare state transfer request: "
+                 "adding default port failed: %zd.", ret);
+  }
+  else {
+    *addr_out= addr_in;
+  }
+
+  return ret;
+}
+
+static bool SE_initialized = false;
+
+ssize_t wsrep_sst_prepare (void** msg)
+{
+  const ssize_t ip_max= 256;
+  char ip_buf[ip_max];
+  const char* addr_in=  NULL;
+  const char* addr_out= NULL;
+
+  if (!strcmp(wsrep_sst_method, WSREP_SST_SKIP))
+  {
+    ssize_t ret = strlen(WSREP_STATE_TRANSFER_TRIVIAL) + 1;
+    *msg = strdup(WSREP_STATE_TRANSFER_TRIVIAL);
+    if (!msg)
+    {
+      WSREP_ERROR("Could not allocate %zd bytes for state request", ret);
+      unireg_abort(1);
+    }
+    return ret;
+  }
+
+  // Figure out SST address. Common for all SST methods
+  if (wsrep_sst_receive_address &&
+    strcmp (wsrep_sst_receive_address, WSREP_SST_ADDRESS_AUTO))
+  {
+    addr_in= wsrep_sst_receive_address;
+  }
+  else if (wsrep_node_address && strlen(wsrep_node_address))
+  {
+    const char* const colon= strchr (wsrep_node_address, ':');
+    if (colon)
+    {
+      ptrdiff_t const len= colon - wsrep_node_address;
+      strncpy (ip_buf, wsrep_node_address, len);
+      ip_buf[len]= '\0';
+      addr_in= ip_buf;
+    }
+    else
+    {
+      addr_in= wsrep_node_address;
+    }
+  }
+  else
+  {
+    ssize_t ret= default_ip (ip_buf, ip_max);
+
+    if (ret && ret < ip_max)
+    {
+      addr_in= ip_buf;
+    }
+    else
+    {
+      WSREP_ERROR("Could not prepare state transfer request: "
+                  "failed to guess address to accept state transfer at. "
+                  "wsrep_sst_receive_address must be set manually.");
+//      return -EADDRNOTAVAIL;
+      unireg_abort(1);
+    }
+  }
+
+  ssize_t addr_len= -ENOSYS;
+  if (!strcmp(wsrep_sst_method, WSREP_SST_MYSQLDUMP))
+  {
+    addr_len= sst_prepare_mysqldump (addr_in, &addr_out);
+    if (addr_len < 0) unireg_abort(1); // return addr_len;
+  }
+  else
+  {
+    /*! A heuristic workaround until we learn how to stop and start engines */
+    if (SE_initialized)
+    {
+      // we already did SST at initializaiton, now engines are running
+      // sql_print_information() is here because the message is too long
+      // for WSREP_INFO.
+      sql_print_information ("WSREP: "
+                 "You have configured '%s' state snapshot transfer method "
+                 "which cannot be performed on a running server. "
+                 "Wsrep provider won't be able to fall back to it "
+                 "if other means of state transfer are unavailable. "
+                 "In that case you will need to restart the server.",
+                 wsrep_sst_method);
+      *msg = 0;
+      return 0;
+    }
+
+    addr_len = sst_prepare_other (wsrep_sst_method, addr_in, &addr_out);
+    if (addr_len < 0)
+    {
+      WSREP_ERROR("Failed to prepare for '%s' SST. Unrecoverable.",
+                   wsrep_sst_method);
+//      return addr_len;
+      unireg_abort(1);
+    }
+  }
+
+  size_t const method_len(strlen(wsrep_sst_method));
+  size_t const msg_len   (method_len + addr_len + 2 /* + auth_len + 1*/);
+
+  *msg = malloc (msg_len);
+  if (NULL != *msg) {
+    char* const method_ptr(reinterpret_cast<char*>(*msg));
+    strcpy (method_ptr, wsrep_sst_method);
+    char* const addr_ptr(method_ptr + method_len + 1);
+    strcpy (addr_ptr, addr_out);
+
+    WSREP_INFO ("Prepared SST request: %s|%s", method_ptr, addr_ptr);
+  }
+  else {
+    WSREP_ERROR("Failed to allocate SST request of size %zu. Can't continue.",
+                msg_len);
+    unireg_abort(1);
+  }
+
+  if (addr_out != addr_in) /* malloc'ed */ free ((char*)addr_out);
+
+  return msg_len;
+}
+
+// helper method for donors
+static int sst_run_shell (const char* cmd_str, int max_tries)
+{
+  int ret = 0;
+
+  for (int tries=1; tries <= max_tries; tries++)
+  {
+    wsp::process proc (cmd_str, "r");
+
+    if (NULL != proc.pipe())
+    {
+      proc.wait();
+    }
+
+    if ((ret = proc.error()))
+    {
+      WSREP_ERROR("Try %d/%d: '%s' failed: %d (%s)",
+                  tries, max_tries, proc.cmd(), ret, strerror(ret));
+      sleep (1);
+    }
+    else
+    {
+      WSREP_DEBUG("SST script successfully completed.");
+      break;
+    }
+  }
+
+  return -ret;
+}
+
+static int sst_mysqldump_check_addr (const char* user, const char* pswd,
+                                     const char* host, const char* port)
+{
+  return 0;
+}
+
+static int sst_donate_mysqldump (const char*         addr,
+                                 const wsrep_uuid_t* uuid,
+                                 const char*         uuid_str,
+                                 wsrep_seqno_t       seqno,
+                                 bool                bypass)
+{
+  size_t host_len;
+  const char* port = strchr (addr, ':');
+
+  if (port)
+  {
+    port += 1;
+    host_len = port - addr;
+  }
+  else
+  {
+    port = "";
+    host_len = strlen (addr) + 1;
+  }
+
+  char host[host_len];
+
+  strncpy (host, addr, host_len - 1);
+  host[host_len - 1] = '\0';
+
+  const char* auth = sst_auth_real;
+  const char* pswd = strchr (auth, ':');
+  size_t user_len;
+
+  if (pswd)
+  {
+    pswd += 1;
+    user_len = pswd - auth;
+  }
+  else
+  {
+    pswd = "";
+    user_len = strlen (auth) + 1;
+  }
+
+  char user[user_len];
+
+  strncpy (user, auth, user_len - 1);
+  user[user_len - 1] = '\0';
+
+  int ret = sst_mysqldump_check_addr (user, pswd, host, port);
+  if (!ret)
+  {
+    size_t cmd_len= 1024;
+    char   cmd_str[cmd_len];
+
+    snprintf (cmd_str, cmd_len,
+              "wsrep_sst_mysqldump '%s' '%s' '%s' '%s' '%u' '%s' '%lld' '%d'",
+              user, pswd, host, port, mysqld_port, uuid_str, (long long)seqno,
+              bypass);
+
+    WSREP_DEBUG("Running: '%s'", cmd_str);
+
+    ret= sst_run_shell (cmd_str, 3);
+  }
+
+  wsrep->sst_sent (wsrep, uuid, ret ? ret : seqno);
+
+  return ret;
+}
+
+wsrep_seqno_t wsrep_locked_seqno= WSREP_SEQNO_UNDEFINED;
+
+static int sst_flush_tables(THD* thd)
+{
+  WSREP_INFO("Flushing tables for SST...");
+
+  int not_used;
+  int  err= reload_acl_and_cache(thd, REFRESH_TABLES | REFRESH_READ_LOCK,
+                                 (TABLE_LIST*) 0, &not_used);
+//  Other possible flags: REFRESH_LOG, REFRESH_THREADS, REFRESH_HOSTS,
+//                        REFRESH_FAST, REFRESH_STATUS, REFRESH_SLAVE,
+//                        REFRESH_MASTER, REFRESH_QUERY_CACHE_FREE,
+//                        REFRESH_DES_KEY_FILE
+
+  if (err)
+  {
+    WSREP_ERROR("Failed to flush and lock tables: %d (%s)", err,strerror(err));
+  }
+  else
+  {
+    /* make sure logs are flushed after global read lock acquired */
+    err= reload_acl_and_cache(thd, REFRESH_LOG, (TABLE_LIST*) 0, &not_used);
+  }
+
+  if (err)
+  {
+    WSREP_ERROR("Failed to flush redo logs: %d (%s)", err, strerror(err));
+  }
+  else
+  {
+    WSREP_INFO("Tables flushed.");
+
+    const char base_name[]= "tables_flushed";
+    ssize_t const full_len= strlen(mysql_real_data_home) + strlen(base_name)+2;
+    char real_name[full_len];
+    sprintf(real_name, "%s/%s", mysql_real_data_home, base_name);
+    char tmp_name[full_len + 4];
+    sprintf(tmp_name, "%s.tmp", real_name);
+
+    FILE* file= fopen(tmp_name, "w+");
+    if (0 == file)
+    {
+      err= errno;
+      WSREP_ERROR("Failed to open '%s': %d (%s)", tmp_name, err,strerror(err));
+    }
+    else
+    {
+      fprintf(file, "%s:%lld\n",
+              wsrep_cluster_state_uuid, (long long)wsrep_locked_seqno);
+      fsync(fileno(file));
+      fclose(file);
+      if (rename(tmp_name, real_name) == -1)
+      {
+        err= errno;
+        WSREP_ERROR("Failed to rename '%s' to '%s': %d (%s)",
+                     tmp_name, real_name, err,strerror(err));
+      }
+    }
+  }
+
+  return err;
+}
+
+static void sst_disallow_writes (THD* thd, bool yes)
+{
+  char query_str[64] = { 0, };
+  ssize_t const query_max = sizeof(query_str) - 1;
+  snprintf (query_str, query_max, "SET GLOBAL innodb_disallow_writes=%d",
+            yes ? 1 : 0);
+
+  thd->set_query(query_str, strlen(query_str));
+
+  const char* found_semicolon = 0;
+  mysql_parse(thd, thd->query(), thd->query_length(), &found_semicolon);
+  if (thd->is_error())
+  {
+    int const err= thd->main_da.sql_errno();
+    WSREP_WARN ("error executing '%s': %d (%s)%s",
+                query_str, err, thd->main_da.message(),
+                err == ER_UNKNOWN_SYSTEM_VARIABLE ? 
+                ". Was mysqld built with --with-innodb-disallow-writes ?" : "");
+    thd->clear_error();
+  }
+}
+
+static void* sst_donor_thread (void* a)
+{
+  sst_thread_arg* arg= (sst_thread_arg*)a;
+
+  WSREP_INFO("Running: '%s'", arg->cmd);
+
+  int  err= 1;
+  bool locked= false;
+
+  const char*  out= NULL;
+  const size_t out_len= 128;
+  char         out_buf[out_len];
+
+  wsrep_uuid_t  ret_uuid= WSREP_UUID_UNDEFINED;
+  wsrep_seqno_t ret_seqno= WSREP_SEQNO_UNDEFINED; // seqno of complete SST
+
+  wsp::thd thd;
+  wsp::process proc(arg->cmd, "r");
+
+  err= proc.error();
+
+/* Inform server about SST script startup and release TO isolation */
+  pthread_mutex_lock   (&arg->lock);
+  arg->err = -err;
+  pthread_cond_signal  (&arg->cond);
+  pthread_mutex_unlock (&arg->lock); //! @note arg is unusable after that.
+
+  if (proc.pipe() && !err)
+  {
+wait_signal:
+    out= my_fgets (out_buf, out_len, proc.pipe());
+
+    if (out)
+    {
+      const char magic_flush[]= "flush tables";
+      const char magic_cont[]= "continue";
+      const char magic_done[]= "done";
+
+      if (!strcasecmp (out, magic_flush))
+      {
+        err= sst_flush_tables (thd.ptr);
+        if (!err)
+        {
+          sst_disallow_writes (thd.ptr, true);
+          locked= true;
+          goto wait_signal;
+        }
+      }
+      else if (!strcasecmp (out, magic_cont))
+      {
+        if (locked)
+        {
+          sst_disallow_writes (thd.ptr, false);
+          unlock_global_read_lock (thd.ptr);
+          locked= false;
+        }
+        err=  0;
+        goto wait_signal;
+      }
+      else if (!strncasecmp (out, magic_done, strlen(magic_done)))
+      {
+        err= sst_scan_uuid_seqno (out + strlen(magic_done) + 1,
+                                  &ret_uuid, &ret_seqno);
+      }
+      else
+      {
+        WSREP_WARN("Received unknown signal: '%s'", out);
+      }
+    }
+    else
+    {
+      WSREP_ERROR("Failed to read from: %s", proc.cmd());
+    }
+    if (err && proc.error()) err= proc.error();
+  }
+  else
+  {
+    WSREP_ERROR("Failed to execute: %s : %d (%s)",
+                proc.cmd(), err, strerror(err));
+  }
+
+  if (locked) // don't forget to unlock server before return
+  {
+    sst_disallow_writes (thd.ptr, false);
+    unlock_global_read_lock (thd.ptr);
+  }
+
+  // signal to donor that SST is over
+  wsrep->sst_sent (wsrep, &ret_uuid, err ? -err : ret_seqno);
+  proc.wait();
+
+  return NULL;
+}
+
+static int sst_donate_other (const char*   method,
+                             const char*   addr,
+                             const char*   uuid,
+                             wsrep_seqno_t seqno,
+                             bool          bypass)
+{
+  ssize_t cmd_len = 4096;
+  char    cmd_str[cmd_len];
+
+  int ret= snprintf (cmd_str, cmd_len,
+                     "wsrep_sst_%s 'donor' '%s' '%s' '%s' '%s' '%s' '%lld' '%d'"
+                     ,
+                     method, addr, sst_auth_real, mysql_real_data_home,
+                     wsrep_defaults_file, uuid, (long long) seqno, bypass);
+
+  if (ret < 0 || ret >= cmd_len)
+  {
+    WSREP_ERROR("sst_donate_other(): snprintf() failed: %d", ret);
+    return (ret < 0 ? ret : -EMSGSIZE);
+  }
+
+  pthread_t tmp;
+  sst_thread_arg arg(cmd_str);
+  pthread_mutex_lock (&arg.lock);
+  pthread_create (&tmp, NULL, sst_donor_thread, &arg);
+  pthread_cond_wait (&arg.cond, &arg.lock);
+
+  WSREP_INFO("sst_donor_thread signaled with %d", arg.err);
+  return arg.err;
+}
+
+int wsrep_sst_donate_cb (void* app_ctx, void* recv_ctx,
+                         const void* msg, size_t msg_len,
+                         const wsrep_uuid_t*     current_uuid,
+                         wsrep_seqno_t           current_seqno,
+                         const char* state, size_t state_len,
+                         bool bypass)
+{
+  /* This will be reset when sync callback is called.
+   * Should we set wsrep_ready to FALSE here too? */
+//  wsrep_notify_status(WSREP_MEMBER_DONOR);
+  local_status.set(WSREP_MEMBER_DONOR);
+
+  const char* method = (char*)msg;
+  size_t method_len  = strlen (method);
+  const char* data   = method + method_len + 1;
+
+  char uuid_str[37];
+  wsrep_uuid_print (current_uuid, uuid_str, sizeof(uuid_str));
+
+  int ret;
+  if (!strcmp (WSREP_SST_MYSQLDUMP, method))
+  {
+    ret = sst_donate_mysqldump (data, current_uuid, uuid_str, current_seqno,
+                                bypass);
+  }
+  else
+  {
+    ret = sst_donate_other (method, data, uuid_str, current_seqno, bypass);
+  }
+
+  return (ret > 0 ? 0 : ret);
+}
+
+static pthread_mutex_t init_lock = PTHREAD_MUTEX_INITIALIZER;
+static pthread_cond_t  init_cond = PTHREAD_COND_INITIALIZER;
+
+void wsrep_SE_init_grab()
+{
+  if (pthread_mutex_lock (&init_lock)) abort();
+}
+
+void wsrep_SE_init_wait()
+{
+  pthread_cond_wait (&init_cond, &init_lock);
+  pthread_mutex_unlock (&init_lock);
+}
+
+void wsrep_SE_init_done()
+{
+  pthread_cond_signal (&init_cond);
+  pthread_mutex_unlock (&init_lock);
+}
+
+void wsrep_SE_initialized()
+{
+  SE_initialized = true;
+}

=== added file 'sql/wsrep_utils.cc'
--- old/sql/wsrep_utils.cc	1970-01-01 00:00:00 +0000
+++ new/sql/wsrep_utils.cc	2012-05-04 07:24:05 +0000
@@ -0,0 +1,391 @@
+/* Copyright 2010 Codership Oy <http://www.codership.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+//! @file declares symbols private to wsrep integration layer
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE // POSIX_SPAWN_USEVFORK flag
+#endif
+
+#include <spawn.h>    // posix_spawn()
+#include <unistd.h>   // pipe()
+#include <errno.h>    // errno
+#include <string.h>   // strerror()
+#include <sys/wait.h> // waitpid()
+
+#include "wsrep_priv.h"
+
+extern char** environ; // environment variables
+
+static wsp::string wsrep_PATH;
+
+void
+wsrep_prepend_PATH (const char* path)
+{
+    int count = 0;
+
+    while (environ[count])
+    {
+        if (strncmp (environ[count], "PATH=", 5))
+        {
+            count++;
+            continue;
+        }
+
+        char* const old_path (environ[count]);
+
+        if (strstr (old_path, path)) return; // path already there
+
+        size_t const new_path_len(strlen(old_path) + strlen(":") +
+                                  strlen(path) + 1);
+
+        char* const new_path (reinterpret_cast<char*>(malloc(new_path_len)));
+
+        if (new_path)
+        {
+            snprintf (new_path, new_path_len, "PATH=%s:%s", path,
+                      old_path + strlen("PATH="));
+
+            wsrep_PATH.set (new_path);
+            environ[count] = new_path;
+        }
+        else
+        {
+            WSREP_ERROR ("Failed to allocate 'PATH' environment variable "
+                         "buffer of size %zu.", new_path_len);
+        }
+
+        return;
+    }
+
+    WSREP_ERROR ("Failed to find 'PATH' environment variable. "
+                 "State snapshot transfer may not be working.");
+}
+
+namespace wsp
+{
+
+#define PIPE_READ  0
+#define PIPE_WRITE 1
+#define STDIN_FD   0
+#define STDOUT_FD  1
+
+#ifndef POSIX_SPAWN_USEVFORK
+# define POSIX_SPAWN_USEVFORK 0
+#endif
+
+process::process (const char* cmd, const char* type)
+    : str_(cmd ? strdup(cmd) : strdup("")), io_(NULL), err_(EINVAL), pid_(0)
+{
+    if (0 == str_)
+    {
+        WSREP_ERROR ("Can't allocate command line of size: %zu", strlen(cmd));
+        err_ = ENOMEM;
+        return;
+    }
+
+    if (0 == strlen(str_))
+    {
+        WSREP_ERROR ("Can't start a process: null or empty command line.");
+        return;
+    }
+
+    if (NULL == type || (strcmp (type, "w") && strcmp(type, "r")))
+    {
+        WSREP_ERROR ("type argument should be either \"r\" or \"w\".");
+        return;
+    }
+
+    int pipe_fds[2] = { -1, };
+    if (::pipe(pipe_fds))
+    {
+        err_ = errno;
+        WSREP_ERROR ("pipe() failed: %d (%s)", err_, strerror(err_));
+        return;
+    }
+
+    // which end of pipe will be returned to parent
+    int const parent_end (strcmp(type,"w") ? PIPE_READ : PIPE_WRITE);
+    int const child_end  (parent_end == PIPE_READ ? PIPE_WRITE : PIPE_READ);
+    int const close_fd   (parent_end == PIPE_READ ? STDOUT_FD : STDIN_FD);
+
+    char* const pargv[4] = { strdup("sh"), strdup("-c"), strdup(str_), NULL };
+    if (!(pargv[0] && pargv[1] && pargv[2]))
+    {
+        err_ = ENOMEM;
+        WSREP_ERROR ("Failed to allocate pargv[] array.");
+        goto cleanup_pipe;
+    }
+
+    posix_spawnattr_t attr;
+    err_ = posix_spawnattr_init (&attr);
+    if (err_)
+    {
+        WSREP_ERROR ("posix_spawnattr_init() failed: %d (%s)",
+                     err_, strerror(err_));
+        goto cleanup_pipe;
+    }
+
+    err_ = posix_spawnattr_setflags (&attr, POSIX_SPAWN_SETSIGDEF |
+                                            POSIX_SPAWN_USEVFORK);
+    if (err_)
+    {
+        WSREP_ERROR ("posix_spawnattr_setflags() failed: %d (%s)",
+                     err_, strerror(err_));
+        goto cleanup_attr;
+    }
+
+    posix_spawn_file_actions_t fact;
+    err_ = posix_spawn_file_actions_init (&fact);
+    if (err_)
+    {
+        WSREP_ERROR ("posix_spawn_file_actions_init() failed: %d (%s)",
+                     err_, strerror(err_));
+        goto cleanup_attr;
+    }
+
+    // close child's stdout|stdin depending on what we returning
+    err_ = posix_spawn_file_actions_addclose (&fact, close_fd);
+    if (err_)
+    {
+        WSREP_ERROR ("posix_spawn_file_actions_addclose() failed: %d (%s)",
+                     err_, strerror(err_));
+        goto cleanup_fact;
+    }
+
+    // substitute our pipe descriptor in place of the closed one
+    err_ = posix_spawn_file_actions_adddup2 (&fact,
+                                             pipe_fds[child_end], close_fd);
+    if (err_)
+    {
+        WSREP_ERROR ("posix_spawn_file_actions_addup2() failed: %d (%s)",
+                     err_, strerror(err_));
+        goto cleanup_fact;
+    }
+
+    err_ = posix_spawnp (&pid_, pargv[0], &fact, &attr, pargv, environ);
+    if (err_)
+    {
+        WSREP_ERROR ("posix_spawnp(%s) failed: %d (%s)",
+                     pargv[2], err_, strerror(err_));
+        pid_ = 0; // just to make sure it was not messed up in the call
+        goto cleanup_fact;
+    }
+
+    io_ = fdopen (pipe_fds[parent_end], type);
+
+    if (io_)
+    {
+        pipe_fds[parent_end] = -1; // skip close on cleanup
+    }
+    else
+    {
+        err_ = errno;
+        WSREP_ERROR ("fdopen() failed: %d (%s)", err_, strerror(err_));
+    }
+
+cleanup_fact:
+    int err; // to preserve err_ code
+    err = posix_spawn_file_actions_destroy (&fact);
+    if (err)
+    {
+        WSREP_ERROR ("posix_spawn_file_actions_destroy() failed: %d (%s)\n",
+                     err, strerror(err));
+    }
+
+cleanup_attr:
+    err = posix_spawnattr_destroy (&attr);
+    if (err)
+    {
+        WSREP_ERROR ("posix_spawnattr_destroy() failed: %d (%s)",
+                     err, strerror(err));
+    }
+
+cleanup_pipe:
+    if (pipe_fds[0] >= 0) close (pipe_fds[0]);
+    if (pipe_fds[1] >= 0) close (pipe_fds[1]);
+
+    free (pargv[0]);
+    free (pargv[1]);
+    free (pargv[2]);
+}
+
+process::~process ()
+{
+    if (io_)
+    {
+        assert (pid_);
+        assert (str_);
+
+        WSREP_WARN("Closing pipe to child process: %s, PID(%ld) "
+                   "which might still be running.", str_, (long)pid_);
+
+        if (fclose (io_) == -1)
+        {
+            err_ = errno;
+            WSREP_ERROR("fclose() failed: %d (%s)", err_, strerror(err_));
+        }
+    }
+
+    if (str_) free (const_cast<char*>(str_));
+}
+
+int
+process::wait ()
+{
+  if (pid_)
+  {
+      int status;
+      if (-1 == waitpid(pid_, &status, 0))
+      {
+          err_ = errno; assert (err_);
+          WSREP_ERROR("Waiting for process failed: %s, PID(%ld): %d (%s)",
+                      str_, (long)pid_, err_, strerror (err_));
+      }
+      else
+      {                // command completed, check exit status
+          if (WIFEXITED (status)) {
+              err_ = WEXITSTATUS (status);
+          }
+          else {       // command didn't complete with exit()
+              WSREP_ERROR("Process was aborted.");
+              err_ = errno ? errno : ECHILD;
+          }
+
+          if (err_) {
+              switch (err_) /* Translate error codes to more meaningful */
+              {
+              case 126: err_ = EACCES; break; /* Permission denied */
+              case 127: err_ = ENOENT; break; /* No such file or directory */
+              }
+              WSREP_ERROR("Process completed with error: %s: %d (%s)",
+                          str_, err_, strerror(err_));
+          }
+
+          pid_ = 0;
+          if (io_) fclose (io_);
+          io_ = NULL;
+      }
+  }
+  else {
+      assert (NULL == io_);
+      WSREP_ERROR("Command did not run: %s", str_);
+  }
+
+  return err_;
+}
+
+thd::thd () : init(), ptr(new THD)
+{
+  if (ptr)
+  {
+    ptr->thread_stack= (char*) &ptr;
+    ptr->store_globals();
+    ptr->options&= ~OPTION_BIN_LOG; // disable binlog
+    ptr->security_ctx->master_access= ~(ulong)0;
+    lex_start(ptr);
+  }
+}
+
+thd::~thd ()
+{
+  if (ptr)
+  {
+    delete ptr;
+    my_pthread_setspecific_ptr (THR_THD, 0);
+  }
+}
+
+} // namespace wsp
+
+extern ulong my_bind_addr;
+extern uint  mysqld_port;
+
+size_t default_ip (char* buf, size_t buf_len)
+{
+  size_t ip_len = 0;
+
+  if (htonl(INADDR_NONE) == my_bind_addr) {
+    WSREP_ERROR("Networking not configured, cannot receive state transfer.");
+    return 0;
+  }
+
+  if (htonl(INADDR_ANY) == my_bind_addr) {
+    // binds to all interfaces, try to find the address of the first one
+#if (TARGET_OS_LINUX == 1)
+    const char cmd[] = "/sbin/ifconfig | "
+        "grep -m1 -1 -E '^[a-z]?eth[0-9]' | tail -n 1 | "
+        "awk '{ print $2 }' | awk -F : '{ print $2 }'";
+#elif defined(__sun__)
+    const char cmd[] = "/sbin/ifconfig -a | "
+        "grep -m1 -1 -E 'net[0-9]:' | tail -n 1 | awk '{ print $2 }'";
+#else
+    char *cmd;
+#error "OS not supported"
+#endif
+    wsp::process proc (cmd, "r");
+
+    if (NULL != proc.pipe()) {
+      char* ret;
+
+      ret = fgets (buf, buf_len, proc.pipe());
+
+      if (proc.wait()) return 0;
+
+      if (NULL == ret) {
+        WSREP_ERROR("Failed to read output of: '%s'", cmd);
+        return 0;
+      }
+    }
+    else {
+      WSREP_ERROR("Failed to execute: '%s'", cmd);
+      return 0;
+    }
+
+    // clear possible \n at the end of ip string left by fgets()
+    ip_len = strlen (buf);
+    if (ip_len > 0 && '\n' == buf[ip_len - 1]) {
+      ip_len--;
+      buf[ip_len] = '\0';
+    }
+
+    if (INADDR_NONE == inet_addr(buf)) {
+      if (strlen(buf) != 0) {
+        WSREP_WARN("Shell command returned invalid address: '%s'", buf);
+      }
+      return 0;
+    }
+  }
+  else {
+    uint8_t* b = (uint8_t*)&my_bind_addr;
+    ip_len = snprintf (buf, buf_len,
+                       "%hhu.%hhu.%hhu.%hhu", b[0],b[1],b[2],b[3]);
+  }
+
+  return ip_len;
+}
+
+size_t default_address(char* buf, size_t buf_len)
+{
+  size_t addr_len = default_ip (buf, buf_len);
+
+  if (addr_len && addr_len < buf_len) {
+    addr_len += snprintf (buf + addr_len, buf_len - addr_len,
+                          ":%u", mysqld_port);
+  }
+
+  return addr_len;
+}

=== added file 'sql/wsrep_var.cc'
--- old/sql/wsrep_var.cc	1970-01-01 00:00:00 +0000
+++ new/sql/wsrep_var.cc	2012-01-15 05:44:01 +0000
@@ -0,0 +1,720 @@
+/* Copyright 2008 Codership Oy <http://www.codership.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA */
+
+#include "wsrep_priv.h"
+#include <my_dir.h>
+#include <cstdio>
+#include <cstdlib>
+
+// trx history position to start with
+static char  start_position[128]   = { 0, };
+const  char* wsrep_start_position = start_position;
+
+static char  provider[256]  = { 0, };
+const  char* wsrep_provider = provider;
+
+static char  provider_options[8192] = { 0, };
+const  char* wsrep_provider_options = provider_options;
+
+static char  cluster_address[256]  = { 0, };
+const  char* wsrep_cluster_address = cluster_address;
+
+static char  cluster_name[WSREP_MEMBER_NAME_LEN] = { 0, };
+const  char* wsrep_cluster_name = cluster_name;
+
+static char  node_address[256]  = { 0, };
+const  char* wsrep_node_address = node_address;
+
+static char  node_name[256] = { 0, };
+const  char* wsrep_node_name = node_name;
+
+int wsrep_init_vars()
+{
+  wsrep_start_position_default  (NULL, OPT_DEFAULT);
+  wsrep_provider_default        (NULL, OPT_DEFAULT);
+  wsrep_provider_options_default(NULL, OPT_DEFAULT);
+  wsrep_cluster_name_default    (NULL, OPT_DEFAULT);
+  wsrep_cluster_address_default (NULL, OPT_DEFAULT);
+  wsrep_node_name_default       (NULL, OPT_DEFAULT);
+  wsrep_node_address_default    (NULL, OPT_DEFAULT);
+  wsrep_sst_method_default      (NULL, OPT_DEFAULT);
+  wsrep_sst_receive_address_def (NULL, OPT_DEFAULT);
+  wsrep_sst_auth_default        (NULL, OPT_DEFAULT);
+  wsrep_sst_donor_default       (NULL, OPT_DEFAULT);
+
+  return 0;
+}
+
+void wsrep_on_update (THD* thd, enum_var_type var_type)
+{
+  if (var_type == OPT_GLOBAL) {
+    // FIXME: this variable probably should be changed only per session
+    thd->variables.wsrep_on = global_system_variables.wsrep_on;
+  }
+  else {
+  }
+
+  if (thd->variables.wsrep_on)
+    thd->options |= (OPTION_BIN_LOG);
+  else
+    thd->options &= ~(OPTION_BIN_LOG);
+}
+
+void wsrep_causal_reads_update (THD* thd, enum_var_type var_type)
+{
+  if (var_type == OPT_GLOBAL) {
+    thd->variables.wsrep_causal_reads = global_system_variables.wsrep_causal_reads;
+  }
+  else {
+  }
+}
+
+static int wsrep_start_position_verify (const char* start_str)
+{
+  size_t        start_len;
+  wsrep_uuid_t  uuid;
+  ssize_t       uuid_len;
+
+  start_len = strlen (start_str);
+  if (start_len < 34)
+    return 1;
+
+  uuid_len = wsrep_uuid_scan (start_str, start_len, &uuid);
+  if (uuid_len < 0 || (start_len - uuid_len) < 2)
+    return 1;
+
+  if (start_str[uuid_len] != ':') // separator should follow UUID
+    return 1;
+
+  char* endptr;
+  wsrep_seqno_t const seqno __attribute__((unused)) // to avoid GCC warnings
+    (strtoll(&start_str[uuid_len + 1], &endptr, 10));
+
+  if (*endptr == '\0') return 0; // remaining string was seqno
+
+  return 1;
+}
+
+int wsrep_start_position_check (THD* thd, set_var* var)
+{
+  char   buff[FN_REFLEN];
+  String str(buff, sizeof(buff), system_charset_info), *res;
+  const char*   start_str = NULL;
+
+  if (!(thd->security_ctx->master_access & SUPER_ACL)) {
+    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "SUPER");
+    return 1;
+  }
+
+  if (!(res = var->value->val_str(&str))) goto err;
+
+  start_str = res->c_ptr();
+
+  if (!start_str) goto err;
+
+  if (!wsrep_start_position_verify(start_str)) return 0;
+
+err:
+
+  my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), var->var->name, 
+           start_str ? start_str : "NULL");
+  return 1;
+}
+
+void wsrep_set_local_position (const char* value)
+{
+  size_t value_len  = strlen (value);
+  size_t uuid_len   = wsrep_uuid_scan (value, value_len, &local_uuid);
+
+  local_seqno = strtoll (value + uuid_len + 1, NULL, 10);
+  strncpy (start_position, value, sizeof(start_position) - 1);
+  sql_print_information ("WSREP: wsrep_start_position var submitted: '%s'",
+                         wsrep_start_position);
+}
+
+bool wsrep_start_position_update (THD* thd, set_var* var)
+{
+  // since this value passed wsrep_start_position_check, don't check anything
+  // here
+  const char* value = var->value->str_value.c_ptr();
+
+  wsrep_set_local_position (value);
+
+  if (wsrep) {
+    wsrep->sst_received (wsrep, &local_uuid, local_seqno, NULL, 0);
+  }
+
+  return 0;
+}
+
+void wsrep_start_position_default (THD* thd, enum_var_type var_type)
+{
+  static const char zero[] = "00000000-0000-0000-0000-000000000000:-1";
+  strncpy (start_position, zero, sizeof(zero));
+}
+
+void wsrep_start_position_init (const char* val)
+{
+  if (NULL == val || wsrep_start_position_verify (val))
+  {
+    sql_print_error ("WSREP: Bad initial value for wsrep_start_position: "
+                     "%s", (val ? val : ""));
+    return;
+  }
+
+  wsrep_set_local_position (val);
+}
+
+static int wsrep_provider_verify (const char* provider_str)
+{
+  MY_STAT   f_stat;
+  char path[FN_REFLEN];
+
+  if (!provider_str || strlen(provider_str)== 0)
+    return 1;
+
+  if (!strcmp(provider_str, WSREP_NONE))
+    return 0;
+
+  if (!unpack_filename(path, provider_str))
+    return 1;
+
+  /* check that provider file exists */
+  bzero(&f_stat, sizeof(MY_STAT));
+  if (!my_stat(path, &f_stat, MYF(0)))
+  {
+    return 1;
+  }
+  return 0;
+}
+
+int wsrep_provider_check (THD* thd, set_var* var)
+{
+  char   buff[FN_REFLEN];
+  String str(buff, sizeof(buff), system_charset_info), *res;
+  const char*   provider_str = NULL;
+
+  if (!(thd->security_ctx->master_access & SUPER_ACL)) {
+    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "SUPER");
+    return 1;
+  }
+
+  if (!(res = var->value->val_str(&str))) goto err;
+
+  provider_str = res->c_ptr();
+
+  if (!provider_str) goto err;
+
+  if (strcasecmp(provider_str, "none"))
+  {
+    if (global_system_variables.binlog_format != BINLOG_FORMAT_ROW)
+    {
+      char msg[256] = { 0, };
+      snprintf (msg, sizeof(msg) - 1, "wsrep replication with binlog_format "
+                "= '%s'. Please make sure it is 'ROW'. Globally.",
+                binlog_format_names[global_system_variables.binlog_format]);
+      my_error(ER_NOT_SUPPORTED_YET, MYF(0), msg);
+      return 1;
+    }
+  }
+
+  if (!wsrep_provider_verify(provider_str)) return 0;
+
+err:
+  my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), var->var->name, 
+           provider_str ? provider_str : "NULL");
+  return 1;
+}
+
+bool wsrep_provider_update (THD* thd, set_var* var)
+{
+  bool rcode= 0;
+  const char* value = var->value->str_value.c_ptr();
+
+  if (strcmp(value, provider)) {
+    /* provider has changed */
+
+    bool wsrep_on_saved= thd->variables.wsrep_on;
+    thd->variables.wsrep_on= false;
+
+    wsrep_stop_replication(thd);
+    wsrep_deinit();
+
+    memset(provider, '\0', sizeof(provider));
+    strncpy (provider, value, sizeof(provider) - 1);
+
+    char* tmp= strdup(provider); // wsrep_init() rewrites provider when fails
+    if (wsrep_init())
+    {
+      my_error(ER_CANT_OPEN_LIBRARY, MYF(0), tmp);
+      rcode= 1;
+    }
+    free(tmp);
+
+    // we sure don't want to use old address with new provider
+    cluster_address[0]='\0';
+
+#if 0 /* don't start replication until new address is set */
+    if (wsrep_start_replication())
+    {
+      wsrep_create_rollbacker();
+      wsrep_create_appliers();
+    }
+#endif
+    thd->variables.wsrep_on= wsrep_on_saved;
+  }
+
+  return rcode;
+}
+
+void wsrep_provider_default (THD* thd, enum_var_type var_type)
+{
+  memset(provider, '\0', sizeof(provider));
+  strncpy (provider, WSREP_NONE, sizeof(provider) - 1);
+}
+
+void wsrep_provider_init (const char* value)
+{
+  if (NULL == value || wsrep_provider_verify (value))
+  {
+    WSREP_ERROR("Bad initial value for wsrep_provider: %s",
+                (value ? value : ""));
+    return;
+  }
+
+  memset(provider, '\0', sizeof(provider));
+  strncpy (provider, value, sizeof(provider) - 1);
+}
+
+int wsrep_provider_options_check(THD* thd, set_var* var)
+{
+  if (!(thd->security_ctx->master_access & SUPER_ACL)) {
+    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "SUPER");
+    return 1;
+  }
+  return 0;
+}
+
+bool wsrep_provider_options_update(THD* thd, set_var* var)
+{
+  const char* value= var->value->str_value.c_ptr();
+  wsrep_status_t ret= wsrep->options_set(wsrep, value);
+  if (ret != WSREP_OK)
+  {
+    sql_print_error("WSREP: Set options returned %d", ret);
+    return 1;
+  }
+  else
+  {
+    char* opts= wsrep->options_get(wsrep);
+    if (opts)
+    {
+      strncpy(provider_options, opts, sizeof(provider_options));
+      provider_options[sizeof(provider_options) - 1]= '\0';
+      free(opts);
+    }
+    else
+    {
+      sql_print_error("WSREP: Failed to get provider options");
+      return 1;
+    }
+  }
+  return 0;
+}
+
+void wsrep_provider_options_default(THD* thd, enum_var_type var_type)
+{
+  memset(provider_options, '\0', sizeof(provider_options));
+}
+
+void wsrep_provider_options_init(const char* value)
+{
+  if (NULL == value)
+  {
+    sql_print_error ("WSREP: Bad initial value for wsrep_provider_options: "
+                     "%s", (value ? value : ""));
+    return;
+  }
+  memset(provider_options, '\0', sizeof(provider_options));
+  strncpy(provider_options, value, sizeof(provider_options) - 1);
+}
+
+static int wsrep_cluster_address_verify (const char* cluster_address_str)
+{
+  /* There is no predefined address format, it depends on provider. */
+  return 0;
+}
+
+int wsrep_cluster_address_check (THD* thd, set_var* var)
+{
+  char   buff[FN_REFLEN];
+  String str(buff, sizeof(buff), system_charset_info), *res;
+  const char*   cluster_address_str = NULL;
+
+  if (!(thd->security_ctx->master_access & SUPER_ACL)) {
+    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "SUPER");
+    return 1;
+  }
+
+  if (!(res = var->value->val_str(&str))) goto err;
+
+  cluster_address_str = res->c_ptr();
+
+  if (!cluster_address_str) goto err;
+
+  if (!wsrep_cluster_address_verify(cluster_address_str)) return 0;
+
+ err:
+
+  my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), var->var->name, 
+             cluster_address_str ? cluster_address_str : "NULL");
+  return 1;
+}
+
+bool wsrep_cluster_address_update (THD* thd, set_var* var)
+{
+  const char* value = var->value->str_value.c_ptr();
+
+  bool wsrep_on_saved= thd->variables.wsrep_on;
+  thd->variables.wsrep_on= false;
+
+  wsrep_stop_replication(thd);
+
+  memset(cluster_address, '\0', sizeof(cluster_address));
+  strncpy(cluster_address, value, sizeof(cluster_address) - 1);
+
+  if (wsrep_start_replication())
+  {
+    wsrep_create_rollbacker();
+    wsrep_create_appliers();
+  }
+  thd->variables.wsrep_on= wsrep_on_saved;
+
+  return 0;
+}
+
+void wsrep_cluster_address_default (THD* thd, enum_var_type var_type)
+{
+  memset(cluster_address, '\0', sizeof(cluster_address));
+}
+
+void wsrep_cluster_address_init (const char* value)
+{
+  if (NULL == value || wsrep_cluster_address_verify (value))
+  {
+    sql_print_error ("WSREP: Bad initial value for wsrep_cluster_address: "
+                     "%s", (value ? value : ""));
+    return;
+  }
+
+  memset(cluster_address, '\0', sizeof(cluster_address));
+  strncpy (cluster_address, value, sizeof(cluster_address) - 1);
+}
+
+static bool cluster_name_verify (const char* val)
+{
+    return (strlen(val) < (sizeof(cluster_name) - 1));
+}
+
+int wsrep_cluster_name_check (THD* thd, set_var* var)
+{
+  char   buff[FN_REFLEN];
+  String str(buff, sizeof(buff), system_charset_info), *res;
+  const char* cluster_name_str = NULL;
+
+  if (!(thd->security_ctx->master_access & SUPER_ACL)) {
+    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "SUPER");
+    return 1;
+  }
+
+  if (!(res = var->value->val_str(&str))) goto err;
+
+  cluster_name_str = res->c_ptr();
+
+  if (!cluster_name_str) goto err;
+
+  if (cluster_name_verify(cluster_name_str)) return 0;
+
+ err:
+
+  my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), var->var->name, 
+             cluster_name_str ? cluster_name_str : "NULL");
+  return 1;
+}
+
+bool wsrep_cluster_name_update (THD* thd, set_var* var)
+{
+  const char* value = var->value->str_value.c_ptr();
+
+  memset(cluster_name, '\0', sizeof(cluster_name));
+  strncpy(cluster_name, value, sizeof(cluster_name) - 1);
+
+  return 0;
+}
+
+void wsrep_cluster_name_default (THD* thd, enum_var_type var_type)
+{
+  memset(cluster_name, '\0', sizeof(cluster_name));
+  strncpy(cluster_name, "my_wsrep_cluster", sizeof(cluster_name) - 1);
+}
+
+void wsrep_cluster_name_init (const char* value)
+{
+  if (NULL == value || !cluster_name_verify (value))
+  {
+    sql_print_error ("WSREP: Bad initial value for wsrep_cluster_name: "
+                     "%s", (value ? value : ""));
+    return;
+  }
+
+  memset(cluster_name, '\0', sizeof(cluster_name));
+  strncpy (cluster_name, value, sizeof(cluster_name) - 1);
+}
+
+static bool node_name_verify (const char* val)
+{
+  return (strlen(val) < (sizeof(node_name)));
+}
+
+int wsrep_node_name_check (THD* thd, set_var* var)
+{
+  char   buff[FN_REFLEN];
+  String str(buff, sizeof(buff), system_charset_info), *res;
+  const char* node_name_str = NULL;
+
+  if (!(thd->security_ctx->master_access & SUPER_ACL)) {
+    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "SUPER");
+    return 1;
+  }
+
+  if (!(res = var->value->val_str(&str))) goto err;
+
+  node_name_str = res->c_ptr();
+
+  if (!node_name_str) goto err;
+
+  if (node_name_verify(node_name_str)) return 0;
+
+ err:
+
+  my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), var->var->name, 
+             node_name_str ? node_name_str : "NULL");
+  return 1;
+}
+
+bool wsrep_node_name_update (THD* thd, set_var* var)
+{
+  const char* value = var->value->str_value.c_ptr();
+
+  if (node_name_verify (value))
+  {
+    memset(node_name, '\0', sizeof(node_name));
+    strncpy(node_name, value, sizeof(node_name) - 1);
+    return 0;
+  }
+
+  return 1;
+}
+
+void wsrep_node_name_default (THD* thd, enum_var_type var_type)
+{
+  memset(node_name, '\0', sizeof(node_name));
+
+  if (gethostname(node_name, sizeof(node_name) - 1) < 0)
+  {
+    if (ENAMETOOLONG == errno)
+    {
+      WSREP_WARN("Truncated hostname to %zu bytes", sizeof(node_name) - 1);
+    }
+    else
+    {
+      strmake(node_name, STRING_WITH_LEN("localhost"));
+      WSREP_WARN("gethostname failed: %d (%s), using '%s' as default "
+                 "wsrep_node_name", errno, strerror(errno), node_name);
+    }
+  }
+}
+
+void wsrep_node_name_init (const char* value)
+{
+  if (NULL == value || !node_name_verify (value))
+  {
+    sql_print_error ("WSREP: Bad initial value for wsrep_node_name: "
+                     "%s", (value ? value : ""));
+    return;
+  }
+
+  memset(node_name, '\0', sizeof(node_name));
+  strncpy (node_name, value, sizeof(node_name) - 1);
+}
+
+static bool node_address_verify (const char* val)
+{
+    // TODO: something more elaborate can be done here, like address resolution
+    return (strlen(val) < sizeof(node_address)                 &&
+            strncasecmp(val, "127.0.0.1", strlen("127.0.0.1")) &&
+            strncasecmp(val, "localhost", strlen("localhost")));
+}
+
+int wsrep_node_address_check (THD* thd, set_var* var)
+{
+  char   buff[FN_REFLEN];
+  String str(buff, sizeof(buff), system_charset_info), *res;
+  const char* node_address_str = NULL;
+
+  if (!(thd->security_ctx->master_access & SUPER_ACL)) {
+    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), "SUPER");
+    return 1;
+  }
+
+  if (!(res = var->value->val_str(&str))) goto err;
+
+  node_address_str = res->c_ptr();
+
+  if (!node_address_str) goto err;
+
+  if (node_address_verify(node_address_str)) return 0;
+
+ err:
+
+  my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), var->var->name, 
+             node_address_str ? node_address_str : "NULL");
+  return 1;
+}
+
+bool wsrep_node_address_update (THD* thd, set_var* var)
+{
+  const char* value = var->value->str_value.c_ptr();
+
+  if (node_address_verify (value))
+  {
+    memset(node_address, '\0', sizeof(node_address));
+    strncpy(node_address, value, sizeof(node_address) - 1);
+    return 0;
+  }
+
+  return 1;
+}
+
+void wsrep_node_address_default (THD* thd, enum_var_type var_type)
+{
+  int ret= default_ip (node_address, sizeof(node_address));
+
+  if (ret <= 0)
+  {
+    WSREP_WARN("Failed to guess the value of wsrep_node_address variable."
+               "You need to set it explicitly.");
+    memset(node_address, '\0', sizeof(node_address));
+  }
+}
+
+void wsrep_node_address_init (const char* value)
+{
+  if (NULL == value || !node_address_verify (value))
+  {
+    sql_print_error ("WSREP: Bad initial value for wsrep_node_address: "
+                     "%s", (value ? value : ""));
+    return;
+  }
+
+  memset(node_address, '\0', sizeof(node_address));
+  strncpy (node_address, value, sizeof(node_address) - 1);
+}
+
+
+/*
+ * Status variables stuff below
+ */
+static inline void
+wsrep_assign_to_mysql (SHOW_VAR* mysql, wsrep_stats_var* wsrep)
+{
+  mysql->name = wsrep->name;
+  switch (wsrep->type) {
+  case WSREP_VAR_INT64:
+    mysql->value = (char*) &wsrep->value._int64;
+    mysql->type  = SHOW_LONGLONG;
+    break;
+  case WSREP_VAR_STRING:
+    mysql->value = (char*) &wsrep->value._string;
+    mysql->type  = SHOW_CHAR_PTR;
+    break;
+  case WSREP_VAR_DOUBLE:
+    mysql->value = (char*) &wsrep->value._double;
+    mysql->type  = SHOW_DOUBLE;
+    break;
+  }
+}
+
+static wsrep_stats_var*  wsrep_status_vars = NULL;
+
+#if DYNAMIC
+// somehow this mysql status thing works only with statically allocated arrays.
+static SHOW_VAR*          mysql_status_vars = NULL;
+static int                mysql_status_len  = -1;
+#else
+static SHOW_VAR           mysql_status_vars[100 + 1];
+static const int          mysql_status_len  = 100;
+#endif
+
+static void export_wsrep_status_to_mysql()
+{
+  int wsrep_status_len, i;
+
+  if (wsrep_status_vars) wsrep->stats_free (wsrep, wsrep_status_vars);
+
+  wsrep_status_vars = wsrep->stats_get (wsrep);
+
+  if (!wsrep_status_vars) {
+    return;
+  }
+
+  for (wsrep_status_len = 0;
+       wsrep_status_vars[wsrep_status_len].name != NULL;
+       wsrep_status_len++);
+
+#if DYNAMIC
+  if (wsrep_status_len != mysql_status_len) {
+    void* tmp = realloc (mysql_status_vars,
+                         (wsrep_status_len + 1) * sizeof(SHOW_VAR));
+    if (!tmp) {
+
+      sql_print_error ("Out of memory for wsrep status variables."
+                       "Number of variables: %d", wsrep_status_len);
+      return;
+    }
+
+    mysql_status_len  = wsrep_status_len;
+    mysql_status_vars = (SHOW_VAR*)tmp;
+  }
+  /* @TODO: fix this: */
+#else
+  if (mysql_status_len < wsrep_status_len) wsrep_status_len= mysql_status_len;
+#endif
+
+  for (i = 0; i < wsrep_status_len; i++)
+    wsrep_assign_to_mysql (mysql_status_vars + i, wsrep_status_vars + i);
+
+  mysql_status_vars[wsrep_status_len].name  = NullS;
+  mysql_status_vars[wsrep_status_len].value = NullS;
+  mysql_status_vars[wsrep_status_len].type  = SHOW_LONG;
+}
+
+int wsrep_show_status (THD *thd, SHOW_VAR *var, char *buff)
+{
+  export_wsrep_status_to_mysql();
+  var->type= SHOW_ARRAY;
+  var->value= (char *) &mysql_status_vars;
+  return 0;
+}

=== modified file 'storage/innobase/Makefile.am'
--- old/storage/innobase/Makefile.am	2010-07-09 11:37:51 +0000
+++ new/storage/innobase/Makefile.am	2011-05-23 11:17:44 +0000
@@ -24,9 +24,9 @@
 			-I$(top_srcdir)/regex \
 			-I$(top_srcdir)/storage/innobase/include \
 			-I$(top_srcdir)/sql \
-			-I$(srcdir)
+			-I$(srcdir) @WSREP_INCLUDES@
 
-DEFS=			@DEFS@
+DEFS=			-DMYSQL_SERVER @DEFS@ @INNODB_DEFS@
 
 
 noinst_HEADERS=		include/btr0btr.h include/btr0btr.ic		\

=== modified file 'storage/innobase/handler/ha_innodb.cc'
--- old/storage/innobase/handler/ha_innodb.cc	2012-02-06 10:44:59 +0000
+++ new/storage/innobase/handler/ha_innodb.cc	2012-04-19 19:26:55 +0000
@@ -37,9 +37,26 @@
 #include <myisampack.h>
 #include <mysys_err.h>
 #include <my_sys.h>
+
 #include "ha_innodb.h"
 #include <mysql/plugin.h>
 
+#ifdef WITH_WSREP
+#include "wsrep_mysqld.h"
+#include <my_md5.h>
+#include <sql_common.h>
+class binlog_trx_data;
+extern handlerton *binlog_hton;
+extern wsrep_t *wsrep;
+
+extern bool wsrep_prepare_key_for_innodb(const uchar *cache_key,
+					 size_t cache_key_len,
+                                         const uchar* row_id,
+                                         size_t row_id_len,
+                                         wsrep_key_part_t* key,
+                                         size_t* key_len);
+#endif
+
 /** to protect innobase_open_files */
 static pthread_mutex_t innobase_share_mutex;
 /** to force correct commit order in binlog */
@@ -86,8 +103,30 @@
 #include "../storage/innobase/include/trx0xa.h"
 #include "../storage/innobase/include/thr0loc.h"
 #include "../storage/innobase/include/ha_prototypes.h"
+
+#ifdef WITH_WSREP
+#include "../storage/innobase/include/ut0byte.h"
+#ifndef EXTRA_DEBUG
+#include "../storage/innobase/include/ut0byte.ic"
+#endif
+#ifdef REMOVED
+enum wsrep_trx_status {
+    WSREP_TRX_OK,
+    WSREP_TRX_ROLLBACK,
+    WSREP_TRX_ERROR,
+  };
+enum wsrep_trx_status
+wsrep_run_wsrep_commit(THD *thd, handlerton *hton, bool all);
+#endif
+static inline wsrep_trx_handle_t*
+wsrep_trx_handle(THD* thd, const trx_t* trx) {
+    return wsrep_trx_handle_for_id(
+        &thd->wsrep_trx_handle, 
+        (wsrep_trx_id_t)ut_conv_dulint_to_longlong(trx->id));
 }
+#endif /* WITH_WSREP */
 
+}
 static const long AUTOINC_OLD_STYLE_LOCKING = 0;
 static const long AUTOINC_NEW_STYLE_LOCKING = 1;
 static const long AUTOINC_NO_LOCKING = 2;
@@ -529,7 +568,6 @@
 
 		return;
 	}
-
 	srv_conc_enter_innodb(trx);
 }
 
@@ -611,7 +649,13 @@
 {
 	return((trx_t*) thd_get_ha_data(thd, innodb_hton_ptr));
 }
-
+#ifdef WITH_WSREP
+ulonglong thd_to_trx_id(THD *thd)
+{
+	return ((wsrep_trx_id_t) ut_conv_dulint_to_longlong(
+		(*(trx_t**) thd_ha_data(thd, innodb_hton_ptr))->id));
+}
+#endif
 /************************************************************************
 Call this function when mysqld passes control to the client. That is to
 avoid deadlocks on the adaptive hash S-latch possibly held by thd. For more
@@ -641,6 +685,11 @@
 	return 0;
 }
 
+#ifdef WITH_WSREP
+static int 
+wsrep_abort_transaction(handlerton* hton, THD *bf_thd, THD *victim_thd, 
+			my_bool signal);
+#endif
 /************************************************************************
 Increments innobase_active_counter and every INNOBASE_WAKE_INTERVALth
 time calls srv_active_wake_master_thread. This function should be used
@@ -979,6 +1028,9 @@
 innobase_mysql_tmpfile(void)
 /*========================*/
 {
+#ifdef WITH_INNODB_DISALLOW_WRITES
+	os_event_wait(srv_allow_writes_event);
+#endif /* WITH_INNODB_DISALLOW_WRITES */
 	int	fd;				/* handle of opened file */
 	HANDLE	osfh;				/* OS handle of opened file */
 	char*	tmpdir;				/* point to the directory
@@ -1804,6 +1856,9 @@
         innobase_hton->show_status=innobase_show_status;
         innobase_hton->flags=HTON_NO_FLAGS;
         innobase_hton->release_temporary_latches=innobase_release_temporary_latches;
+#ifdef WITH_WSREP
+        innobase_hton->wsrep_abort_transaction=wsrep_abort_transaction;
+#endif /* WITH_WSREP */
 
 	ut_a(DATA_MYSQL_TRUE_VARCHAR == (ulint)MYSQL_TYPE_VARCHAR);
 
@@ -2169,7 +2224,6 @@
 
 	DBUG_RETURN(0);
 }
-
 /*********************************************************************
 Commits a transaction in an InnoDB database or marks an SQL statement
 ended. */
@@ -2224,7 +2278,6 @@
 	}
 	if (all
 		|| (!thd_test_options(thd, OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN))) {
-
 		/* We were instructed to commit the whole transaction, or
 		this is an SQL statement end and autocommit is on */
 
@@ -2260,16 +2313,17 @@
 			pthread_mutex_unlock(&commit_cond_m);
 		}
 
+#ifndef WITH_WSREP
 		if (trx->active_trans == 2) {
-
 			pthread_mutex_unlock(&prepare_commit_mutex);
 		}
+#endif
 
 		trx->active_trans = 0;
 
 	} else {
-		/* We just mark the SQL statement ended and do not do a
-		transaction commit */
+                /* We just mark the SQL statement ended and do not do a
+                transaction commit */
 
 		/* If we had reserved the auto-inc lock for some
 		table in this SQL statement we release it now */
@@ -2344,7 +2398,6 @@
 	} else {
 		error = trx_rollback_last_sql_stat_for_mysql(trx);
 	}
-
 	DBUG_RETURN(convert_error_code_to_mysql(error, NULL));
 }
 
@@ -3339,6 +3392,95 @@
 
 	return(0);
 }
+#ifdef WITH_WSREP
+void
+wsrep_innobase_mysql_sort(
+/*===============*/
+					/* out: str contains sort string */
+	int		mysql_type,	/* in: MySQL type */
+	uint		charset_number,	/* in: number of the charset */
+	unsigned char*	str,		/* in: data field */
+	unsigned int	str_length)	/* in: data field length,
+					not UNIV_SQL_NULL */
+{
+	CHARSET_INFO*		charset;
+	enum_field_types	mysql_tp;
+
+	DBUG_ASSERT(str_length != UNIV_SQL_NULL);
+
+	mysql_tp = (enum_field_types) mysql_type;
+
+	switch (mysql_tp) {
+
+	case MYSQL_TYPE_BIT:
+	case MYSQL_TYPE_STRING:
+	case MYSQL_TYPE_VAR_STRING:
+	case MYSQL_TYPE_TINY_BLOB:
+	case MYSQL_TYPE_MEDIUM_BLOB:
+	case MYSQL_TYPE_BLOB:
+	case MYSQL_TYPE_LONG_BLOB:
+	case MYSQL_TYPE_VARCHAR:
+	{
+		uchar tmp_str[DICT_MAX_INDEX_COL_LEN];
+		uint tmp_length = DICT_MAX_INDEX_COL_LEN;
+
+		/* Use the charset number to pick the right charset struct for
+		the comparison. Since the MySQL function get_charset may be
+		slow before Bar removes the mutex operation there, we first
+		look at 2 common charsets directly. */
+
+		if (charset_number == default_charset_info->number) {
+			charset = default_charset_info;
+		} else if (charset_number == my_charset_latin1.number) {
+			charset = &my_charset_latin1;
+		} else {
+			charset = get_charset(charset_number, MYF(MY_WME));
+
+			if (charset == NULL) {
+			  sql_print_error("InnoDB needs charset %lu for doing "
+					  "a comparison, but MySQL cannot "
+					  "find that charset.",
+					  (ulong) charset_number);
+				ut_a(0);
+			}
+		}
+
+		ut_a(str_length <= tmp_length);
+		memcpy(tmp_str, str, str_length);
+
+		tmp_length = charset->coll->strnxfrm(charset, str, str_length,
+						     tmp_str, tmp_length);
+		DBUG_ASSERT(tmp_length == str_length);
+ 
+		break;
+	}
+	case MYSQL_TYPE_DECIMAL :
+	case MYSQL_TYPE_TINY :
+	case MYSQL_TYPE_SHORT :
+	case MYSQL_TYPE_LONG :
+	case MYSQL_TYPE_FLOAT :
+	case MYSQL_TYPE_DOUBLE :
+	case MYSQL_TYPE_NULL :
+	case MYSQL_TYPE_TIMESTAMP :
+	case MYSQL_TYPE_LONGLONG :
+	case MYSQL_TYPE_INT24 :
+	case MYSQL_TYPE_DATE :
+	case MYSQL_TYPE_TIME :
+	case MYSQL_TYPE_DATETIME :
+	case MYSQL_TYPE_YEAR :
+	case MYSQL_TYPE_NEWDATE :
+	case MYSQL_TYPE_NEWDECIMAL :
+	case MYSQL_TYPE_ENUM :
+	case MYSQL_TYPE_SET :
+	case MYSQL_TYPE_GEOMETRY :
+		break;
+	default:
+		break;
+	}
+
+	return;
+}
+#endif // WITH_WSREP
 }
 
 /******************************************************************
@@ -3480,7 +3622,260 @@
 
 /***********************************************************************
 Stores a key value for a row to a buffer. */
+#ifdef WITH_WSREP
+uint
+wsrep_store_key_val_for_row(
+/*===============================*/
+	TABLE		*table,
+				/* out: key value length as stored in buff */
+	uint		keynr,	/* in: key number */
+	uchar*		buff,	/* in/out: buffer for the key value (in MySQL
+				format) */
+	uint		buff_len,/* in: buffer length */
+	const uchar*	record,  /* in: row in MySQL format */
+	ibool*          key_is_null)/*!< out: full key was null */
+{
+	KEY*		key_info	= table->key_info + keynr;
+	KEY_PART_INFO*	key_part	= key_info->key_part;
+	KEY_PART_INFO*	end		= key_part + key_info->key_parts;
+	uchar*		buff_start	= buff;
+	enum_field_types mysql_type;
+	Field*		field;
+
+	DBUG_ENTER("wsrep_store_key_val_for_row");
+
+	bzero(buff, buff_len);
+	*key_is_null = TRUE;
+
+	for (; key_part != end; key_part++) {
+		uchar sorted[DICT_MAX_INDEX_COL_LEN] = {'\0'};
+		ibool part_is_null = FALSE;
 
+		if (key_part->null_bit) {
+			if (record[key_part->null_offset] &
+			    key_part->null_bit) {
+				*buff = 1;
+				part_is_null = TRUE;
+			} else {
+				*buff = 0;
+			}
+			buff++;
+		}
+		if (!part_is_null)  *key_is_null = FALSE;
+
+		field = key_part->field;
+		mysql_type = field->type();
+
+		if (mysql_type == MYSQL_TYPE_VARCHAR) {
+						/* >= 5.0.3 true VARCHAR */
+			ulint	lenlen;
+			ulint	len;
+			byte*	data;
+			ulint	key_len;
+			ulint	true_len;
+			CHARSET_INFO*	cs;
+			int	error=0;
+
+			key_len = key_part->length;
+
+			if (part_is_null) {
+				buff += key_len + 2;
+
+				continue;
+			}
+			cs = field->charset();
+
+			lenlen = (ulint)
+				(((Field_varstring*)field)->length_bytes);
+
+			data = row_mysql_read_true_varchar(&len,
+				(byte*) (record
+				+ (ulint)get_field_offset(table, field)),
+				lenlen);
+
+			true_len = len;
+
+			/* For multi byte character sets we need to calculate
+			the true length of the key */
+
+			if (len > 0 && cs->mbmaxlen > 1) {
+				true_len = (ulint) cs->cset->well_formed_len(cs,
+						(const char *) data,
+						(const char *) data + len,
+                                                (uint) (key_len /
+                                                        cs->mbmaxlen),
+						&error);
+			}
+
+			/* In a column prefix index, we may need to truncate
+			the stored value: */
+
+			if (true_len > key_len) {
+				true_len = key_len;
+			}
+			ut_a(true_len <= DICT_MAX_INDEX_COL_LEN);
+
+			memcpy(sorted, data, true_len);
+			wsrep_innobase_mysql_sort(
+			       mysql_type, cs->number, sorted, true_len);
+
+			memcpy(buff, sorted, true_len);
+
+			/* Note that we always reserve the maximum possible
+			length of the true VARCHAR in the key value, though
+			only len first bytes after the 2 length bytes contain
+			actual data. The rest of the space was reset to zero
+			in the bzero() call above. */
+
+			buff += key_len;
+
+		} else if (mysql_type == MYSQL_TYPE_TINY_BLOB
+			|| mysql_type == MYSQL_TYPE_MEDIUM_BLOB
+			|| mysql_type == MYSQL_TYPE_BLOB
+			|| mysql_type == MYSQL_TYPE_LONG_BLOB
+			/* MYSQL_TYPE_GEOMETRY data is treated
+			as BLOB data in innodb. */
+			|| mysql_type == MYSQL_TYPE_GEOMETRY) {
+
+			CHARSET_INFO*	cs;
+			ulint		key_len;
+			ulint		true_len;
+			int		error=0;
+			ulint		blob_len;
+			byte*		blob_data;
+
+			ut_a(key_part->key_part_flag & HA_PART_KEY_SEG);
+
+			key_len = key_part->length;
+
+			if (part_is_null) {
+				buff += key_len + 2;
+
+				continue;
+			}
+
+			cs = field->charset();
+
+			blob_data = row_mysql_read_blob_ref(&blob_len,
+				(byte*) (record
+				+ (ulint)get_field_offset(table, field)),
+					(ulint) field->pack_length());
+
+			true_len = blob_len;
+
+			ut_a(get_field_offset(table, field)
+				== key_part->offset);
+
+			/* For multi byte character sets we need to calculate
+			the true length of the key */
+
+			if (blob_len > 0 && cs->mbmaxlen > 1) {
+				true_len = (ulint) cs->cset->well_formed_len(cs,
+						(const char *) blob_data,
+						(const char *) blob_data
+							+ blob_len,
+                                                (uint) (key_len /
+                                                        cs->mbmaxlen),
+						&error);
+			}
+
+			/* All indexes on BLOB and TEXT are column prefix
+			indexes, and we may need to truncate the data to be
+			stored in the key value: */
+
+			if (true_len > key_len) {
+				true_len = key_len;
+			}
+
+			memcpy(sorted, blob_data, true_len);
+			wsrep_innobase_mysql_sort(
+			       mysql_type, cs->number, sorted, true_len);
+
+			memcpy(buff, sorted, true_len);
+
+			/* Note that we always reserve the maximum possible
+			length of the BLOB prefix in the key value. */
+
+			buff += key_len;
+		} else {
+			/* Here we handle all other data types except the
+			true VARCHAR, BLOB and TEXT. Note that the column
+			value we store may be also in a column prefix
+			index. */
+
+			CHARSET_INFO*		cs;
+			ulint			true_len;
+			ulint			key_len;
+			const uchar*		src_start;
+			int			error=0;
+			enum_field_types	real_type;
+
+			key_len = key_part->length;
+
+			if (part_is_null) {
+				 buff += key_len;
+
+				 continue;
+			}
+
+			src_start = record + key_part->offset;
+			real_type = field->real_type();
+			true_len = key_len;
+
+			/* Character set for the field is defined only
+			to fields whose type is string and real field
+			type is not enum or set. For these fields check
+			if character set is multi byte. */
+
+			if (real_type != MYSQL_TYPE_ENUM
+				&& real_type != MYSQL_TYPE_SET
+				&& ( mysql_type == MYSQL_TYPE_VAR_STRING
+					|| mysql_type == MYSQL_TYPE_STRING)) {
+
+				cs = field->charset();
+
+				/* For multi byte character sets we need to
+				calculate the true length of the key */
+
+				if (key_len > 0 && cs->mbmaxlen > 1) {
+
+					true_len = (ulint)
+						cs->cset->well_formed_len(cs,
+							(const char *)src_start,
+							(const char *)src_start
+								+ key_len,
+                                                        (uint) (key_len /
+                                                                cs->mbmaxlen),
+							&error);
+				}
+				memcpy(sorted, src_start, true_len);
+				wsrep_innobase_mysql_sort(
+					mysql_type, cs->number, sorted, true_len);
+				memcpy(buff, sorted, true_len);
+			} else  {
+				memcpy(buff, src_start, true_len);
+			}
+			buff += true_len;
+
+			/* Pad the unused space with spaces. Note that no
+			padding is ever needed for UCS-2 because in MySQL,
+			all UCS2 characters are 2 bytes, as MySQL does not
+			support surrogate pairs, which are needed to represent
+			characters in the range U+10000 to U+10FFFF. */
+
+			if (true_len < key_len) {
+				ulint pad_len = key_len - true_len;
+				memset(buff, ' ', pad_len);
+				buff += pad_len;
+			}
+		}
+	}
+
+	ut_a(buff <= buff_start + buff_len);
+
+	DBUG_RETURN((uint)(buff - buff_start));
+}
+#endif /* WITH_WSREP */
 uint
 ha_innobase::store_key_val_for_row(
 /*===============================*/
@@ -4090,6 +4485,9 @@
 	ulint		error = 0;
         int             error_result= 0;
 	ibool		auto_inc_used= FALSE;
+#ifdef WITH_WSREP
+	ibool           auto_inc_inserted= FALSE; /* if NULL was inserted */
+#endif
 	ulint		sql_command;
 	trx_t*		trx = thd_to_trx(user_thd);
 
@@ -4120,8 +4518,14 @@
 	if ((sql_command == SQLCOM_ALTER_TABLE
 	     || sql_command == SQLCOM_OPTIMIZE
 	     || sql_command == SQLCOM_CREATE_INDEX
+#ifdef WITH_WSREP
+	     || sql_command == SQLCOM_LOAD
+#endif /* WITH_WSREP */
 	     || sql_command == SQLCOM_DROP_INDEX)
 	    && num_write_row >= 10000) {
+#ifdef WITH_WSREP
+		WSREP_DEBUG("forced commit: %s", user_thd->query());
+#endif /* WITH_WSREP */
 		/* ALTER TABLE is COMMITted at every 10000 copied rows.
 		The IX table lock for the original table has to be re-issued.
 		As this method will be called on a temporary table where the
@@ -4193,7 +4597,9 @@
 		/* Reset the error code before calling
 		innobase_get_auto_increment(). */
 		prebuilt->autoinc_error = DB_SUCCESS;
-
+#ifdef WITH_WSREP
+		auto_inc_inserted= (table->next_number_field->val_int() == 0);
+#endif
 		if ((error = update_auto_increment())) {
 			/* We don't want to mask autoinc overflow errors. */
 
@@ -4274,6 +4680,26 @@
 				goto set_max_autoinc;
 				break;
 
+#ifdef WITH_WSREP
+			/* workaround for LP bug #355000, retrying the insert */
+			case SQLCOM_INSERT:
+				if (auto_inc_inserted &&
+				    wsrep_drupal_282555_workaround &&
+				    !thd_test_options(current_thd, 
+				     OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN)) {
+ 					WSREP_DEBUG("retrying insert: %s",
+						(current_thd->query()) ? 
+						current_thd->query() : "void");
+					error= DB_SUCCESS;
+					(current_thd)->wsrep_conflict_state= 
+						MUST_ABORT;
+                                        innodb_srv_conc_exit_innodb(prebuilt->trx);
+                                        /* jump straight to func exit over
+                                         * later wsrep hooks */
+                                        goto func_exit;
+				}
+                                break;
+#endif
 			default:
 				break;
 			}
@@ -4319,7 +4745,19 @@
 
 report_error:
 	error_result = convert_error_code_to_mysql((int) error, user_thd);
-
+#ifdef WITH_WSREP
+	if (!error_result && user_thd->wsrep_exec_mode == LOCAL_STATE &&
+	    user_thd->variables.wsrep_on && (sql_command != SQLCOM_LOAD ||
+	    thd_binlog_format(user_thd) == BINLOG_FORMAT_ROW)) {
+
+		if (wsrep_append_keys(user_thd, false, record, NULL)) {
+			DBUG_PRINT("wsrep", ("row key failed"));
+			error_result = HA_ERR_INTERNAL_ERROR;
+			goto wsrep_error;
+		}
+	}
+wsrep_error:
+#endif
 func_exit:
 	innobase_active_small();
 
@@ -4588,6 +5026,19 @@
 
 	innobase_active_small();
 
+#ifdef WITH_WSREP
+	if (!error && user_thd->wsrep_exec_mode == LOCAL_STATE &&
+            user_thd->variables.wsrep_on) {
+		DBUG_PRINT("wsrep", ("update row key"));
+
+		if (wsrep_append_keys(user_thd, false, old_row, new_row)) {
+			DBUG_PRINT("wsrep", ("row key failed"));
+			error = HA_ERR_INTERNAL_ERROR;
+			goto wsrep_error;
+		}
+	}
+wsrep_error:
+#endif
 	DBUG_RETURN(error);
 }
 
@@ -4630,6 +5081,18 @@
 
 	innobase_active_small();
 
+#ifdef WITH_WSREP
+	if (!error && user_thd->wsrep_exec_mode == LOCAL_STATE &&
+            user_thd->variables.wsrep_on) {
+		DBUG_PRINT("wsrep", ("delete row key"));
+		if (wsrep_append_keys(user_thd, false, record, NULL)) {
+			DBUG_PRINT("wsrep", ("delete fail"));
+			error = HA_ERR_INTERNAL_ERROR;
+			goto wsrep_error;
+		}
+	}
+wsrep_error:
+#endif
 	DBUG_RETURN(error);
 }
 
@@ -5340,7 +5803,236 @@
 
 	DBUG_RETURN(error);
 }
+#ifdef WITH_WSREP
+extern "C" 
+ulint
+wsrep_append_foreign_key(
+/*===========================*/
+	trx_t*		trx,		/*!< in: trx */
+	dict_foreign_t*	foreign,	/*!< in: foreign key constraint */
+	const rec_t*	clust_rec,	/*!<in: clustered index record */
+	dict_index_t*	clust_index,	/*!<in: clustered index */
+	ibool		shared)		/*!<in: is shared access */
+{
+	THD *thd = (THD*)trx->mysql_thd;
+	ulint rcode = DB_SUCCESS;
+	char cache_key[512] = {'\0'};
+
+	if (!thd->variables.wsrep_on || 
+	    thd->wsrep_exec_mode != LOCAL_STATE) 
+		return DB_SUCCESS;
+
+	byte key[WSREP_MAX_SUPPORTED_KEY_LENGTH+1];
+	ulint len = WSREP_MAX_SUPPORTED_KEY_LENGTH;
+
+	if (!(clust_index->type & DICT_CLUSTERED)) {
+		WSREP_ERROR("clustered index not passed for FK append");
+		return DB_ERROR;
+	}
+
+	key[0] = '\0';
+	rcode = wsrep_rec_get_primary_key(
+		&key[1], &len, clust_rec, clust_index);
+	if (rcode != DB_SUCCESS) {
+		WSREP_ERROR("FK key set failed: %lu", rcode);
+		return rcode;
+	}
+#ifdef WSREP_DEBUG_PRINT
+	unlint i;
+	fprintf(stderr, "FK parent key, len: %lu ", len+1);
+	for (i=0; i<len+1; i++) {
+		fprintf(stderr, " (%X), ", key[i]);
+	}
+	fprintf(stderr, "\n");
+#endif
+	strncpy(cache_key, foreign->foreign_table->name, 512);
+	char *p = strchr(cache_key, '/');
+	if (p) {
+		*p = '\0';
+	} else {
+		WSREP_WARN("unexpected foreign key table %s", 
+			   foreign->foreign_table->name);
+	}
+
+	wsrep_key_part_t wkey_part[3];
+        wsrep_key_t wkey = {wkey_part, 3};
+	if (!wsrep_prepare_key_for_innodb(
+		(const uchar*)cache_key, 
+		strlen(foreign->foreign_table->name) +  1,
+		(const uchar*)key, len+1,
+		wkey_part,
+		&wkey.key_parts_len)) {
+		WSREP_WARN("key prepare failed for cascaded FK: %s", 
+			   (thd->query()) ? thd->query() : "void");
+		return DB_ERROR;
+	}
+	rcode = (int)wsrep->append_key(
+		wsrep,
+		wsrep_trx_handle(thd, trx),
+		&wkey,
+		1, 
+		shared);
+	if (rcode) {
+		DBUG_PRINT("wsrep", ("row key failed: %lu", rcode));
+		WSREP_ERROR("Appending cascaded fk row key failed: %s, %lu", 
+			    (thd->query()) ? thd->query() : "void", rcode);
+		return DB_ERROR;
+	}
+
+	return DB_SUCCESS;
+}
+//}
 
+static int
+wsrep_append_key(
+/*==================*/
+	THD		*thd,
+	trx_t 		*trx,
+	TABLE_SHARE 	*table_share,
+	TABLE 		*table,
+	const uchar*	key,
+	uint16_t        key_len,
+	bool		shared
+)
+{
+	DBUG_ENTER("wsrep_append_key");
+#ifdef WSREP_DEBUG_PRINT
+	fprintf(stderr, "len: %d ", key_len);
+	for (int i=0; i<key_len; i++) {
+		fprintf(stderr, " %c ", key[i]);
+		fprintf(stderr, " (%X), ", key[i]);
+	}
+	fprintf(stderr, "\n");
+#endif
+	wsrep_key_part_t wkey_part[3];
+        wsrep_key_t wkey = {wkey_part, 3};
+	if (!wsrep_prepare_key_for_innodb(
+			(const uchar*)table_share->table_cache_key.str,
+			table_share->table_cache_key.length,
+			key, key_len,
+			wkey_part,
+			&wkey.key_parts_len)) {
+		WSREP_WARN("key prepare failed for: %s", 
+			   (thd->query()) ? thd->query() : "void");
+		DBUG_RETURN(HA_ERR_INTERNAL_ERROR);
+	}
+
+	int rcode = (int)wsrep->append_key(
+			       wsrep,
+			       wsrep_trx_handle(thd, trx),
+			       &wkey,
+                               1,
+			       shared);
+	if (rcode) {
+		DBUG_PRINT("wsrep", ("row key failed: %d", rcode));
+		WSREP_WARN("Appending row key failed: %s, %d", 
+		     (thd->query()) ? thd->query() : "void",	rcode);
+		DBUG_RETURN(rcode);
+	}
+	DBUG_RETURN(0);
+}
+int
+ha_innobase::wsrep_append_keys(
+/*==================*/
+	THD 		*thd,
+	bool		shared,
+	const uchar*	record0,	/* in: row in MySQL format */
+	const uchar*	record1)	/* in: row in MySQL format */
+{
+	DBUG_ENTER("wsrep_append_keys");
+	trx_t *trx = thd_to_trx(thd);
+
+	/* if no PK, calculate hash of full row, to be the key value */
+	if (prebuilt->clust_index_was_generated && wsrep_certify_nonPK) {
+		uchar digest[16];
+		int rcode;
+
+		MY_MD5_HASH(digest, (uchar *)record0, table->s->reclength);
+		if ((rcode = wsrep_append_key(thd, trx, table_share, table, 
+					      (const uchar*) digest, 16, 
+					      shared))) {
+			DBUG_RETURN(rcode);
+		}
+		if (record1) {
+			MY_MD5_HASH(digest, (uchar *)record1, 
+				    table->s->reclength);
+			if ((rcode = wsrep_append_key(thd, trx, table_share, 
+						      table,
+						      (const uchar*) digest, 
+						      16, shared))) {
+				DBUG_RETURN(rcode);
+			}
+		}
+	} else if (wsrep_protocol_version == 0) {
+		uint	len;
+		uchar 	keyval[WSREP_MAX_SUPPORTED_KEY_LENGTH+1] = {'\0'};
+		uchar 	*key 		= &keyval[0];
+		KEY	*key_info	= table->key_info;
+		ibool    is_null;
+
+		len = wsrep_store_key_val_for_row(
+			table, 0, key, key_info->key_length, record0, &is_null);
+		if (!is_null) {
+			int rcode = wsrep_append_key(
+				thd, trx, table_share, table, keyval, 
+				len, shared);
+			if (rcode) DBUG_RETURN(rcode);
+		}
+		else
+		{
+			WSREP_DEBUG("NULL key skipped (proto 0): %s", 
+				    thd->query());
+		}
+	} else {
+		ut_a(table->s->keys <= 256);
+		uint i;
+		for (i=0; i<table->s->keys; ++i) {
+			uint	len;
+			char 	keyval0[WSREP_MAX_SUPPORTED_KEY_LENGTH+1] = {'\0'};
+			char 	keyval1[WSREP_MAX_SUPPORTED_KEY_LENGTH+1] = {'\0'};
+			char 	*key0 		= &keyval0[1];
+			char 	*key1 		= &keyval1[1];
+			KEY	*key_info	= table->key_info + i;
+			ibool    is_null;
+
+			keyval0[0] = (char)i;
+			keyval0[1] = (char)i;
+
+			if (key_info->flags & HA_NOSAME) {
+				len = wsrep_store_key_val_for_row(
+					table, i, (uchar*)key0, key_info->key_length, 
+					record0, &is_null);
+				if (!is_null) {
+					int rcode = wsrep_append_key(
+						thd, trx, table_share, table, 
+						(const uchar*)keyval0, len+1, 
+						shared);
+					if (rcode) DBUG_RETURN(rcode);
+				}
+				else
+				{
+					WSREP_DEBUG("NULL key skipped: %s", 
+						    thd->query());
+				}
+				if (record1) {
+					len = wsrep_store_key_val_for_row(
+						table, i, (uchar*)key1, key_info->key_length, 
+						record1, &is_null);
+					if (!is_null && memcmp(key0, key1, len)) {
+						int rcode = wsrep_append_key(
+							thd, trx, table_share, 
+							table, 
+							(const uchar*)keyval1, 
+							len+1, shared);
+						if (rcode) DBUG_RETURN(rcode);
+					}
+				}
+			}
+		}
+	}
+	DBUG_RETURN(0);
+}
+#endif
 /*************************************************************************
 Stores a reference to the current row to 'ref' field of the handle. Note
 that in the case where we have generated the clustered index for the
@@ -8633,7 +9325,11 @@
 		In this case we cannot know how many minutes or hours
 		will be between XA PREPARE and XA COMMIT, and we don't want
 		to block for undefined period of time. */
+#ifdef WITH_WSREP
+                //pthread_mutex_lock(&prepare_commit_mutex);
+#else
 		pthread_mutex_lock(&prepare_commit_mutex);
+#endif
 		trx->active_trans = 2;
 	}
 
@@ -9025,6 +9721,264 @@
 static struct st_mysql_storage_engine innobase_storage_engine=
 { MYSQL_HANDLERTON_INTERFACE_VERSION };
 
+#ifdef WITH_WSREP
+void
+wsrep_abort_slave_trx(wsrep_seqno_t bf_seqno, wsrep_seqno_t victim_seqno)
+{
+	WSREP_ERROR("Trx %lld tries to abort slave trx %lld. This could be "
+		"caused by:\n\t"
+		"1) unsupported configuration options combination, please check documentation.\n\t"
+		"2) a bug in the code.\n\t"
+		"3) a database corruption.\n Node consistency compromized, "
+		"need to abort. Restart the node to resync with cluster.",
+		(long long)bf_seqno, (long long)victim_seqno);
+	abort();
+}
+
+int
+wsrep_innobase_kill_one_trx(trx_t *bf_trx, trx_t *victim_trx, ibool signal)
+{
+	DBUG_ENTER("wsrep_innobase_kill_one_trx");
+	THD *thd          = (THD *) victim_trx->mysql_thd;
+	THD *bf_thd       = (bf_trx) ? (THD *)bf_trx->mysql_thd : NULL;
+	int64_t bf_seqno  = (bf_thd) ? bf_thd->wsrep_trx_seqno : 0;
+
+	ut_ad(mutex_own(&kernel_mutex));
+
+	if (!thd) {
+		DBUG_PRINT("wsrep", ("no thd for conflicting lock"));
+		WSREP_WARN("no THD for trx: %lld", 
+			ut_conv_dulint_to_longlong(victim_trx->id));
+		DBUG_RETURN(1);
+	}
+
+        WSREP_DEBUG("BF kill (%lu, seqno: %lld), victim: (%lu %lu) trx: %lld",
+                signal,
+                (bf_thd) ? (long long)bf_thd->wsrep_trx_seqno : -1LL,
+                thd->real_id, thd->thread_id,
+                ut_conv_dulint_to_longlong(victim_trx->id));
+
+	WSREP_DEBUG("Aborting query: %s", 
+		(thd && thd->query()) ? thd->query() : "void");
+
+	pthread_mutex_lock(&thd->LOCK_wsrep_thd);
+
+	if (thd->wsrep_query_state == QUERY_EXITING) {
+		WSREP_DEBUG("kill trx EXITING for %lld",
+			ut_conv_dulint_to_longlong(victim_trx->id));
+		pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+		DBUG_RETURN(0);
+	}
+	if(thd->wsrep_exec_mode != LOCAL_STATE) {
+		WSREP_DEBUG(
+			"withdraw for BF trx: %lld, state: %d", 
+			ut_conv_dulint_to_longlong(victim_trx->id),
+			thd->wsrep_conflict_state);
+	}
+
+	switch (thd->wsrep_conflict_state){
+	case NO_CONFLICT: 
+		thd->wsrep_conflict_state= MUST_ABORT;
+		break;
+        case MUST_ABORT:
+		WSREP_DEBUG("victim %lld in MUST ABORT state", 
+			ut_conv_dulint_to_longlong(victim_trx->id));
+		pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+		if (thd->killed != THD::KILL_QUERY      && 
+		    thd->killed != THD::KILL_CONNECTION &&
+		    signal) {
+			pthread_mutex_lock(&thd->LOCK_thd_data);
+			thd->awake(THD::KILL_QUERY);
+			pthread_mutex_unlock(&thd->LOCK_thd_data);
+		} else {
+			pthread_mutex_lock(&LOCK_wsrep_replaying);
+			pthread_cond_broadcast(&COND_wsrep_replaying);
+			pthread_mutex_unlock(&LOCK_wsrep_replaying);
+		}
+		DBUG_RETURN(0);
+		break;
+	case ABORTED:
+	case ABORTING: // fall through
+	default:
+		WSREP_DEBUG("victim %lld in state %d", 
+			ut_conv_dulint_to_longlong(victim_trx->id),
+			thd->wsrep_conflict_state);
+		pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+		DBUG_RETURN(0);
+		break;
+	}
+
+	switch (thd->wsrep_query_state) {
+	case QUERY_COMMITTING:
+		enum wsrep_status rcode;
+
+		WSREP_DEBUG("kill trx QUERY_COMMITTING for %lld", 
+			ut_conv_dulint_to_longlong(victim_trx->id));
+
+		if (thd->wsrep_exec_mode == REPL_RECV) {
+			wsrep_abort_slave_trx(bf_seqno, thd->wsrep_trx_seqno);
+		} else {
+			rcode = wsrep->abort_pre_commit(
+			    wsrep, bf_seqno,
+			    (wsrep_trx_id_t)ut_conv_dulint_to_longlong(
+				victim_trx->id)
+			);
+			
+			switch (rcode) {
+			case WSREP_WARNING:
+				WSREP_DEBUG(
+					"cancel commit warning: %lld",
+					ut_conv_dulint_to_longlong(
+					victim_trx->id));
+				pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+				DBUG_RETURN(1);
+				break;
+			case WSREP_OK:
+				break;
+			default:
+				WSREP_ERROR(
+					"cancel commit bad exit: %d %lld", 
+					rcode, 
+					ut_conv_dulint_to_longlong(
+					victim_trx->id));
+				/* unable to interrupt, must abort */
+				/* note: kill_mysql() will block, if we cannot 
+				 * kill the lock holder first.
+				 */
+				abort();
+				break;
+			}
+		}
+		break;
+	case QUERY_EXEC:
+		/* it is possible that victim trx is itself waiting for some 
+		 * other lock. We need to cancel this waiting
+		 */
+		WSREP_DEBUG("kill trx QUERY_EXEC for %lld", 
+			  ut_conv_dulint_to_longlong(victim_trx->id));
+
+		victim_trx->was_chosen_as_deadlock_victim= TRUE;
+		if (victim_trx->wait_lock) {
+			WSREP_DEBUG("victim has wait flag: %lu", thd->real_id);
+			if (signal) {
+				pthread_mutex_lock(&thd->LOCK_thd_data);
+				thd->awake(THD::KILL_QUERY);
+				pthread_mutex_unlock(&thd->LOCK_thd_data);
+			} else {
+				pthread_mutex_lock(&LOCK_wsrep_replaying);
+				pthread_cond_broadcast(&COND_wsrep_replaying);
+				pthread_mutex_unlock(&LOCK_wsrep_replaying);
+			}
+			WSREP_DEBUG("canceling wait lock");
+			wsrep_lock_cancel_waiting_and_release(
+				victim_trx->wait_lock);
+		} else {
+			/* abort currently executing query */
+			DBUG_PRINT("wsrep",("sending KILL_QUERY to: %lu", 
+					     thd->real_id));
+			WSREP_DEBUG("kill query for: %ld", thd->real_id);
+			if (signal) {
+				pthread_mutex_lock(&thd->LOCK_thd_data);
+				thd->awake(THD::KILL_QUERY);
+				pthread_mutex_unlock(&thd->LOCK_thd_data);
+			} else {
+				pthread_mutex_lock(&LOCK_wsrep_replaying);
+				pthread_cond_broadcast(&COND_wsrep_replaying);
+				pthread_mutex_unlock(&LOCK_wsrep_replaying);
+			}
+
+			/* for BF thd, we need to prevent him from committing */
+			if (thd->wsrep_exec_mode == REPL_RECV) {
+				wsrep_abort_slave_trx(bf_seqno,
+						thd->wsrep_trx_seqno);
+			}
+		}
+		break;
+	case QUERY_IDLE:
+	{
+		bool skip_abort= false;
+		wsrep_aborting_thd_t abortees;
+
+		WSREP_DEBUG("kill IDLE for %lld", 
+			ut_conv_dulint_to_longlong(victim_trx->id));
+
+		if (thd->wsrep_exec_mode == REPL_RECV) {
+			WSREP_DEBUG("kill BF IDLE, seqno: %lld",
+			            (long long) thd->wsrep_trx_seqno);
+			pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+			wsrep_abort_slave_trx(bf_seqno, thd->wsrep_trx_seqno);
+			DBUG_RETURN(0);
+		}
+		/* This will lock thd from preceeding after net_read() */
+		thd->wsrep_conflict_state = ABORTING;
+
+		(void) pthread_mutex_lock(&LOCK_wsrep_rollback);
+
+		abortees = wsrep_aborting_thd;
+		while (abortees &&!skip_abort) {
+			/* check if we have a kill message for this already */
+			if (abortees->aborting_thd == thd) {
+				skip_abort = true;
+				WSREP_DEBUG("WSREP duplicate thd aborter %lu", 
+					    thd->real_id);
+			}
+			abortees = abortees->next;
+		}
+		if (!skip_abort) {
+			wsrep_aborting_thd_t aborting = (wsrep_aborting_thd_t)
+				my_malloc(sizeof(struct wsrep_aborting_thd), 
+					  MYF(0));
+			aborting->aborting_thd  = thd;
+			aborting->next          = wsrep_aborting_thd;
+			wsrep_aborting_thd      = aborting;
+			DBUG_PRINT("wsrep",("enqueuing trx abort for %lu",
+					     thd->real_id));
+			WSREP_DEBUG("enqueuing trx abort for (%lu %lu)",
+				    thd->real_id, thd->thread_id);
+		}
+	
+		DBUG_PRINT("wsrep",("signalling wsrep rollbacker"));
+		WSREP_DEBUG("WSREP signalling aborter");
+		pthread_cond_signal(&COND_wsrep_rollback);
+		(void) pthread_mutex_unlock(&LOCK_wsrep_rollback);
+
+		break;
+	}
+	default:
+		WSREP_WARN("bad wsrep query state: %d", thd->wsrep_query_state);
+		break;
+	}
+	pthread_mutex_unlock(&thd->LOCK_wsrep_thd);
+     
+	DBUG_RETURN(0);
+}
+static int 
+wsrep_abort_transaction(handlerton* hton, THD *bf_thd, THD *victim_thd, 
+			my_bool signal)
+{
+	DBUG_ENTER("wsrep_innobase_abort_thd");
+	trx_t* victim_trx = thd_to_trx(victim_thd);
+	trx_t* bf_trx     = (bf_thd) ? thd_to_trx(bf_thd) : NULL;
+	int rcode;
+
+	if (victim_trx)
+	{
+		mutex_enter_noninline(&kernel_mutex);
+		rcode = wsrep_innobase_kill_one_trx(bf_trx, victim_trx, 
+						    (ibool)signal);
+		mutex_exit_noninline(&kernel_mutex);
+	} else {
+		WSREP_DEBUG("victim does not have transaction: thd %lu",
+			    victim_thd->thread_id);
+		pthread_mutex_lock(&victim_thd->LOCK_thd_data);
+		victim_thd->awake(THD::KILL_QUERY);
+		pthread_mutex_unlock(&victim_thd->LOCK_thd_data);
+		rcode = -1;
+	}
+	DBUG_RETURN(rcode);
+}
+#endif /* WITH_WSREP */
+
 /* plugin options */
 static MYSQL_SYSVAR_BOOL(checksums, innobase_use_checksums,
   PLUGIN_VAR_NOCMDARG | PLUGIN_VAR_READONLY,
@@ -9240,6 +10194,40 @@
   NULL, NULL, 0, 0, 1, 0);
 #endif /* UNIV_DEBUG || UNIV_IBUF_DEBUG */
 
+#ifdef WITH_INNODB_DISALLOW_WRITES
+/*******************************************************
+ *    innobase_disallow_writes variable definition     *
+ *******************************************************/
+ 
+/* Must always init to FALSE. */
+static my_bool	innobase_disallow_writes	= FALSE;
+
+/**************************************************************************
+An "update" method for innobase_disallow_writes variable. */
+static
+void
+innobase_disallow_writes_update(
+/*============================*/
+	THD*			thd,		/* in: thread handle */
+	st_mysql_sys_var*	var,		/* in: pointer to system
+						variable */
+	void*			var_ptr,	/* out: pointer to dynamic
+						variable */
+	const void*		save)		/* in: temporary storage */
+{
+	*(my_bool*)var_ptr = *(my_bool*)save;
+	ut_a(srv_allow_writes_event);
+	if (*(my_bool*)var_ptr)
+		os_event_reset(srv_allow_writes_event);
+	else
+		os_event_set(srv_allow_writes_event);
+}
+
+static MYSQL_SYSVAR_BOOL(disallow_writes, innobase_disallow_writes,
+  PLUGIN_VAR_NOCMDOPT,
+  "Tell InnoDB to stop any writes to disk",
+  NULL, innobase_disallow_writes_update, FALSE);
+#endif /* WITH_INNODB_DISALLOW_WRITES */
 #ifdef UNIV_DEBUG
 static MYSQL_SYSVAR_UINT(trx_rseg_n_slots_debug, trx_rseg_n_slots_debug,
   PLUGIN_VAR_RQCMDARG,
@@ -9292,6 +10280,9 @@
 #if defined UNIV_DEBUG || defined UNIV_IBUF_DEBUG
   MYSQL_SYSVAR(change_buffering_debug),
 #endif /* UNIV_DEBUG || UNIV_IBUF_DEBUG */
+#ifdef WITH_INNODB_DISALLOW_WRITES
+  MYSQL_SYSVAR(disallow_writes),
+#endif /* WITH_INNODB_DISALLOW_WRITES */
 #ifdef UNIV_DEBUG
   MYSQL_SYSVAR(trx_rseg_n_slots_debug),
 #endif /* UNIV_DEBUG */

=== modified file 'storage/innobase/handler/ha_innodb.h'
--- old/storage/innobase/handler/ha_innodb.h	2010-10-18 10:48:11 +0000
+++ new/storage/innobase/handler/ha_innodb.h	2012-01-27 18:54:43 +0000
@@ -82,6 +82,10 @@
 	dict_index_t* innobase_get_index(uint keynr);
 	int info_low(uint flag, bool called_from_analyze);
 
+#ifdef WITH_WSREP
+	int wsrep_append_keys(THD *thd, bool shared,
+			      const uchar* record0, const uchar* record1);
+#endif
 	/* Init values for the class: */
  public:
 	ha_innobase(handlerton *hton, TABLE_SHARE *table_arg);
@@ -112,7 +116,11 @@
 				less than 1 / 4 of page size which is 16 kB;
 				but currently MySQL does not work with keys
 				whose size is > MAX_KEY_LENGTH */
+#ifdef WITH_WSREP
+	uint max_supported_key_length() const { return 3500; }
+#else
 	uint max_supported_key_length() const { return 3500; }
+#endif // WITH_WSREP
 	uint max_supported_key_part_length() const;
 	const key_map *keys_to_use_for_scanning() { return &key_map_full; }
 
@@ -260,3 +268,7 @@
 */
 bool thd_binlog_filter_ok(const MYSQL_THD thd);
 }
+
+#ifdef WITH_WSREP
+extern "C" int wsrep_trx_is_aborting(void *thd_ptr);
+#endif

=== modified file 'storage/innobase/include/dict0mem.h'
--- old/storage/innobase/include/dict0mem.h	2011-01-14 17:02:28 +0000
+++ new/storage/innobase/include/dict0mem.h	2011-07-03 19:20:30 +0000
@@ -168,6 +168,9 @@
 files would be at risk! */
 
 #define DICT_MAX_INDEX_COL_LEN		768
+#ifdef WITH_WSREP
+#define WSREP_MAX_SUPPORTED_KEY_LENGTH 3500
+#endif // WITH_WSREP
 
 /* Data structure for a field in an index */
 struct dict_field_struct{

=== modified file 'storage/innobase/include/ha_prototypes.h'
--- old/storage/innobase/include/ha_prototypes.h	2009-11-04 10:28:10 +0000
+++ new/storage/innobase/include/ha_prototypes.h	2012-01-25 20:25:55 +0000
@@ -75,5 +75,13 @@
 				/* out: true if thd is executing SELECT */
 	const void*	thd);	/* in: thread handle (THD*) */
 
+#ifdef WITH_WSREP
+int wsrep_innobase_kill_one_trx(trx_t *bf_trx, trx_t *victim_trx, ibool signal);
+int wsrep_thd_is_brute_force(void *thd_ptr);
+int wsrep_trx_order_before(void *thd1, void *thd2);
+void wsrep_innobase_mysql_sort(int mysql_type, uint charset_number,
+			       unsigned char* str, unsigned int str_length);
+my_thread_id wsrep_thd_thread_id(void *thd);
+#endif /* WITH_WSREP */
 #endif
 #endif

=== modified file 'storage/innobase/include/lock0lock.h'
--- old/storage/innobase/include/lock0lock.h	2010-06-02 10:26:37 +0000
+++ new/storage/innobase/include/lock0lock.h	2011-09-24 22:18:27 +0000
@@ -461,6 +461,12 @@
 Cancels a waiting lock request and releases possible other transactions
 waiting behind it. */
 
+#ifdef WITH_WSREP
+void
+wsrep_lock_cancel_waiting_and_release(
+/*============================*/
+	lock_t*	lock);	/* in: waiting lock request */
+#endif
 void
 lock_cancel_waiting_and_release(
 /*============================*/
@@ -685,6 +691,7 @@
 				remains set when the waiting lock is granted,
 				or if the lock is inherited to a neighboring
 				record */
+#define WSREP_BF		4096
 
 /* When lock bits are reset, the following flags are available: */
 #define LOCK_RELEASE_WAIT	1

=== modified file 'storage/innobase/include/rem0rec.h'
--- old/storage/innobase/include/rem0rec.h	2011-06-16 08:51:04 +0000
+++ new/storage/innobase/include/rem0rec.h	2012-01-25 20:25:55 +0000
@@ -591,6 +591,13 @@
 two upmost bits in a two byte offset for special purposes */
 #define REC_MAX_DATA_SIZE	(16 * 1024)
 
+#ifdef WITH_WSREP
+int wsrep_rec_get_primary_key(
+	byte 		*buf,     /* out: extracted key */
+	ulint 		*buf_len, /* in/out: length of buf */
+	const rec_t*	rec,	  /* in: physical record */
+	dict_index_t*	index);	  /* in: record descriptor */
+#endif // WITH_WSREP
 #ifndef UNIV_NONINL
 #include "rem0rec.ic"
 #endif

=== modified file 'storage/innobase/include/srv0srv.h'
--- old/storage/innobase/include/srv0srv.h	2011-01-14 17:02:28 +0000
+++ new/storage/innobase/include/srv0srv.h	2011-07-03 19:20:30 +0000
@@ -82,6 +82,11 @@
 extern ulint	srv_log_buffer_size;
 extern ulong	srv_flush_log_at_trx_commit;
 
+#ifdef WITH_INNODB_DISALLOW_WRITES
+/* When this event is reset we do not allow any file writes to take place. */
+extern os_event_t	srv_allow_writes_event;
+#endif /* WITH_INNODB_DISALLOW_WRITES */
+
 extern byte	srv_latin1_ordering[256];/* The sort order table of the latin1
 					character set */
 extern ulint	srv_pool_size;

=== modified file 'storage/innobase/lock/lock0lock.c'
--- old/storage/innobase/lock/lock0lock.c	2010-09-14 09:37:03 +0000
+++ new/storage/innobase/lock/lock0lock.c	2011-10-09 06:58:15 +0000
@@ -21,6 +21,12 @@
 #include "dict0mem.h"
 #include "trx0sys.h"
 
+#ifdef WITH_WSREP
+#include "ha_prototypes.h"
+extern my_bool wsrep_debug;
+int wsrep_thd_is_brute_force(void *thd_ptr);
+int wsrep_trx_order_before(void *thd1, void *thd2);
+#endif
 
 /* Restricts the length of search we will do in the waits-for
 graph of transactions */
@@ -900,7 +906,15 @@
 	if (trx != lock2->trx
 	    && !lock_mode_compatible(LOCK_MODE_MASK & type_mode,
 				     lock_get_mode(lock2))) {
-
+#ifdef WITH_WSREP
+		if ((type_mode & WSREP_BF) && (lock2->type_mode & WSREP_BF)) {
+	  		if (wsrep_debug)
+				fprintf(stderr, 
+					"WSREP BF lock modes:  %lu, %lu\n", 
+					lock2->type_mode, type_mode );
+			return FALSE;
+		}
+#endif /* WITH_WSREP */
 		/* We have somewhat complex rules when gap type record locks
 		cause waits */
 
@@ -1500,6 +1514,11 @@
 	return(NULL);
 }
 #endif /* !UNIV_HOTBACKUP */
+#ifdef WITH_WSREP
+static
+void
+lock_rec_discard(lock_t*	in_lock);
+#endif
 
 /*************************************************************************
 Checks if some other transaction has a conflicting explicit lock request
@@ -1525,7 +1544,34 @@
 		if (lock_rec_has_to_wait(trx, mode, lock,
 					 page_rec_is_supremum(rec))) {
 
+#ifdef WITH_WSREP
+			int bf_this  = wsrep_thd_is_brute_force(trx->mysql_thd);
+			int bf_other = 
+			    wsrep_thd_is_brute_force(lock->trx->mysql_thd);
+			if ((bf_this && !bf_other) ||
+			    (bf_this && bf_other && wsrep_trx_order_before(
+				    trx->mysql_thd, lock->trx->mysql_thd))) {
+
+				if (lock->trx->que_state == TRX_QUE_LOCK_WAIT) {
+					if (wsrep_debug) fprintf(stderr,
+					    "WSREP: BF victim  waiting: %lu\n",
+					    (ulong)ut_dulint_get_low(
+						lock->trx->id));
+					/* cannot release lock, until our lock
+					is in the queue*/
+					return(lock);
+				} else if (lock->trx != trx) {
+					wsrep_innobase_kill_one_trx(
+						trx, lock->trx, TRUE);
+					return(lock);
+				}
+			} else {
+				return(lock);
+                        }
+#else
 			return(lock);
+#endif
+
 		}
 
 		lock = lock_rec_get_next(rec, lock);
@@ -1661,6 +1707,9 @@
 static
 lock_t*
 lock_rec_create(
+#ifdef WITH_WSREP
+        lock_t *       c_lock,   /* conflicting lock */
+#endif
 /*============*/
 				/* out: created lock */
 	ulint		type_mode,/* in: lock mode and wait flag, type is
@@ -1701,12 +1750,15 @@
 	n_bytes = 1 + n_bits / 8;
 
 	lock = mem_heap_alloc(trx->lock_heap, sizeof(lock_t) + n_bytes);
-
 	UT_LIST_ADD_LAST(trx_locks, trx->trx_locks, lock);
-
 	lock->trx = trx;
 
 	lock->type_mode = (type_mode & ~LOCK_TYPE_MASK) | LOCK_REC;
+#ifdef WITH_WSREP
+	if (wsrep_thd_is_brute_force(trx->mysql_thd)) {
+		lock->type_mode |= WSREP_BF;
+	}
+#endif
 	lock->index = index;
 
 	lock->un_member.rec_lock.space = space;
@@ -1720,9 +1772,55 @@
 
 	/* Set the bit corresponding to rec */
 	lock_rec_set_nth_bit(lock, heap_no);
-
+#ifdef WITH_WSREP
+	if (c_lock && wsrep_thd_is_brute_force(trx->mysql_thd)) {
+        	lock_t *hash = c_lock->hash;
+		lock_t *prev = NULL;
+
+		while (hash &&
+		  wsrep_thd_is_brute_force(hash->trx->mysql_thd) &&
+		  wsrep_trx_order_before(hash->trx->mysql_thd, trx->mysql_thd)){
+			prev = hash;
+			hash = hash->hash;
+		}
+		lock->hash = hash;
+		if (prev) {
+			if (wsrep_debug) fprintf(stderr,
+				"WSREP: c_lock inserted between: %lu - %lu\n",
+				(ulong) ut_dulint_get_low(prev->trx->id),
+				(hash) ?
+				    (ulong)ut_dulint_get_low(lock->trx->id) :0);
+				(ulong) ut_dulint_get_low(prev->trx->id),
+			prev->hash = lock;
+		} else {
+			c_lock->hash = lock;
+		}
+		/*
+		 * delayed conflict resolution '...kill_one_trx' was not called,
+		 * if victim was waiting for some other lock
+		 */
+		if (c_lock && c_lock->trx->que_state == TRX_QUE_LOCK_WAIT) {
+			if (wsrep_debug) fprintf(stderr, 
+				"WSREP: BF %lu is waiting for c_lock: %lu %ld\n",
+				(ulong) ut_dulint_get_low(lock->trx->id),
+				(ulong) ut_dulint_get_low(c_lock->trx->id),
+				wsrep_thd_thread_id(c_lock->trx->mysql_thd));
+
+                        ut_ad(c_lock->trx->wait_lock);
+			trx->que_state = TRX_QUE_LOCK_WAIT;
+			lock_set_lock_and_trx_wait(lock, trx);
+			c_lock->trx->was_chosen_as_deadlock_victim = TRUE;
+			lock_cancel_waiting_and_release(c_lock->trx->wait_lock);
+			return(lock);
+		}
+	} else {
+		HASH_INSERT(lock_t, hash, lock_sys->rec_hash,
+			    lock_rec_fold(space, page_no), lock);
+	}
+#else
 	HASH_INSERT(lock_t, hash, lock_sys->rec_hash,
 		    lock_rec_fold(space, page_no), lock);
+#endif
 	if (type_mode & LOCK_WAIT) {
 
 		lock_set_lock_and_trx_wait(lock, trx);
@@ -1737,6 +1835,9 @@
 static
 ulint
 lock_rec_enqueue_waiting(
+#ifdef WITH_WSREP
+	lock_t* 	c_lock,   /* conflicting lock */
+#endif
 /*=====================*/
 				/* out: DB_LOCK_WAIT, DB_DEADLOCK, or
 				DB_QUE_THR_SUSPENDED, or DB_SUCCESS_LOCKED_REC;
@@ -1786,8 +1887,17 @@
 	}
 
 	/* Enqueue the lock request that will wait to be granted */
+#ifdef WITH_WSREP
+	if (trx->was_chosen_as_deadlock_victim) {
+		if(wsrep_debug) 
+			fprintf(stderr,"WSREP: was chosen DL victim: %lu\n",
+				(ulong) ut_dulint_get_low(trx->id));
+		return(DB_DEADLOCK);
+        }
+	lock = lock_rec_create(c_lock, type_mode | LOCK_WAIT, rec, index, trx);
+#else
 	lock = lock_rec_create(type_mode | LOCK_WAIT, rec, index, trx);
-
+#endif
 	/* Check if a deadlock occurs: if yes, remove the lock request and
 	return an error code */
 
@@ -1853,11 +1963,12 @@
 	      || ((type_mode & LOCK_MODE_MASK) != LOCK_S)
 	      || !lock_rec_other_has_expl_req(LOCK_X, 0, LOCK_WAIT,
 					      rec, trx));
+#ifndef WITH_WSREP
 	ut_ad((type_mode & (LOCK_WAIT | LOCK_GAP))
 	      || ((type_mode & LOCK_MODE_MASK) != LOCK_X)
 	      || !lock_rec_other_has_expl_req(LOCK_S, 0, LOCK_WAIT,
 					      rec, trx));
-
+#endif
 	type_mode = type_mode | LOCK_REC;
 
 	/* If rec is the supremum record, then we can reset the gap bit, as
@@ -1897,11 +2008,13 @@
 	if (similar_lock && !somebody_waits && !(type_mode & LOCK_WAIT)) {
 
 		lock_rec_set_nth_bit(similar_lock, heap_no);
-
 		return(similar_lock);
 	}
-
+#ifdef WITH_WSREP
+	return(lock_rec_create(NULL, type_mode, rec, index, trx));
+#else
 	return(lock_rec_create(type_mode, rec, index, trx));
+#endif
 }
 
 /** Record locking request status */
@@ -1958,7 +2071,11 @@
 
 	if (lock == NULL) {
 		if (!impl) {
+#ifdef WITH_WSREP
+			lock_rec_create(NULL, mode, rec, index, trx);
+#else
 			lock_rec_create(mode, rec, index, trx);
+#endif
 		}
 
 		return(LOCK_REC_SUCCESS_CREATED);
@@ -2011,6 +2128,9 @@
 	que_thr_t*	thr)	/* in: query thread */
 {
 	trx_t*	trx;
+#ifdef WITH_WSREP
+	lock_t *c_lock;
+#endif
 
 	ut_ad(mutex_own(&kernel_mutex));
 	ut_ad((LOCK_MODE_MASK & mode) != LOCK_S
@@ -2029,13 +2149,20 @@
 		/* The trx already has a strong enough lock on rec: do
 		nothing */
 
+#ifdef WITH_WSREP
+	} else if ((c_lock = lock_rec_other_has_conflicting(mode, rec, trx))) {
+#else
 	} else if (lock_rec_other_has_conflicting(mode, rec, trx)) {
-
+#endif
 		/* If another transaction has a non-gap conflicting request in
 		the queue, as this transaction does not have a lock strong
 		enough already granted on the record, we have to wait. */
-
+#ifdef WITH_WSREP
+		return(lock_rec_enqueue_waiting(c_lock, mode, rec, index, thr));
+#else
 		return(lock_rec_enqueue_waiting(mode, rec, index, thr));
+#endif
+
 	} else if (!impl) {
 		/* Set the requested lock on the record */
 
@@ -2079,6 +2206,11 @@
 	      || mode - (LOCK_MODE_MASK & mode) == LOCK_REC_NOT_GAP
 	      || mode - (LOCK_MODE_MASK & mode) == 0);
 
+#ifdef WITH_WSREP
+	if (wsrep_thd_is_brute_force(thr_get_trx(thr)->mysql_thd)) {
+		mode |= WSREP_BF;
+	}
+#endif /* WITH_WSREP */
 	/* We try a simplified and faster subroutine for the most
 	common cases */
 	switch (lock_rec_lock_fast(impl, mode, rec, index, thr)) {
@@ -3297,16 +3429,58 @@
 				}
 #endif /* UNIV_DEBUG */
 
+#ifdef WITH_WSREP
+				if (wsrep_debug)
+					fputs("WSREP: Deadlock detected\n", ef);
+				if (wsrep_thd_is_brute_force(start->mysql_thd) &&
+				    wsrep_thd_is_brute_force(
+				        wait_lock->trx->mysql_thd) &&
+				    (start != wait_lock->trx)) {
+
+					if (wsrep_trx_order_before(
+					    start->mysql_thd, 
+                                            wait_lock->trx->mysql_thd)) {
+
+						wait_lock->trx->was_chosen_as_deadlock_victim = TRUE;
+						lock_cancel_waiting_and_release(wait_lock);
+						return(LOCK_VICTIM_IS_OTHER);
+					} else {
+						return(LOCK_VICTIM_IS_START);
+					}
+                                }
+#endif
+
+				if (too_far) {
+
+					fputs("TOO DEEP OR LONG SEARCH"
+					      " IN THE LOCK TABLE"
+					      " WAITS-FOR GRAPH\n", ef);
+
+					return(LOCK_VICTIM_IS_START);
+				}
+
 				if (trx_weight_cmp(wait_lock->trx,
 						   start) >= 0) {
 					/* Our recursion starting point
 					transaction is 'smaller', let us
 					choose 'start' as the victim and roll
 					back it */
-
+#ifdef WITH_WSREP
+					if (!wsrep_thd_is_brute_force(
+					    start->mysql_thd)) {
+						return(LOCK_VICTIM_IS_START);
+					}
+#else
 					return(LOCK_VICTIM_IS_START);
+#endif
 				}
 
+#ifdef WITH_WSREP
+				if (wsrep_thd_is_brute_force(
+				    wait_lock->trx->mysql_thd)) {
+					return(LOCK_VICTIM_IS_START);
+				}
+#endif
 				lock_deadlock_found = TRUE;
 
 				/* Let us choose the transaction of wait_lock
@@ -3372,6 +3546,9 @@
 UNIV_INLINE
 lock_t*
 lock_table_create(
+#ifdef WITH_WSREP
+	lock_t*		c_lock,   /* conflicting lock */
+#endif
 /*==============*/
 				/* out, own: new lock object */
 	dict_table_t*	table,	/* in: database table in dictionary cache */
@@ -3400,7 +3577,6 @@
 	} else {
 		lock = mem_heap_alloc(trx->lock_heap, sizeof(lock_t));
 	}
-
 	UT_LIST_ADD_LAST(trx_locks, trx->trx_locks, lock);
 
 	lock->type_mode = type_mode | LOCK_TABLE;
@@ -3408,8 +3584,25 @@
 
 	lock->un_member.tab_lock.table = table;
 
-	UT_LIST_ADD_LAST(un_member.tab_lock.locks, table->locks, lock);
+#ifdef WITH_WSREP
+	if (c_lock && wsrep_thd_is_brute_force(trx->mysql_thd)) {
+        	UT_LIST_INSERT_AFTER(
+		    un_member.tab_lock.locks, table->locks, c_lock, lock);
+        } else {
+        	UT_LIST_ADD_LAST(un_member.tab_lock.locks, table->locks, lock);
+        }
+
+	if (c_lock && c_lock->trx->que_state == TRX_QUE_LOCK_WAIT) {
+		if (wsrep_debug)
+			fprintf(stderr, "WSREP: table c_lock in wait: %lu\n", 
+			(ulong) ut_dulint_get_low(c_lock->trx->id));
+		c_lock->trx->was_chosen_as_deadlock_victim = TRUE;
+		lock_cancel_waiting_and_release(c_lock->trx->wait_lock);
+	}
 
+#else
+	UT_LIST_ADD_LAST(un_member.tab_lock.locks, table->locks, lock);
+#endif
 	if (type_mode & LOCK_WAIT) {
 
 		lock_set_lock_and_trx_wait(lock, trx);
@@ -3453,6 +3646,9 @@
 static
 ulint
 lock_table_enqueue_waiting(
+#ifdef WITH_WSREP
+	lock_t*		c_lock,   /* conflicting lock */
+#endif
 /*=======================*/
 				/* out: DB_LOCK_WAIT, DB_DEADLOCK, or
 				DB_QUE_THR_SUSPENDED, or DB_SUCCESS;
@@ -3495,9 +3691,14 @@
 	}
 
 	/* Enqueue the lock request that will wait to be granted */
-
+#ifdef WITH_WSREP
+	if (trx->was_chosen_as_deadlock_victim) {
+		return(DB_DEADLOCK);
+	}
+	lock = lock_table_create(c_lock, table, mode | LOCK_WAIT, trx);
+#else
 	lock = lock_table_create(table, mode | LOCK_WAIT, trx);
-
+#endif
 	/* Check if a deadlock occurs: if yes, remove the lock request and
 	return an error code */
 
@@ -3529,7 +3730,11 @@
 Checks if other transactions have an incompatible mode lock request in
 the lock queue. */
 UNIV_INLINE
+#ifdef WITH_WSREP
+lock_t *
+#else
 ibool
+#endif
 lock_table_other_has_incompatible(
 /*==============================*/
 	trx_t*		trx,	/* in: transaction, or NULL if all
@@ -3551,13 +3756,44 @@
 		    && (!lock_mode_compatible(lock_get_mode(lock), mode))
 		    && (wait || !(lock_get_wait(lock)))) {
 
+#ifdef WITH_WSREP
+			int bf_this  = wsrep_thd_is_brute_force(trx->mysql_thd);
+			int bf_other = wsrep_thd_is_brute_force(
+			    lock->trx->mysql_thd);
+			if ((bf_this && !bf_other) ||
+			    (bf_this && bf_other && 
+				wsrep_trx_order_before(
+					trx->mysql_thd, lock->trx->mysql_thd)
+			    )
+			) {
+				if (lock->trx->que_state == TRX_QUE_LOCK_WAIT) {
+					if (wsrep_debug) fprintf(stderr,
+					    "WSREP: BF victim  waiting: %lu\n",
+					    (ulong)ut_dulint_get_low(
+						lock->trx->id));
+					return(lock);
+				} else {
+                                	if (bf_this && bf_other)
+						wsrep_innobase_kill_one_trx(
+							trx, lock->trx, TRUE);
+					return(lock);
+				}
+			} else {
+				return(lock);
+			}
+#else
 			return(TRUE);
+#endif
 		}
 
 		lock = UT_LIST_GET_PREV(un_member.tab_lock.locks, lock);
 	}
 
+#ifdef WITH_WSREP
+	return(NULL);
+#else
 	return(FALSE);
+#endif
 }
 
 /*************************************************************************
@@ -3575,6 +3811,9 @@
 	ulint		mode,	/* in: lock mode */
 	que_thr_t*	thr)	/* in: query thread */
 {
+#ifdef WITH_WSREP
+	lock_t *c_lock;
+#endif
 	trx_t*	trx;
 	ulint	err;
 
@@ -3602,20 +3841,30 @@
 
 	/* We have to check if the new lock is compatible with any locks
 	other transactions have in the table lock queue. */
-
+#ifdef WITH_WSREP
+	if ((c_lock = lock_table_other_has_incompatible(trx, LOCK_WAIT, table, mode))) {
+#else
 	if (lock_table_other_has_incompatible(trx, LOCK_WAIT, table, mode)) {
-
+#endif
 		/* Another trx has a request on the table in an incompatible
 		mode: this trx may have to wait */
 
+#ifdef WITH_WSREP
+		err = lock_table_enqueue_waiting(c_lock, mode | flags, table, thr);
+#else
 		err = lock_table_enqueue_waiting(mode | flags, table, thr);
+#endif
 
 		lock_mutex_exit_kernel();
 
 		return(err);
 	}
 
+#ifdef WITH_WSREP
+	lock_table_create(c_lock, table, mode | flags, trx);
+#else
 	lock_table_create(table, mode | flags, trx);
+#endif
 
 	ut_a(!flags || mode == LOCK_S || mode == LOCK_X);
 
@@ -3890,6 +4139,24 @@
 	ut_a(trx->auto_inc_lock == NULL);
 }
 
+#ifdef WITH_WSREP
+/*************************************************************************
+Cancels a waiting lock request and releases possible other transactions
+waiting behind it. */
+
+void
+wsrep_lock_cancel_waiting_and_release(
+/*============================*/
+	lock_t*	lock)	/* in: waiting lock request */
+{
+	ut_ad(mutex_own(&kernel_mutex));
+	if (lock && lock_get_wait(lock)) {
+		lock_cancel_waiting_and_release(lock);
+	} else if (wsrep_debug) { 
+		fprintf(stderr, "WSREP no more wait locks, bailing out\n");
+	}
+}
+#endif
 /*************************************************************************
 Cancels a waiting lock request and releases possible other transactions
 waiting behind it. */
@@ -3966,6 +4233,15 @@
 
 		lock = prev_lock;
 	}
+#ifdef WITH_WSREP
+	if (!wsrep_thd_is_brute_force(trx->mysql_thd)) {
+		if (wsrep_innobase_kill_one_trx(NULL, trx, FALSE)) {
+			fprintf(stderr,	"WSREP: kill trx failed for DDL\n");
+		} 
+	} else {
+		fprintf(stderr,	"WSREP: DDL vs BF conflict\n");
+	}
+#endif
 }
 
 /*************************************************************************
@@ -4819,6 +5095,9 @@
 	trx_t*	trx;
 	lock_t*	lock;
 	ulint	err;
+#ifdef WITH_WSREP
+	lock_t *c_lock;
+#endif
 
 	if (flags & BTR_NO_LOCKING_FLAG) {
 
@@ -4864,14 +5143,24 @@
 	had to wait for their insert. Both had waiting gap type lock requests
 	on the successor, which produced an unnecessary deadlock. */
 
-	if (lock_rec_other_has_conflicting(
-		    LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION, next_rec,
-		    trx)) {
+#ifdef WITH_WSREP
+	if ((c_lock = lock_rec_other_has_conflicting
+	    (LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION | WSREP_BF, next_rec, trx))) {
+#else
+	if (lock_rec_other_has_conflicting
+	    (LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION, next_rec, trx)) {
+#endif
 
 		/* Note that we may get DB_SUCCESS also here! */
+#ifdef WITH_WSREP
+		err = lock_rec_enqueue_waiting(c_lock, LOCK_X | LOCK_GAP
+					       | LOCK_INSERT_INTENTION,
+					       next_rec, index, thr);
+#else
 		err = lock_rec_enqueue_waiting(LOCK_X | LOCK_GAP
 					       | LOCK_INSERT_INTENTION,
 					       next_rec, index, thr);
+#endif
 	} else {
 		err = DB_SUCCESS;
 	}

=== modified file 'storage/innobase/os/os0file.c'
--- old/storage/innobase/os/os0file.c	2010-10-28 04:18:59 +0000
+++ new/storage/innobase/os/os0file.c	2011-05-23 11:17:44 +0000
@@ -46,6 +46,12 @@
 /* We do not call os_file_flush in every os_file_write. */
 #endif /* UNIV_DO_FLUSH */
 
+#ifdef WITH_INNODB_DISALLOW_WRITES
+#define WAIT_ALLOW_WRITES() os_event_wait(srv_allow_writes_event)
+#else
+#define WAIT_ALLOW_WRITES() do { } while (0)
+#endif /* WITH_INNODB_DISALLOW_WRITES */
+
 /* We use these mutexes to protect lseek + file i/o operation, if the
 OS does not provide an atomic pread or pwrite, or similar */
 #define OS_FILE_N_SEEK_MUTEXES	16
@@ -550,6 +556,7 @@
 
 	return(NULL);
 #else
+	WAIT_ALLOW_WRITES();
 # ifdef __NETWARE__
 	FILE*	file	= tmpfile();
 # else /* __NETWARE__ */
@@ -847,6 +854,7 @@
 	ibool		fail_if_exists)	/* in: if TRUE, pre-existing directory
 					is treated as an error. */
 {
+	WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	BOOL	rcode;
 
@@ -899,6 +907,8 @@
 				OS_FILE_READ_WRITE */
 	ibool*		success)/* out: TRUE if succeed, FALSE if error */
 {
+	if (create_mode != OS_FILE_OPEN && create_mode != OS_FILE_OPEN_RAW)
+		WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	os_file_t	file;
 	DWORD		create_flag;
@@ -1040,6 +1050,8 @@
 				used by a backup program reading the file */
 	ibool*		success)/* out: TRUE if succeed, FALSE if error */
 {
+	if (create_mode != OS_FILE_OPEN && create_mode != OS_FILE_OPEN_RAW)
+		WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	os_file_t	file;
 	DWORD		create_flag;
@@ -1209,6 +1221,8 @@
 	ulint		type,	/* in: OS_DATA_FILE or OS_LOG_FILE */
 	ibool*		success)/* out: TRUE if succeed, FALSE if error */
 {
+	if (create_mode != OS_FILE_OPEN && create_mode != OS_FILE_OPEN_RAW)
+		WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	os_file_t	file;
 	DWORD		share_mode	= FILE_SHARE_READ;
@@ -1429,6 +1443,7 @@
 				/* out: TRUE if success */
 	const char*	name)	/* in: file path as a null-terminated string */
 {
+	WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	BOOL	ret;
 	ulint	count	= 0;
@@ -1491,6 +1506,7 @@
 				/* out: TRUE if success */
 	const char*	name)	/* in: file path as a null-terminated string */
 {
+	WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	BOOL	ret;
 	ulint	count	= 0;
@@ -1557,6 +1573,7 @@
 				string */
 	const char*	newpath)/* in: new file path */
 {
+	WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	BOOL	ret;
 
@@ -1827,6 +1844,7 @@
 				/* out: TRUE if success */
 	FILE*		file)	/* in: file to be truncated */
 {
+	WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	HANDLE h = (HANDLE) _get_osfhandle(fileno(file));
 	return(SetEndOfFile(h));
@@ -1893,6 +1911,7 @@
 				/* out: TRUE if success */
 	os_file_t	file)	/* in, own: handle to a file */
 {
+	WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	BOOL	ret;
 
@@ -2443,6 +2462,7 @@
 				offset */
 	ulint		n)	/* in: number of bytes to write */
 {
+	WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	BOOL		ret;
 	DWORD		len;

=== modified file 'storage/innobase/plug.in'
--- old/storage/innobase/plug.in	2010-03-30 16:03:46 +0000
+++ new/storage/innobase/plug.in	2011-05-23 11:17:44 +0000
@@ -39,6 +39,12 @@
 		;;
   esac
   AC_SUBST(INNODB_DYNAMIC_CFLAGS)
+  AC_ARG_WITH([innodb-disallow-writes],
+	AS_HELP_STRING([--with-innodb-disallow-writes],
+		       [Allow stopping InnoDB disk writes]),
+	[INNODB_DEFS="$INNODB_DEFS -DWITH_INNODB_DISALLOW_WRITES"],
+	[])
+  AC_SUBST(INNODB_DEFS)
   ])
 
 # vim: set ft=config:

=== modified file 'storage/innobase/rem/rem0rec.c'
--- old/storage/innobase/rem/rem0rec.c	2007-06-14 08:34:23 +0000
+++ new/storage/innobase/rem/rem0rec.c	2012-01-25 20:25:55 +0000
@@ -14,6 +14,9 @@
 
 #include "mtr0mtr.h"
 #include "mtr0log.h"
+#ifdef WITH_WSREP
+#include <ha_prototypes.h>
+#endif // WITH_WSREP
 
 /*			PHYSICAL RECORD (OLD STYLE)
 			===========================
@@ -1513,3 +1516,67 @@
 		}
 	}
 }
+#ifdef WITH_WSREP
+int
+wsrep_rec_get_primary_key(
+	byte 		*buf,     /* out: extracted key */
+	ulint 		*buf_len, /* in/out: length of buf */
+	const rec_t*	rec,	  /* in: physical record */
+	dict_index_t*	index)	  /* in: record descriptor */
+{
+	const byte*	data;
+	ulint		len;
+	ulint		key_len = 0;
+	ulint		i;
+	uint            key_parts = dict_index_get_n_unique_in_tree(index);
+	ut_ad(index);
+	mem_heap_t*	heap	= NULL;
+	ulint		offsets_[REC_OFFS_NORMAL_SIZE];
+	*offsets_ = (sizeof offsets_) / sizeof *offsets_;
+
+	rec_get_offsets(rec, index, offsets_, ULINT_UNDEFINED, &heap);
+	if (UNIV_LIKELY_NULL(heap)) {
+		mem_heap_free(heap);
+	}
+
+	ut_ad(rec_offs_validate(rec, NULL, offsets_));
+
+	ut_ad(rec);
+
+	for (i = 0; i < key_parts; i++) {
+		dict_field_t*	  field = dict_index_get_nth_field(index, i);
+		const dict_col_t* col = dict_field_get_col(field);
+
+		data = rec_get_nth_field(rec, offsets_, i, &len);
+		if (key_len + len > (col->prtype & DATA_NOT_NULL) ?   
+			*buf_len : *buf_len - 1) {
+			goto err_out;
+		}
+
+		if (len == UNIV_SQL_NULL) {
+			ut_a(!(col->prtype & DATA_NOT_NULL));
+			*buf++ = 1;
+			key_len++;
+		} else {
+			if (!(col->prtype & DATA_NOT_NULL)) {
+				*buf++ = 0;
+				key_len++;
+			}
+			memcpy(buf, data, len);
+			wsrep_innobase_mysql_sort(
+				(int)(col->prtype & DATA_MYSQL_TYPE_MASK),
+				(uint)dtype_get_charset_coll(col->prtype),
+				buf, len);
+			key_len += len;
+			buf 	+= len;
+		}
+	}
+
+	rec_validate(rec, offsets_);
+	*buf_len = key_len;
+	return DB_SUCCESS;
+
+ err_out:
+	return DB_ERROR;
+}
+#endif // WITH_WSREP

=== modified file 'storage/innobase/row/row0ins.c'
--- old/storage/innobase/row/row0ins.c	2012-02-16 10:24:11 +0000
+++ new/storage/innobase/row/row0ins.c	2012-04-19 19:26:55 +0000
@@ -11,6 +11,10 @@
 #include "my_sys.h" /* DEBUG_SYNC_C */
 #include "row0ins.h"
 
+#ifdef WITH_WSREP
+#include "ha_prototypes.h"
+#endif /* WITH_WSREP */
+
 #ifdef UNIV_NONINL
 #include "row0ins.ic"
 #endif
@@ -36,6 +40,9 @@
 #define	ROW_INS_PREV	1
 #define	ROW_INS_NEXT	2
 
+#ifdef WITH_WSREP
+extern int wsrep_thd_is_brute_force(void *thd_ptr);
+#endif /* WITH_WSREP */
 
 /*********************************************************************
 This prototype is copied from /mysql/sql/ha_innodb.cc.
@@ -1059,6 +1066,33 @@
 	err = row_update_cascade_for_mysql(thr, cascade,
 					   foreign->foreign_table);
 
+#ifdef WITH_WSREP
+	{
+		byte key[WSREP_MAX_SUPPORTED_KEY_LENGTH+1];
+		ulint len = WSREP_MAX_SUPPORTED_KEY_LENGTH;
+		key[0] = '\0';
+		int rcode = wsrep_rec_get_primary_key(
+			&key[1], &len, clust_rec, clust_index);
+
+		if (rcode == DB_SUCCESS) {
+#ifdef WSREP_DEBUG_PRINT
+			ilint i;
+			fprintf(stderr, "INNODB len: %lu ", len+1);
+			for (i=0; i<len+1; i++) {
+				fprintf(stderr, " %c ", key[i]);
+				fprintf(stderr, " (%X), ", key[i]);
+			}
+			fprintf(stderr, "\n");
+#endif
+			rcode = wsrep_append_foreign_key(
+				thr_get_trx(thr),
+				foreign->foreign_table->name,
+				(char *)key, 
+				len+1,
+				FALSE);
+		}
+	}
+#endif /* WITH_WSREP */
 	if (foreign->foreign_table->n_foreign_key_checks_running == 0) {
 		fprintf(stderr,
 			"InnoDB: error: table %s has the counter 0"
@@ -1639,6 +1673,9 @@
 	que_thr_t*	thr)	/* in: query thread */
 {
 #ifndef UNIV_HOTBACKUP
+#ifdef WITH_WSREP
+	trx_t*		trx = thr_get_trx(thr);
+#endif /* WITH_WSREP */
 	ulint		n_unique;
 	ulint		i;
 	int		cmp;
@@ -1690,9 +1727,13 @@
 
 		offsets = rec_get_offsets(rec, index, offsets,
 					  ULINT_UNDEFINED, &heap);
-
+#ifdef WITH_WSREP
+		/* slave applier must not get duplicate error */
+		if (allow_duplicates ||
+			wsrep_thd_is_brute_force(trx->mysql_thd)) {
+#else /* WITH_WSREP */
 		if (allow_duplicates) {
-
+#endif /* WITH_WSREP */
 			/* If the SQL-query will update or replace
 			duplicate key we will take X-lock for
 			duplicates ( REPLACE, LOAD DATAFILE REPLACE,
@@ -1816,8 +1857,13 @@
 			sure that in roll-forward we get the same duplicate
 			errors as in original execution */
 
+#ifdef WITH_WSREP
+			if (trx->duplicates ||
+				(wsrep_thd_is_brute_force(trx->mysql_thd))) {
+#else
 			if (trx->duplicates) {
 
+#endif
 				/* If the SQL-query will update or replace
 				duplicate key we will take X-lock for
 				duplicates ( REPLACE, LOAD DATAFILE REPLACE,
@@ -1858,7 +1904,12 @@
 			offsets = rec_get_offsets(rec, cursor->index, offsets,
 						  ULINT_UNDEFINED, &heap);
 
+#ifdef WITH_WSREP
+			if (trx->duplicates ||
+				(wsrep_thd_is_brute_force(trx->mysql_thd))) {
+#else
 			if (trx->duplicates) {
+#endif
 
 				/* If the SQL-query will update or replace
 				duplicate key we will take X-lock for

=== modified file 'storage/innobase/srv/srv0srv.c'
--- old/storage/innobase/srv/srv0srv.c	2011-03-30 11:25:58 +0000
+++ new/storage/innobase/srv/srv0srv.c	2012-02-15 21:11:51 +0000
@@ -49,6 +49,10 @@
 #include "row0mysql.h"
 #include "ha_prototypes.h"
 
+#ifdef WITH_WSREP
+extern int wsrep_debug;
+extern int wsrep_trx_is_aborting(void *thd_ptr);
+#endif
 /* This is set to TRUE if the MySQL user has set it in MySQL; currently
 affects only FOREIGN KEY definition parsing */
 ibool	srv_lower_case_table_names	= FALSE;
@@ -133,6 +137,10 @@
 with mutex_enter(), which will wait until it gets the mutex. */
 #define MUTEX_NOWAIT(mutex_skipped)	((mutex_skipped) < MAX_MUTEX_NOWAIT)
 
+#ifdef WITH_INNODB_DISALLOW_WRITES
+os_event_t srv_allow_writes_event;
+#endif /* WITH_INNODB_DISALLOW_WRITES */
+
 byte	srv_latin1_ordering[256]	/* The sort order table of the latin1
 					character set. The following table is
 					the MySQL order as of Feb 10th, 2002 */
@@ -330,6 +338,9 @@
 							free to proceed; but
 							reserved may still be
 							TRUE at that point */
+#ifdef WITH_WSREP
+	void				*thd;		/* to see priority */
+#endif
 	UT_LIST_NODE_T(srv_conc_slot_t)	srv_conc_queue;	/* queue node */
 };
 
@@ -964,7 +975,20 @@
 		conc_slot->reserved = FALSE;
 		conc_slot->event = os_event_create(NULL);
 		ut_a(conc_slot->event);
-	}
+#ifdef WITH_WSREP
+		conc_slot->thd = NULL;
+#endif /* WITH_WSREP */
+	}
+#ifdef WITH_INNODB_DISALLOW_WRITES
+        /*
+           Writes have to be enabled on init or else we hang. Thus, we
+           always set the event here regardless of innobase_disallow_writes.
+           That flag will always be 0 at this point because it isn't settable
+           via my.cnf or command line arg.
+        */
+        srv_allow_writes_event = os_event_create(NULL);
+        os_event_set(srv_allow_writes_event);
+#endif /* WITH_INNODB_DISALLOW_WRITES */
 }
 
 /*************************************************************************
@@ -1030,6 +1054,16 @@
 		return;
 	}
 
+#ifdef WITH_WSREP
+	if (wsrep_thd_is_brute_force(trx->mysql_thd)) {
+		srv_conc_force_enter_innodb(trx);
+		return;
+	}
+	if (wsrep_trx_is_aborting(trx->mysql_thd)) {
+		srv_conc_force_enter_innodb(trx);
+		return;
+	}
+#endif
 	os_fast_mutex_lock(&srv_conc_mutex);
 retry:
 	if (trx->declared_to_be_inside_innodb) {
@@ -1122,6 +1156,9 @@
 	/* Add to the queue */
 	slot->reserved = TRUE;
 	slot->wait_ended = FALSE;
+#ifdef WITH_WSREP
+	slot->thd = trx->mysql_thd;
+#endif
 
 	UT_LIST_ADD_LAST(srv_conc_queue, srv_conc_queue, slot);
 
@@ -1148,7 +1185,9 @@
 	incremented the thread counter on behalf of this thread */
 
 	slot->reserved = FALSE;
-
+#ifdef WITH_WSREP
+	slot->thd = NULL;
+#endif
 	UT_LIST_REMOVE(srv_conc_queue, srv_conc_queue, slot);
 
 	trx->declared_to_be_inside_innodb = TRUE;
@@ -1214,6 +1253,9 @@
 	trx->n_tickets_to_enter_innodb = 0;
 
 	if (srv_conc_n_threads < (lint)srv_thread_concurrency) {
+#ifdef WITH_WSREP
+		srv_conc_slot_t*  wsrep_slot;
+#endif
 		/* Look for a slot where a thread is waiting and no other
 		thread has yet released the thread */
 
@@ -1222,7 +1264,19 @@
 		while (slot && slot->wait_ended == TRUE) {
 			slot = UT_LIST_GET_NEXT(srv_conc_queue, slot);
 		}
-
+#ifdef WITH_WSREP
+		/* look for aborting trx, they must be released asap */
+		wsrep_slot= slot;
+		while (wsrep_slot && (wsrep_slot->wait_ended == TRUE || 
+		    !wsrep_trx_is_aborting(wsrep_slot->thd))) {
+			wsrep_slot = UT_LIST_GET_NEXT(srv_conc_queue, wsrep_slot);
+		}
+		if (wsrep_slot) {
+			slot = wsrep_slot;
+			if (wsrep_debug)
+			    fprintf(stderr, "WSREP: releasing aborting thd\n");
+		}
+#endif
 		if (slot != NULL) {
 			slot->wait_ended = TRUE;
 
@@ -2127,9 +2181,19 @@
 				granted: in that case do nothing */
 
 				if (thr_get_trx(slot->thr)->wait_lock) {
+#ifdef WITH_WSREP
+					if (wsrep_thd_is_brute_force(
+					  (thr_get_trx(slot->thr))->mysql_thd)){
+                                          if (wsrep_debug) fprintf(stderr, 
+						"WSREP: BF lock wait long\n");
+					} else {
+#endif
 					lock_cancel_waiting_and_release(
 						thr_get_trx(slot->thr)
 						->wait_lock);
+#ifdef WITH_WSREP
+					}
+#endif
 				}
 			}
 		}
@@ -2235,7 +2299,20 @@
 
 	if (sync_array_print_long_waits(&waiter, &sema)
 	    && sema == old_sema && os_thread_eq(waiter, old_waiter)) {
+#if defined(WITH_WSREP) && defined(WITH_INNODB_DISALLOW_WRITES)
+	  if (srv_allow_writes_event->is_set) {
+#endif /* WITH_WSREP */
 		fatal_cnt++;
+#if defined(WITH_WSREP) && defined(WITH_INNODB_DISALLOW_WRITES)
+	  } else {
+		fprintf(stderr,
+			"WSREP: avoiding InnoDB self crash due to long "
+			"semaphore wait of  > %lu seconds\n"
+			"Server is processing SST donor operation, "
+			"fatal_cnt now: %lu",
+			(ulong) srv_fatal_semaphore_wait_threshold, fatal_cnt);
+	  }
+#endif /* WITH_WSREP */
 		if (fatal_cnt > 10) {
 
 			fprintf(stderr,

=== modified file 'storage/innobase/trx/trx0roll.c'
--- old/storage/innobase/trx/trx0roll.c	2010-09-14 12:21:32 +0000
+++ new/storage/innobase/trx/trx0roll.c	2011-01-03 13:12:54 +0000
@@ -152,7 +152,11 @@
 	err = trx_general_rollback_for_mysql(trx, FALSE, NULL);
 	
 	trx->op_info = "";
-
+#ifdef WITH_WSREP
+	if (trx->was_chosen_as_deadlock_victim) {
+		trx->was_chosen_as_deadlock_victim = FALSE;
+	}
+#endif
 	return(err);
 }
 
@@ -1102,6 +1106,11 @@
 		srv_que_task_enqueue_low(thr);
 		/*		srv_que_task_enqueue_low(thr2); */
 	}
+#ifdef WITH_WSREP
+	if (trx->was_chosen_as_deadlock_victim) {
+		trx->was_chosen_as_deadlock_victim = FALSE;
+	}
+#endif
 }
 
 /********************************************************************

=== modified file 'storage/innobase/trx/trx0trx.c'
--- old/storage/innobase/trx/trx0trx.c	2011-04-07 18:12:54 +0000
+++ new/storage/innobase/trx/trx0trx.c	2011-09-10 08:42:29 +0000
@@ -953,6 +953,11 @@
 	ut_ad(UT_LIST_GET_LEN(trx->wait_thrs) == 0);
 	ut_ad(UT_LIST_GET_LEN(trx->trx_locks) == 0);
 
+#ifdef WITH_WSREP
+	if (trx->was_chosen_as_deadlock_victim) {
+		trx->was_chosen_as_deadlock_victim = FALSE;
+	}
+#endif
 	UT_LIST_REMOVE(trx_list, trx_sys->trx_list, trx);
 }
 

=== modified file 'storage/innodb_plugin/Makefile.am'
--- old/storage/innodb_plugin/Makefile.am	2010-07-09 11:37:51 +0000
+++ new/storage/innodb_plugin/Makefile.am	2011-05-23 11:17:44 +0000
@@ -24,9 +24,10 @@
 			-I$(top_srcdir)/regex \
 			-I$(srcdir)/include \
 			-I$(top_srcdir)/sql \
+			-I$(srcdir) @WSREP_INCLUDES@ \
 			-I$(srcdir) @ZLIB_INCLUDES@
 
-DEFS=			@DEFS@
+DEFS=			@DEFS@ @INNODB_DEFS@
 
 
 noinst_HEADERS=		\

=== modified file 'storage/innodb_plugin/handler/ha_innodb.cc'
--- old/storage/innodb_plugin/handler/ha_innodb.cc	2012-02-16 10:20:41 +0000
+++ new/storage/innodb_plugin/handler/ha_innodb.cc	2012-04-19 19:26:55 +0000
@@ -83,8 +83,13 @@
 #include "ha_prototypes.h"
 #include "ut0mem.h"
 #include "ibuf0ibuf.h"
+#ifdef WITH_WSREP
+#include "../storage/innobase/include/ut0byte.h"
+#ifndef EXTRA_DEBUG
+  //#include "../storage/innobase/include/ut0byte.ic"
+#endif /* EXTRA_DEBUG */
+#endif /* WITH_WSREP */
 }
-
 #include "ha_innodb.h"
 #include "i_s.h"
 
@@ -100,6 +105,44 @@
 #endif /* MYSQL_VERSION_ID < 50124 */
 #endif /* MYSQL_SERVER */
 
+#ifdef WITH_WSREP
+#include <wsrep_mysqld.h>
+#include <my_md5.h>
+extern my_bool wsrep_certify_nonPK;
+class  binlog_trx_data;
+extern handlerton *binlog_hton;
+
+extern MYSQL_PLUGIN_IMPORT MYSQL_BIN_LOG mysql_bin_log;
+extern MYSQL_PLUGIN_IMPORT pthread_mutex_t LOCK_wsrep_rollback;
+extern MYSQL_PLUGIN_IMPORT pthread_cond_t COND_wsrep_rollback;
+extern MYSQL_PLUGIN_IMPORT wsrep_aborting_thd_t wsrep_aborting_thd;
+
+#ifdef REMOVED
+enum wsrep_trx_status {
+    WSREP_TRX_OK,
+    WSREP_TRX_ROLLBACK,
+    WSREP_TRX_ERROR,
+};
+static enum wsrep_trx_status
+wsrep_run_wsrep_commit(THD *thd, trx_t *trx, handlerton *hton, bool all);
+#endif
+
+static inline wsrep_trx_handle_t*
+wsrep_trx_handle(THD* thd, const trx_t* trx) {
+    return wsrep_trx_handle_for_id(
+        wsrep_thd_trx_handle(thd), 
+        (wsrep_trx_id_t)ut_conv_dulint_to_longlong(trx->id));
+}
+
+extern bool wsrep_prepare_key_for_innodb(const uchar *cache_key,
+					 size_t cache_key_len,
+                                         const uchar* row_id,
+                                         size_t row_id_len,
+                                         wsrep_key_part_t* key,
+                                         size_t* key_len);
+
+#endif /* WITH_WSREP */
+
 /** to protect innobase_open_files */
 static pthread_mutex_t innobase_share_mutex;
 /** to force correct commit order in binlog */
@@ -611,7 +654,6 @@
 
 		return;
 	}
-
 	srv_conc_enter_innodb(trx);
 }
 
@@ -750,7 +792,11 @@
 	}
 	return(0);
 }
-
+#ifdef WITH_WSREP
+static int 
+wsrep_abort_transaction(handlerton* hton, THD *bf_thd, THD *victim_thd, 
+			my_bool signal);
+#endif
 /********************************************************************//**
 Increments innobase_active_counter and every INNOBASE_WAKE_INTERVALth
 time calls srv_active_wake_master_thread. This function should be used
@@ -1177,6 +1223,9 @@
 innobase_mysql_tmpfile(void)
 /*========================*/
 {
+#ifdef WITH_INNODB_DISALLOW_WRITES
+	os_event_wait(srv_allow_writes_event);
+#endif /* WITH_INNODB_DISALLOW_WRITES */
 	int	fd2 = -1;
 	File	fd = mysql_tmpfile("ib");
 	if (fd >= 0) {
@@ -2017,7 +2066,9 @@
         innobase_hton->flags=HTON_NO_FLAGS;
         innobase_hton->release_temporary_latches=innobase_release_temporary_latches;
 	innobase_hton->alter_table_flags = innobase_alter_table_flags;
-
+#ifdef WITH_WSREP
+        innobase_hton->wsrep_abort_transaction=wsrep_abort_transaction;
+#endif /* WITH_WSREP */
 	ut_a(DATA_MYSQL_TRUE_VARCHAR == (ulint)MYSQL_TYPE_VARCHAR);
 
 #ifdef UNIV_DEBUG
@@ -2414,7 +2465,26 @@
 		return;
 	}
 
+#ifdef WITH_WSREP
+	THD* thd = (THD*)trx->mysql_thd;
+	const char* tmp = 0;
+	if (thd) {
+#ifdef WSREP_PROC_INFO
+	char info[64];
+	info[sizeof(info) - 1] = '\0';
+	snprintf(info, sizeof(info) - 1,
+		 "innobase_commit_low():trx_commit_for_mysql(%lld)",
+		 (long long) wsrep_thd_trx_seqno(thd));
+	tmp = thd_proc_info(thd, info);
+#else
+	tmp = thd_proc_info(thd, "innobase_commit_low()");
+#endif /* WSREP_PROC_INFO */
+	}
+#endif /* WITH_WSREP */
 	trx_commit_for_mysql(trx);
+#ifdef WITH_WSREP
+	if (thd) { thd_proc_info(thd, tmp); }
+#endif /* WITH_WSREP */
 }
 
 /*****************************************************************//**
@@ -2516,7 +2586,6 @@
 	}
 	if (all
 		|| (!thd_test_options(thd, OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN))) {
-
 		/* We were instructed to commit the whole transaction, or
 		this is an SQL statement end and autocommit is on */
 
@@ -2570,15 +2639,16 @@
 			pthread_mutex_unlock(&commit_cond_m);
 		}
 
+#ifndef WITH_WSREP
 		if (trx->active_trans == 2) {
 
 			pthread_mutex_unlock(&prepare_commit_mutex);
 		}
+#endif
 
 		/* Now do a write + flush of logs. */
 		trx_commit_complete_for_mysql(trx);
 		trx->active_trans = 0;
-
 	} else {
 		/* We just mark the SQL statement ended and do not do a
 		transaction commit */
@@ -2989,7 +3059,11 @@
 	therefore set to slightly less than 1 / 4 of page size which
 	is 16 kB; but currently MySQL does not work with keys whose
 	size is > MAX_KEY_LENGTH */
+#ifdef WITH_WSREP
+	return(3500);
+#else
 	return(3500);
+#endif
 }
 
 /****************************************************************//**
@@ -4048,7 +4122,96 @@
 
 	return(0);
 }
+#ifdef WITH_WSREP
+extern "C" UNIV_INTERN
+void
+wsrep_innobase_mysql_sort(
+/*===============*/
+					/* out: str contains sort string */
+	int		mysql_type,	/* in: MySQL type */
+	uint		charset_number,	/* in: number of the charset */
+	unsigned char*	str,		/* in: data field */
+	unsigned int	str_length)	/* in: data field length,
+					not UNIV_SQL_NULL */
+{
+	CHARSET_INFO*		charset;
+	enum_field_types	mysql_tp;
+
+	DBUG_ASSERT(str_length != UNIV_SQL_NULL);
+
+	mysql_tp = (enum_field_types) mysql_type;
+
+	switch (mysql_tp) {
 
+	case MYSQL_TYPE_BIT:
+	case MYSQL_TYPE_STRING:
+	case MYSQL_TYPE_VAR_STRING:
+	case MYSQL_TYPE_TINY_BLOB:
+	case MYSQL_TYPE_MEDIUM_BLOB:
+	case MYSQL_TYPE_BLOB:
+	case MYSQL_TYPE_LONG_BLOB:
+	case MYSQL_TYPE_VARCHAR:
+	{
+		uchar tmp_str[DICT_MAX_INDEX_COL_LEN];
+		uint tmp_length = DICT_MAX_INDEX_COL_LEN;
+
+		/* Use the charset number to pick the right charset struct for
+		the comparison. Since the MySQL function get_charset may be
+		slow before Bar removes the mutex operation there, we first
+		look at 2 common charsets directly. */
+
+		if (charset_number == default_charset_info->number) {
+			charset = default_charset_info;
+		} else if (charset_number == my_charset_latin1.number) {
+			charset = &my_charset_latin1;
+		} else {
+			charset = get_charset(charset_number, MYF(MY_WME));
+
+			if (charset == NULL) {
+			  sql_print_error("InnoDB needs charset %lu for doing "
+					  "a comparison, but MySQL cannot "
+					  "find that charset.",
+					  (ulong) charset_number);
+				ut_a(0);
+			}
+		}
+
+		ut_a(str_length <= tmp_length);
+		memcpy(tmp_str, str, str_length);
+
+		tmp_length = charset->coll->strnxfrm(charset, str, str_length,
+						     tmp_str, tmp_length);
+		DBUG_ASSERT(tmp_length == str_length);
+ 
+		break;
+	}
+	case MYSQL_TYPE_DECIMAL :
+	case MYSQL_TYPE_TINY :
+	case MYSQL_TYPE_SHORT :
+	case MYSQL_TYPE_LONG :
+	case MYSQL_TYPE_FLOAT :
+	case MYSQL_TYPE_DOUBLE :
+	case MYSQL_TYPE_NULL :
+	case MYSQL_TYPE_TIMESTAMP :
+	case MYSQL_TYPE_LONGLONG :
+	case MYSQL_TYPE_INT24 :
+	case MYSQL_TYPE_DATE :
+	case MYSQL_TYPE_TIME :
+	case MYSQL_TYPE_DATETIME :
+	case MYSQL_TYPE_YEAR :
+	case MYSQL_TYPE_NEWDATE :
+	case MYSQL_TYPE_NEWDECIMAL :
+	case MYSQL_TYPE_ENUM :
+	case MYSQL_TYPE_SET :
+	case MYSQL_TYPE_GEOMETRY :
+		break;
+	default:
+		break;
+	}
+
+	return;
+}
+#endif // WITH_WSREP
 /**************************************************************//**
 Converts a MySQL type to an InnoDB type. Note that this function returns
 the 'mtype' of InnoDB. InnoDB differentiates between MySQL's old <= 4.1
@@ -4193,6 +4356,257 @@
 /*******************************************************************//**
 Stores a key value for a row to a buffer.
 @return	key value length as stored in buff */
+#ifdef WITH_WSREP
+UNIV_INTERN
+uint
+wsrep_store_key_val_for_row(
+/*===============================*/
+	TABLE*		table,
+	uint		keynr,	/*!< in: key number */
+	uchar*		buff,	/*!< in/out: buffer for the key value (in MySQL
+				format) */
+	uint		buff_len,/*!< in: buffer length */
+	const uchar*	record,  /*!< in: row in MySQL format */
+	ibool*          key_is_null)/*!< out: full key was null */
+{
+	KEY*		key_info	= table->key_info + keynr;
+	KEY_PART_INFO*	key_part	= key_info->key_part;
+	KEY_PART_INFO*	end		= key_part + key_info->key_parts;
+	uchar*		buff_start	= buff;
+	enum_field_types mysql_type;
+	Field*		field;
+
+	DBUG_ENTER("store_key_val_for_row");
+
+	bzero(buff, buff_len);
+	*key_is_null = TRUE;
+
+	for (; key_part != end; key_part++) {
+		uchar sorted[DICT_MAX_INDEX_COL_LEN] = {'\0'};
+		ibool part_is_null = FALSE;
+
+		if (key_part->null_bit) {
+			if (record[key_part->null_offset] &
+			    key_part->null_bit) {
+				*buff = 1;
+				part_is_null = TRUE;
+			} else {
+				*buff = 0;
+			}
+			buff++;
+		}
+		if (!part_is_null)  *key_is_null = FALSE;
+
+		field = key_part->field;
+		mysql_type = field->type();
+
+		if (mysql_type == MYSQL_TYPE_VARCHAR) {
+						/* >= 5.0.3 true VARCHAR */
+			ulint		lenlen;
+			ulint		len;
+			const byte*	data;
+			ulint		key_len;
+			ulint		true_len;
+			CHARSET_INFO*	cs;
+			int		error=0;
+
+			key_len = key_part->length;
+
+			if (part_is_null) {
+				buff += key_len + 2;
+
+				continue;
+			}
+			cs = field->charset();
+
+			lenlen = (ulint)
+				(((Field_varstring*)field)->length_bytes);
+
+			data = row_mysql_read_true_varchar(&len,
+				(byte*) (record
+				+ (ulint)get_field_offset(table, field)),
+				lenlen);
+
+			true_len = len;
+
+			/* For multi byte character sets we need to calculate
+			the true length of the key */
+
+			if (len > 0 && cs->mbmaxlen > 1) {
+				true_len = (ulint) cs->cset->well_formed_len(cs,
+						(const char *) data,
+						(const char *) data + len,
+                                                (uint) (key_len /
+                                                        cs->mbmaxlen),
+						&error);
+			}
+
+			/* In a column prefix index, we may need to truncate
+			the stored value: */
+
+			if (true_len > key_len) {
+				true_len = key_len;
+			}
+
+			memcpy(sorted, data, true_len);
+			wsrep_innobase_mysql_sort(
+			       mysql_type, cs->number, sorted, true_len);
+
+			/* Note that we always reserve the maximum possible
+			length of the true VARCHAR in the key value, though
+			only len first bytes after the 2 length bytes contain
+			actual data. The rest of the space was reset to zero
+			in the bzero() call above. */
+
+			buff += key_len;
+
+		} else if (mysql_type == MYSQL_TYPE_TINY_BLOB
+			|| mysql_type == MYSQL_TYPE_MEDIUM_BLOB
+			|| mysql_type == MYSQL_TYPE_BLOB
+			|| mysql_type == MYSQL_TYPE_LONG_BLOB
+			/* MYSQL_TYPE_GEOMETRY data is treated
+			as BLOB data in innodb. */
+			|| mysql_type == MYSQL_TYPE_GEOMETRY) {
+
+			CHARSET_INFO*	cs;
+			ulint		key_len;
+			ulint		true_len;
+			int		error=0;
+			ulint		blob_len;
+			const byte*	blob_data;
+
+			ut_a(key_part->key_part_flag & HA_PART_KEY_SEG);
+
+			key_len = key_part->length;
+
+			if (part_is_null) {
+				buff += key_len + 2;
+
+				continue;
+			}
+
+			cs = field->charset();
+
+			blob_data = row_mysql_read_blob_ref(&blob_len,
+				(byte*) (record
+				+ (ulint)get_field_offset(table, field)),
+					(ulint) field->pack_length());
+
+			true_len = blob_len;
+
+			ut_a(get_field_offset(table, field)
+				== key_part->offset);
+
+			/* For multi byte character sets we need to calculate
+			the true length of the key */
+
+			if (blob_len > 0 && cs->mbmaxlen > 1) {
+				true_len = (ulint) cs->cset->well_formed_len(cs,
+						(const char *) blob_data,
+						(const char *) blob_data
+							+ blob_len,
+                                                (uint) (key_len /
+                                                        cs->mbmaxlen),
+						&error);
+			}
+
+			/* All indexes on BLOB and TEXT are column prefix
+			indexes, and we may need to truncate the data to be
+			stored in the key value: */
+
+			if (true_len > key_len) {
+				true_len = key_len;
+			}
+
+			memcpy(sorted, blob_data, true_len);
+			wsrep_innobase_mysql_sort(
+			       mysql_type, cs->number, sorted, true_len);
+
+			memcpy(buff, sorted, true_len);
+
+			/* Note that we always reserve the maximum possible
+			length of the BLOB prefix in the key value. */
+
+			buff += key_len;
+		} else {
+			/* Here we handle all other data types except the
+			true VARCHAR, BLOB and TEXT. Note that the column
+			value we store may be also in a column prefix
+			index. */
+
+			CHARSET_INFO*		cs;
+			ulint			true_len;
+			ulint			key_len;
+			const uchar*		src_start;
+			int			error=0;
+			enum_field_types	real_type;
+
+			key_len = key_part->length;
+
+			if (part_is_null) {
+				 buff += key_len;
+
+				 continue;
+			}
+
+			src_start = record + key_part->offset;
+			real_type = field->real_type();
+			true_len = key_len;
+
+			/* Character set for the field is defined only
+			to fields whose type is string and real field
+			type is not enum or set. For these fields check
+			if character set is multi byte. */
+
+			if (real_type != MYSQL_TYPE_ENUM
+				&& real_type != MYSQL_TYPE_SET
+				&& ( mysql_type == MYSQL_TYPE_VAR_STRING
+					|| mysql_type == MYSQL_TYPE_STRING)) {
+
+				cs = field->charset();
+
+				/* For multi byte character sets we need to
+				calculate the true length of the key */
+
+				if (key_len > 0 && cs->mbmaxlen > 1) {
+
+					true_len = (ulint)
+						cs->cset->well_formed_len(cs,
+							(const char *)src_start,
+							(const char *)src_start
+								+ key_len,
+                                                        (uint) (key_len /
+                                                                cs->mbmaxlen),
+							&error);
+				}
+				memcpy(sorted, src_start, true_len);
+				wsrep_innobase_mysql_sort(
+					mysql_type, cs->number, sorted, true_len);
+				memcpy(buff, sorted, true_len);
+			} else {
+				memcpy(buff, src_start, true_len);
+			}
+			buff += true_len;
+
+			/* Pad the unused space with spaces. Note that no
+			padding is ever needed for UCS-2 because in MySQL,
+			all UCS2 characters are 2 bytes, as MySQL does not
+			support surrogate pairs, which are needed to represent
+			characters in the range U+10000 to U+10FFFF. */
+
+			if (true_len < key_len) {
+				ulint pad_len = key_len - true_len;
+				memset(buff, ' ', pad_len);
+				buff += pad_len;
+			}
+		}
+	}
+
+	ut_a(buff <= buff_start + buff_len);
+
+	DBUG_RETURN((uint)(buff - buff_start));
+}
+#endif /* WITH_WSREP */
 UNIV_INTERN
 uint
 ha_innobase::store_key_val_for_row(
@@ -4798,6 +5212,9 @@
 	ulint		error = 0;
         int             error_result= 0;
 	ibool		auto_inc_used= FALSE;
+#ifdef WITH_WSREP
+	ibool           auto_inc_inserted= FALSE; /* if NULL was inserted */
+#endif
 	ulint		sql_command;
 	trx_t*		trx = thd_to_trx(user_thd);
 
@@ -4828,8 +5245,14 @@
 	if ((sql_command == SQLCOM_ALTER_TABLE
 	     || sql_command == SQLCOM_OPTIMIZE
 	     || sql_command == SQLCOM_CREATE_INDEX
+#ifdef WITH_WSREP
+	     || sql_command == SQLCOM_LOAD
+#endif /* WITH_WSREP */
 	     || sql_command == SQLCOM_DROP_INDEX)
 	    && num_write_row >= 10000) {
+#ifdef WITH_WSREP
+		WSREP_DEBUG("forced commit: %s", wsrep_thd_query(user_thd));
+#endif /* WITH_WSREP */
 		/* ALTER TABLE is COMMITted at every 10000 copied rows.
 		The IX table lock for the original table has to be re-issued.
 		As this method will be called on a temporary table where the
@@ -4901,7 +5324,9 @@
 		/* Reset the error code before calling
 		innobase_get_auto_increment(). */
 		prebuilt->autoinc_error = DB_SUCCESS;
-
+#ifdef WITH_WSREP
+		auto_inc_inserted= (table->next_number_field->val_int() == 0);
+#endif
 		if ((error = update_auto_increment())) {
 			/* We don't want to mask autoinc overflow errors. */
 
@@ -4981,6 +5406,28 @@
 			case SQLCOM_REPLACE_SELECT:
 				goto set_max_autoinc;
 
+#ifdef WITH_WSREP
+			/* workaround for LP bug #355000, retrying the insert */
+			case SQLCOM_INSERT:
+				if (auto_inc_inserted &&
+				    wsrep_drupal_282555_workaround &&
+				    !thd_test_options(current_thd, 
+				     OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN)) {
+					WSREP_DEBUG(
+					    "retrying insert: %s",
+					    (*wsrep_thd_query(current_thd)) ? 
+						wsrep_thd_query(current_thd) : 
+						(char *)"void");
+					error= DB_SUCCESS;
+					wsrep_thd_set_conflict_state(
+						current_thd, MUST_ABORT);
+                                        innodb_srv_conc_exit_innodb(prebuilt->trx);
+                                        /* jump straight to func exit over
+                                         * later wsrep hooks */
+                                        goto func_exit;
+				}
+                                break;
+#endif
 			default:
 				break;
 			}
@@ -5028,6 +5475,19 @@
 	error_result = convert_error_code_to_mysql((int) error,
 						   prebuilt->table->flags,
 						   user_thd);
+#ifdef WITH_WSREP
+	if (!error_result && wsrep_thd_exec_mode(user_thd) == LOCAL_STATE &&
+	    wsrep_thd_is_wsrep_on(user_thd) && (sql_command != SQLCOM_LOAD ||
+	    thd_binlog_format(user_thd) == BINLOG_FORMAT_ROW)) {
+
+		if (wsrep_append_keys(user_thd, false, record, NULL)) {
+			DBUG_PRINT("wsrep", ("row key failed"));
+			error_result = HA_ERR_INTERNAL_ERROR;
+			goto wsrep_error;
+		}
+	}
+wsrep_error:
+#endif
 
 func_exit:
 	innobase_active_small();
@@ -5293,6 +5753,19 @@
 
 	innobase_active_small();
 
+#ifdef WITH_WSREP
+	if (!error && wsrep_thd_exec_mode(user_thd) == LOCAL_STATE &&
+            wsrep_thd_is_wsrep_on(user_thd)) {
+		DBUG_PRINT("wsrep", ("update row key"));
+
+		if (wsrep_append_keys(user_thd, false, old_row, new_row)) {
+			DBUG_PRINT("wsrep", ("row key failed"));
+			error = HA_ERR_INTERNAL_ERROR;
+			goto wsrep_error;
+		}
+	}
+wsrep_error:
+#endif
 	DBUG_RETURN(error);
 }
 
@@ -5336,6 +5809,18 @@
 
 	innobase_active_small();
 
+#ifdef WITH_WSREP
+	if (!error && wsrep_thd_exec_mode(user_thd) == LOCAL_STATE &&
+            wsrep_thd_is_wsrep_on(user_thd)) {
+
+		if (wsrep_append_keys(user_thd, false, record, NULL)) {
+			DBUG_PRINT("wsrep", ("delete fail"));
+			error = HA_ERR_INTERNAL_ERROR;
+			goto wsrep_error;
+		}
+	}
+wsrep_error:
+#endif
 	DBUG_RETURN(error);
 }
 
@@ -6096,7 +6581,239 @@
 
 	DBUG_RETURN(error);
 }
+#ifdef WITH_WSREP
+extern "C"
+UNIV_INTERN
+ulint
+wsrep_append_foreign_key(
+/*===========================*/
+	trx_t*		trx,		/*!< in: trx */
+	dict_foreign_t*	foreign,	/*!< in: foreign key constraint */
+	const rec_t*	clust_rec,	/*!<in: clustered index record */
+	dict_index_t*	clust_index,	/*!<in: clustered index */
+	ibool		shared)		/*!<in: is shared access */
+{
+	THD *thd = (THD*)trx->mysql_thd;
+	ulint rcode = DB_SUCCESS;
+	char cache_key[512] = {'\0'};
+
+	if (!wsrep_thd_is_wsrep_on((THD*)(trx->mysql_thd)) || 
+	    wsrep_thd_exec_mode(thd) != LOCAL_STATE) 
+		return DB_SUCCESS;
+
+	byte key[WSREP_MAX_SUPPORTED_KEY_LENGTH+1];
+	ulint len = WSREP_MAX_SUPPORTED_KEY_LENGTH;
+
+	if (!dict_index_is_clust(clust_index)) {
+		WSREP_ERROR("clustered index not passed for FK append");
+		return DB_ERROR;
+	}
+
+	key[0] = '\0';
+	rcode = wsrep_rec_get_primary_key(
+		&key[1], &len, clust_rec, clust_index);
+	if (rcode != DB_SUCCESS) {
+		WSREP_ERROR("FK key set failed: %lu", rcode);
+		return rcode;
+	}
+#ifdef WSREP_DEBUG_PRINT
+	unlint i;
+	fprintf(stderr, "FK parent key, len: %lu ", len+1);
+	for (i=0; i<len+1; i++) {
+		fprintf(stderr, " (%X), ", key[i]);
+	}
+	fprintf(stderr, "\n");
+#endif
+	strncpy(cache_key, foreign->foreign_table->name, 512);
+	char *p = strchr(cache_key, '/');
+	if (p) {
+		*p = '\0';
+	} else {
+		WSREP_WARN("unexpected foreign key table %s", 
+			   foreign->foreign_table->name);
+	}
+
+	wsrep_key_part_t wkey_part[3];
+        wsrep_key_t wkey = {wkey_part, 3};
+	if (!wsrep_prepare_key_for_innodb(
+		(const uchar*)cache_key, 
+		strlen(foreign->foreign_table->name) +  1,
+		(const uchar*)key, len+1,
+		wkey_part,
+		&wkey.key_parts_len)) {
+		WSREP_WARN("key prepare failed for cascaded FK: %s", 
+			   (wsrep_thd_query(thd)) ? 
+			   wsrep_thd_query(thd) : "void");
+		return DB_ERROR;
+	}
+	rcode = (int)wsrep->append_key(
+		wsrep,
+		wsrep_trx_handle(thd, trx),
+		&wkey,
+		1, 
+		shared);
+	if (rcode) {
+		DBUG_PRINT("wsrep", ("row key failed: %lu", rcode));
+		WSREP_ERROR("Appending cascaded fk row key failed: %s, %lu", 
+			    (wsrep_thd_query(thd)) ? 
+			    wsrep_thd_query(thd) : "void", rcode);
+		return DB_ERROR;
+	}
+
+	return DB_SUCCESS;
+}
 
+static int
+wsrep_append_key(
+/*==================*/
+	THD		*thd,
+	trx_t 		*trx,
+	TABLE_SHARE 	*table_share,
+	TABLE 		*table,
+	const uchar*	key,
+	uint16_t        key_len,
+	bool		shared
+)
+{
+	DBUG_ENTER("wsrep_append_key");
+#ifdef WSREP_DEBUG_PRINT
+	fprintf(stderr, "len: %d ", key_len);
+	for (int i=0; i<key_len; i++) {
+		fprintf(stderr, " %c ", key[i]);
+		fprintf(stderr, " (%X), ", key[i]);
+	}
+	fprintf(stderr, "\n");
+#endif
+	wsrep_key_part_t wkey_part[3];
+        wsrep_key_t wkey = {wkey_part, 3};
+	if (!wsrep_prepare_key_for_innodb(
+			(const uchar*)table_share->table_cache_key.str,
+			table_share->table_cache_key.length,
+			key, key_len,
+			wkey_part,
+			&wkey.key_parts_len)) {
+		WSREP_WARN("key prepare failed for: %s", 
+			   (wsrep_thd_query(thd)) ? 
+			   wsrep_thd_query(thd) : "void");
+		DBUG_RETURN(HA_ERR_INTERNAL_ERROR);
+	}
+
+	int rcode = (int)wsrep->append_key(
+			       wsrep,
+			       wsrep_trx_handle(thd, trx),
+			       &wkey,
+			       1,
+			       shared);
+	if (rcode) {
+		DBUG_PRINT("wsrep", ("row key failed: %d", rcode));
+		WSREP_WARN("Appending row key failed: %s, %d", 
+			   (wsrep_thd_query(thd)) ? 
+			   wsrep_thd_query(thd) : "void", rcode);
+		DBUG_RETURN(rcode);
+	}
+	DBUG_RETURN(0);
+}
+int
+ha_innobase::wsrep_append_keys(
+/*==================*/
+	THD 		*thd,
+	bool		shared,
+	const uchar*	record0,	/* in: row in MySQL format */
+	const uchar*	record1)	/* in: row in MySQL format */
+{
+	DBUG_ENTER("wsrep_append_keys");
+	trx_t *trx = thd_to_trx(thd);
+
+	/* if no PK, calculate hash of full row, to be the key value */
+	if (prebuilt->clust_index_was_generated && wsrep_certify_nonPK) {
+		uchar digest[16];
+		int rcode;
+
+		MY_MD5_HASH(digest, (uchar *)record0, table->s->reclength);
+		if ((rcode = wsrep_append_key(thd, trx, table_share, table, 
+					      (const uchar*) digest, 16, 
+					      shared))) {
+			DBUG_RETURN(rcode);
+		}
+		if (record1) {
+			MY_MD5_HASH(digest, (uchar *)record1, table->s->reclength);
+			if ((rcode = wsrep_append_key(thd, trx, table_share, 
+						      table,
+						      (const uchar*) digest, 
+						      16, shared))) {
+				DBUG_RETURN(rcode);
+			}
+		}
+	} else if (wsrep_protocol_version == 0) {
+		uint	len;
+		uchar 	keyval[WSREP_MAX_SUPPORTED_KEY_LENGTH+1] = {'\0'};
+		uchar 	*key 		= &keyval[0];
+		KEY	*key_info	= table->key_info;
+		ibool    is_null;
+
+		len = wsrep_store_key_val_for_row(
+			table, 0, key, key_info->key_length, record0, &is_null);
+		if (!is_null) {
+			int rcode = wsrep_append_key(
+				thd, trx, table_share, table, keyval, 
+				len, shared);
+			if (rcode) DBUG_RETURN(rcode);
+		}
+		else
+		{
+			WSREP_DEBUG("NULL key skipped (proto 0): %s", 
+				    wsrep_thd_query(thd));
+		}
+ 	} else {
+		ut_a(table->s->keys <= 256);
+		uint i;
+		for (i=0; i<table->s->keys; ++i) {
+			uint	len;
+			char 	keyval0[WSREP_MAX_SUPPORTED_KEY_LENGTH+1] = {'\0'};
+			char 	keyval1[WSREP_MAX_SUPPORTED_KEY_LENGTH+1] = {'\0'};
+			char 	*key0 		= &keyval0[1];
+			char 	*key1 		= &keyval1[1];
+			KEY	*key_info	= table->key_info + i;
+			ibool    is_null;
+
+			keyval0[0] = (char)i;
+			keyval0[1] = (char)i;
+
+			if (key_info->flags & HA_NOSAME) {
+				len = wsrep_store_key_val_for_row(
+					table, i, (uchar *)key0, key_info->key_length, 
+					record0, &is_null);
+				if (!is_null) {
+					int rcode = wsrep_append_key(
+						thd, trx, table_share, table, 
+						(const uchar*)keyval0, len+1, 
+						shared);
+					if (rcode) DBUG_RETURN(rcode);
+				}
+				else
+				{
+					WSREP_DEBUG("NULL key skipped: %s", 
+						    wsrep_thd_query(thd));
+				}
+				if (record1) {
+					len = wsrep_store_key_val_for_row(
+						table, i, (uchar *)key1, key_info->key_length, 
+						record1, &is_null);
+					if (!is_null && memcmp(key0, key1, len)) {
+						int rcode = wsrep_append_key(
+							thd, trx, table_share, 
+							table, 
+							(const uchar*)keyval1, 
+							len+1, shared);
+						if (rcode) DBUG_RETURN(rcode);
+					}
+				}
+			}
+		}
+	}
+	DBUG_RETURN(0);
+}
+#endif
 /*********************************************************************//**
 Stores a reference to the current row to 'ref' field of the handle. Note
 that in the case where we have generated the clustered index for the
@@ -10122,7 +10839,11 @@
 		In this case we cannot know how many minutes or hours
 		will be between XA PREPARE and XA COMMIT, and we don't want
 		to block for undefined period of time. */
+#ifdef WITH_WSREP
+                //pthread_mutex_lock(&prepare_commit_mutex);
+#else
 		pthread_mutex_lock(&prepare_commit_mutex);
+#endif
 		trx->active_trans = 2;
 	}
 
@@ -10922,6 +11643,239 @@
 static struct st_mysql_storage_engine innobase_storage_engine=
 { MYSQL_HANDLERTON_INTERFACE_VERSION };
 
+#ifdef WITH_WSREP
+void
+wsrep_abort_slave_trx(wsrep_seqno_t bf_seqno, wsrep_seqno_t victim_seqno)
+{
+	WSREP_ERROR("Trx %lld tries to abort slave trx %lld. This could be "
+		"caused by:\n\t"
+		"1) unsupported configuration options combination, please check documentation.\n\t"
+		"2) a bug in the code.\n\t"
+		"3) a database corruption.\n Node consistency compromized, "
+		"need to abort. Restart the node to resync with cluster.",
+		(long long)bf_seqno, (long long)victim_seqno);
+	abort();
+}
+
+int
+wsrep_innobase_kill_one_trx(trx_t *bf_trx, trx_t *victim_trx, ibool signal)
+{
+	DBUG_ENTER("wsrep_innobase_kill_one_trx");
+	THD *thd          = (THD *) victim_trx->mysql_thd;
+	THD *bf_thd       = (bf_trx) ? (THD *)bf_trx->mysql_thd : NULL;
+	int64_t bf_seqno  = (bf_thd) ? wsrep_thd_trx_seqno(bf_thd) : 0;
+
+	if (!thd) {
+		DBUG_PRINT("wsrep", ("no thd for conflicting lock"));
+		WSREP_WARN("no THD for trx: %ld", 
+			 (long)ut_conv_dulint_to_longlong(victim_trx->id));
+		DBUG_RETURN(1);
+	}
+
+	WSREP_DEBUG("BF kill (%lu, seqno: %lld), victim: (%lu) trx: %lld", 
+ 		    signal, (long long)bf_seqno,
+ 		    wsrep_thd_thread_id(thd),
+		    ut_conv_dulint_to_longlong(victim_trx->id));
+
+	WSREP_DEBUG("Aborting query: %s", 
+		  (thd && wsrep_thd_query(thd)) ? wsrep_thd_query(thd) : "void");
+
+	wsrep_thd_LOCK(thd);
+
+	if (wsrep_thd_query_state(thd) == QUERY_EXITING) {
+		WSREP_DEBUG("kill trx EXITING for %ld",
+			  (long)ut_conv_dulint_to_longlong(victim_trx->id));
+		wsrep_thd_UNLOCK(thd);
+		DBUG_RETURN(0);
+	}
+	if(wsrep_thd_exec_mode(thd) != LOCAL_STATE) {
+		WSREP_DEBUG("withdraw for BF trx: %ld, state: %d",
+			  (long)ut_conv_dulint_to_longlong(victim_trx->id),
+		wsrep_thd_conflict_state(thd));
+	}
+
+	switch (wsrep_thd_conflict_state(thd)) {
+	case NO_CONFLICT: 
+		wsrep_thd_set_conflict_state(thd, MUST_ABORT);
+		break;
+        case MUST_ABORT:
+		WSREP_DEBUG("victim %ld in MUST ABORT state", 
+			 (long)ut_conv_dulint_to_longlong(victim_trx->id));
+		wsrep_thd_UNLOCK(thd);
+		wsrep_thd_awake(thd, signal);
+		DBUG_RETURN(0);
+		break;
+	case ABORTED:
+	case ABORTING: // fall through
+	default:
+		WSREP_DEBUG("victim %ld in state %d", 
+			 (long)ut_conv_dulint_to_longlong(victim_trx->id),
+			 wsrep_thd_conflict_state(thd));
+		wsrep_thd_UNLOCK(thd);
+		DBUG_RETURN(0);
+		break;
+	}
+
+	switch (wsrep_thd_query_state(thd)) {
+	case QUERY_COMMITTING:
+		enum wsrep_status rcode;
+
+		WSREP_DEBUG("kill trx QUERY_COMMITTING for %ld", 
+			  (long)ut_conv_dulint_to_longlong(victim_trx->id));
+
+		if (wsrep_thd_exec_mode(thd) == REPL_RECV) {
+			wsrep_abort_slave_trx(bf_seqno,
+					      wsrep_thd_trx_seqno(thd));
+		} else {
+			rcode = wsrep->abort_pre_commit(
+			    wsrep, bf_seqno,
+			    (wsrep_trx_id_t)ut_conv_dulint_to_longlong(
+				victim_trx->id)
+			);
+			
+			switch (rcode) {
+			case WSREP_WARNING:
+				WSREP_DEBUG("cancel commit warning: %ld",
+					  (long)ut_conv_dulint_to_longlong(
+						victim_trx->id));
+				wsrep_thd_UNLOCK(thd);
+				DBUG_RETURN(1);
+				break;
+			case WSREP_OK:
+				break;
+			default:
+				WSREP_ERROR(
+					"cancel commit bad exit: %d %lld", 
+					rcode, 
+					ut_conv_dulint_to_longlong(
+					victim_trx->id));
+				/* unable to interrupt, must abort */
+				/* note: kill_mysql() will block, if we cannot.
+				 * kill the lock holder first.
+				 */
+				abort();
+				break;
+			}
+		}
+		break;
+	case QUERY_EXEC:
+		/* it is possible that victim trx is itself waiting for some 
+		 * other lock. We need to cancel this waiting
+		 */
+		WSREP_DEBUG("kill trx QUERY_EXEC for %ld", 
+			  (long)ut_conv_dulint_to_longlong(victim_trx->id));
+
+		victim_trx->was_chosen_as_deadlock_victim= TRUE;
+		if (victim_trx->wait_lock) {
+			WSREP_DEBUG("victim has wait flag: %ld",
+				wsrep_thd_thread_id(thd));
+			lock_t*  wait_lock = victim_trx->wait_lock;
+			if (wait_lock) {
+				WSREP_DEBUG("canceling wait lock");
+				victim_trx->was_chosen_as_deadlock_victim= TRUE;
+				lock_cancel_waiting_and_release(wait_lock);
+			}
+
+			wsrep_thd_awake(thd, signal); 
+		} else {
+			/* abort currently executing query */
+			DBUG_PRINT("wsrep",("sending KILL_QUERY to: %ld", 
+                                            wsrep_thd_thread_id(thd)));
+			WSREP_DEBUG("kill query for: %ld",
+				wsrep_thd_thread_id(thd));
+			wsrep_thd_awake(thd, signal); 
+
+			/* for BF thd, we need to prevent him from committing */
+			if (wsrep_thd_exec_mode(thd) == REPL_RECV) {
+				wsrep_abort_slave_trx(bf_seqno,
+						    wsrep_thd_trx_seqno(thd));
+			}
+		}
+		break;
+	case QUERY_IDLE:
+	{
+		bool skip_abort= false;
+		wsrep_aborting_thd_t abortees;
+
+		WSREP_DEBUG("kill IDLE for %ld", 
+			  (long)ut_conv_dulint_to_longlong(victim_trx->id));
+
+		if (wsrep_thd_exec_mode(thd) == REPL_RECV) {
+			WSREP_DEBUG("kill BF IDLE, seqno: %lld",
+				    (long long)wsrep_thd_trx_seqno(thd));
+			wsrep_thd_UNLOCK(thd);
+			wsrep_abort_slave_trx(bf_seqno,
+					      wsrep_thd_trx_seqno(thd));
+			DBUG_RETURN(0);
+		}
+                /* This will lock thd from proceeding after net_read() */
+		wsrep_thd_set_conflict_state(thd, ABORTING);
+
+		(void) pthread_mutex_lock(&LOCK_wsrep_rollback);
+
+		abortees = wsrep_aborting_thd;
+		while (abortees && !skip_abort) {
+			/* check if we have a kill message for this already */
+			if (abortees->aborting_thd == thd) {
+				skip_abort = true;
+				WSREP_WARN("duplicate thd aborter %lu", 
+					  wsrep_thd_thread_id(thd));
+			}
+			abortees = abortees->next;
+		}
+		if (!skip_abort) {
+			wsrep_aborting_thd_t aborting = (wsrep_aborting_thd_t)
+				my_malloc(sizeof(struct wsrep_aborting_thd), 
+					  MYF(0));
+			aborting->aborting_thd  = thd;
+			aborting->next          = wsrep_aborting_thd;
+			wsrep_aborting_thd      = aborting;
+ 			DBUG_PRINT("wsrep",("enqueuing trx abort for %lu",
+                                            wsrep_thd_thread_id(thd)));
+			WSREP_DEBUG("enqueuing trx abort for (%lu)",
+				    wsrep_thd_thread_id(thd));
+		}
+
+		DBUG_PRINT("wsrep",("signalling wsrep rollbacker"));
+		WSREP_DEBUG("signaling aborter");
+		pthread_cond_signal(&COND_wsrep_rollback);
+		(void) pthread_mutex_unlock(&LOCK_wsrep_rollback);
+
+		break;
+	}
+	default:
+		WSREP_WARN("bad wsrep query state: %d", 
+			  wsrep_thd_query_state(thd));
+		break;
+	}
+	wsrep_thd_UNLOCK(thd);
+     
+	DBUG_RETURN(0);
+}
+static int 
+wsrep_abort_transaction(handlerton* hton, THD *bf_thd, THD *victim_thd,
+			my_bool signal)
+{
+	DBUG_ENTER("wsrep_innobase_abort_thd");
+	trx_t* victim_trx = thd_to_trx(victim_thd);
+	trx_t* bf_trx     = (bf_thd) ? thd_to_trx(bf_thd) : NULL;
+
+	if (victim_trx)
+	{
+                mutex_enter(&kernel_mutex);
+                int rcode = wsrep_innobase_kill_one_trx(bf_trx, victim_trx,
+                                                        (ibool)signal);
+                mutex_exit(&kernel_mutex);
+                DBUG_RETURN(rcode);
+	} else {
+		WSREP_DEBUG("victim does not have transaction: thd %ld", 
+			  wsrep_thd_thread_id(victim_thd));
+		wsrep_thd_awake(victim_thd, signal); 
+	}
+	DBUG_RETURN(-1);
+}
+#endif /* WITH_WSREP */
+
 /* plugin options */
 static MYSQL_SYSVAR_BOOL(checksums, innobase_use_checksums,
   PLUGIN_VAR_NOCMDARG | PLUGIN_VAR_READONLY,
@@ -11204,6 +12158,40 @@
   NULL, NULL, 0, 0, 1, 0);
 #endif /* UNIV_DEBUG || UNIV_IBUF_DEBUG */
 
+#ifdef WITH_INNODB_DISALLOW_WRITES
+/*******************************************************
+ *    innobase_disallow_writes variable definition     *
+ *******************************************************/
+ 
+/* Must always init to FALSE. */
+static my_bool	innobase_disallow_writes	= FALSE;
+
+/**************************************************************************
+An "update" method for innobase_disallow_writes variable. */
+static
+void
+innobase_disallow_writes_update(
+/*============================*/
+	THD*			thd,		/* in: thread handle */
+	st_mysql_sys_var*	var,		/* in: pointer to system
+						variable */
+	void*			var_ptr,	/* out: pointer to dynamic
+						variable */
+	const void*		save)		/* in: temporary storage */
+{
+	*(my_bool*)var_ptr = *(my_bool*)save;
+	ut_a(srv_allow_writes_event);
+	if (*(my_bool*)var_ptr)
+		os_event_reset(srv_allow_writes_event);
+	else
+		os_event_set(srv_allow_writes_event);
+}
+
+static MYSQL_SYSVAR_BOOL(disallow_writes, innobase_disallow_writes,
+  PLUGIN_VAR_NOCMDOPT,
+  "Tell InnoDB to stop any writes to disk",
+  NULL, innobase_disallow_writes_update, FALSE);
+#endif /* WITH_INNODB_DISALLOW_WRITES */
 static MYSQL_SYSVAR_BOOL(random_read_ahead, srv_random_read_ahead,
   PLUGIN_VAR_NOCMDARG,
   "Whether to use read ahead for random access within an extent.",
@@ -11280,6 +12268,9 @@
 #if defined UNIV_DEBUG || defined UNIV_IBUF_DEBUG
   MYSQL_SYSVAR(change_buffering_debug),
 #endif /* UNIV_DEBUG || UNIV_IBUF_DEBUG */
+#ifdef WITH_INNODB_DISALLOW_WRITES
+  MYSQL_SYSVAR(disallow_writes),
+#endif /* WITH_INNODB_DISALLOW_WRITES */
   MYSQL_SYSVAR(random_read_ahead),
   MYSQL_SYSVAR(read_ahead_threshold),
   MYSQL_SYSVAR(io_capacity),

=== modified file 'storage/innodb_plugin/handler/ha_innodb.h'
--- old/storage/innodb_plugin/handler/ha_innodb.h	2011-04-11 13:40:28 +0000
+++ new/storage/innodb_plugin/handler/ha_innodb.h	2012-01-27 18:54:43 +0000
@@ -111,6 +111,10 @@
 	dict_index_t* innobase_get_index(uint keynr);
 	int info_low(uint flag, bool called_from_analyze);
 
+#ifdef WITH_WSREP
+	int wsrep_append_keys(THD *thd, bool shared,
+			      const uchar* record0, const uchar* record1);
+#endif
 	/* Init values for the class: */
  public:
 	ha_innobase(handlerton *hton, TABLE_SHARE *table_arg);
@@ -288,6 +292,36 @@
 #endif /* MYSQL_VERSION_ID > 50140 */
 }
 
+#ifdef WITH_WSREP
+//extern "C" int wsrep_trx_order_before(void *thd1, void *thd2);
+
+extern "C" bool wsrep_thd_is_wsrep_on(THD *thd);
+
+extern "C" enum wsrep_exec_mode wsrep_thd_exec_mode(THD *thd);
+extern "C" enum wsrep_conflict_state wsrep_thd_conflict_state(THD *thd);
+extern "C" enum wsrep_query_state wsrep_thd_query_state(THD *thd);
+extern "C" wsrep_trx_handle_t* wsrep_thd_trx_handle(THD *thd);
+
+extern "C" void wsrep_thd_set_exec_mode(THD *thd, enum wsrep_exec_mode mode);
+extern "C" void wsrep_thd_set_query_state(
+	THD *thd, enum wsrep_query_state state);
+extern "C" void wsrep_thd_set_conflict_state(
+	THD *thd, enum wsrep_conflict_state state);
+
+extern "C" void wsrep_thd_set_trx_to_replay(THD *thd, uint64 trx_id);
+
+extern "C"void wsrep_thd_LOCK(THD *thd);
+extern "C"void wsrep_thd_UNLOCK(THD *thd);
+extern "C" uint32 wsrep_thd_wsrep_rand(THD *thd);
+extern "C" time_t wsrep_thd_query_start(THD *thd);
+extern "C" my_thread_id wsrep_thd_thread_id(THD *thd);
+extern "C" int64_t wsrep_thd_trx_seqno(THD *thd);
+extern "C" query_id_t wsrep_thd_query_id(THD *thd);
+extern "C" char * wsrep_thd_query(THD *thd);
+extern "C" query_id_t wsrep_thd_wsrep_last_query_id(THD *thd);
+extern "C" void wsrep_thd_set_wsrep_last_query_id(THD *thd, query_id_t id);
+extern "C" void wsrep_thd_awake(THD *thd, my_bool signal);
+#endif
 typedef struct trx_struct trx_t;
 /********************************************************************//**
 @file handler/ha_innodb.h
@@ -328,3 +362,6 @@
 	ulint		num_of_keys);	/*!< in: Number of indexes to
 					be created. */
 
+#ifdef WITH_WSREP
+extern "C" int wsrep_trx_is_aborting(void *thd_ptr);
+#endif

=== modified file 'storage/innodb_plugin/handler/handler0alter.cc'
--- old/storage/innodb_plugin/handler/handler0alter.cc	2011-04-11 13:40:28 +0000
+++ new/storage/innodb_plugin/handler/handler0alter.cc	2011-09-10 08:42:29 +0000
@@ -34,6 +34,9 @@
 #include "handler0alter.h"
 }
 
+#ifdef WITH_WSREP
+#include "wsrep_api.h"
+#endif
 #include "ha_innodb.h"
 
 /*************************************************************//**

=== modified file 'storage/innodb_plugin/include/dict0mem.h'
--- old/storage/innodb_plugin/include/dict0mem.h	2011-02-08 10:56:23 +0000
+++ new/storage/innodb_plugin/include/dict0mem.h	2011-07-03 19:34:26 +0000
@@ -254,6 +254,9 @@
 constant MUST NOT BE CHANGED, or the compatibility of InnoDB data
 files would be at risk! */
 #define DICT_MAX_INDEX_COL_LEN		REC_MAX_INDEX_COL_LEN
+#ifdef WITH_WSREP
+#define WSREP_MAX_SUPPORTED_KEY_LENGTH 3500
+#endif /* WITH_WSREP */
 
 /** Data structure for a field in an index */
 struct dict_field_struct{

=== modified file 'storage/innodb_plugin/include/ha_prototypes.h'
--- old/storage/innodb_plugin/include/ha_prototypes.h	2010-05-14 13:08:15 +0000
+++ new/storage/innodb_plugin/include/ha_prototypes.h	2012-01-08 11:21:35 +0000
@@ -268,4 +268,13 @@
 	void*	thd);	/*!< in: thread handle (THD*), or NULL to query
 			the global innodb_lock_wait_timeout */
 
+#ifdef WITH_WSREP
+UNIV_INTERN
+int
+wsrep_innobase_kill_one_trx(trx_t *bf_trx, trx_t *victim_trx, ibool signal);
+int wsrep_thd_is_brute_force(void *thd_ptr);
+int wsrep_trx_order_before(void *thd1, void *thd2);
+void wsrep_innobase_mysql_sort(int mysql_type, uint charset_number,
+			       unsigned char* str, unsigned int str_length);
+#endif
 #endif

=== modified file 'storage/innodb_plugin/include/lock0lock.h'
--- old/storage/innodb_plugin/include/lock0lock.h	2010-06-02 10:37:14 +0000
+++ new/storage/innodb_plugin/include/lock0lock.h	2011-09-24 22:18:27 +0000
@@ -796,6 +796,7 @@
 				remains set when the waiting lock is granted,
 				or if the lock is inherited to a neighboring
 				record */
+#define WSREP_BF		4096
 #if (LOCK_WAIT|LOCK_GAP|LOCK_REC_NOT_GAP|LOCK_INSERT_INTENTION)&LOCK_MODE_MASK
 # error
 #endif

=== modified file 'storage/innodb_plugin/include/rem0rec.h'
--- old/storage/innodb_plugin/include/rem0rec.h	2011-06-16 08:51:04 +0000
+++ new/storage/innodb_plugin/include/rem0rec.h	2011-10-12 21:45:28 +0000
@@ -829,6 +829,14 @@
 two upmost bits in a two byte offset for special purposes */
 #define REC_MAX_DATA_SIZE	(16 * 1024)
 
+#ifdef WITH_WSREP
+UNIV_INTERN
+int wsrep_rec_get_primary_key(
+	byte 		*buf,     /* out: extracted key */
+	ulint 		*buf_len, /* in/out: length of buf */
+	const rec_t*	rec,	  /* in: physical record */
+	dict_index_t*	index);	  /* in: record descriptor */
+#endif /* WITH_WSREP */
 #ifndef UNIV_NONINL
 #include "rem0rec.ic"
 #endif

=== modified file 'storage/innodb_plugin/include/srv0srv.h'
--- old/storage/innodb_plugin/include/srv0srv.h	2011-07-19 14:37:37 +0000
+++ new/storage/innodb_plugin/include/srv0srv.h	2011-10-12 21:45:28 +0000
@@ -127,6 +127,10 @@
 extern ulong	srv_flush_log_at_trx_commit;
 extern char	srv_adaptive_flushing;
 
+#ifdef WITH_INNODB_DISALLOW_WRITES
+/* When this event is reset we do not allow any file writes to take place. */
+extern os_event_t	srv_allow_writes_event;
+#endif /* WITH_INNODB_DISALLOW_WRITES */
 
 /* The sort order table of the MySQL latin1_swedish_ci character set
 collation */

=== modified file 'storage/innodb_plugin/lock/lock0lock.c'
--- old/storage/innodb_plugin/lock/lock0lock.c	2010-11-30 09:11:26 +0000
+++ new/storage/innodb_plugin/lock/lock0lock.c	2011-11-15 18:17:15 +0000
@@ -39,6 +39,10 @@
 #include "dict0mem.h"
 #include "trx0sys.h"
 
+#ifdef WITH_WSREP
+extern my_bool wsrep_debug;
+#endif
+
 /* Restricts the length of search we will do in the waits-for
 graph of transactions */
 #define LOCK_MAX_N_STEPS_IN_DEADLOCK_CHECK 1000000
@@ -923,6 +927,15 @@
 	if (trx != lock2->trx
 	    && !lock_mode_compatible(LOCK_MODE_MASK & type_mode,
 				     lock_get_mode(lock2))) {
+#ifdef WITH_WSREP
+		if ((type_mode & WSREP_BF) && (lock2->type_mode & WSREP_BF)) {
+	  		if (wsrep_debug)
+				fprintf(stderr, 
+					"WSREP BF lock modes:  %lu, %lu\n", 
+					lock2->type_mode, type_mode );
+			return FALSE;
+		}
+#endif /* WITH_WSREP */
 
 		/* We have somewhat complex rules when gap type record locks
 		cause waits */
@@ -1440,6 +1453,11 @@
 	return(NULL);
 }
 
+#ifdef WITH_WSREP
+static
+void
+lock_rec_discard(lock_t*	in_lock);
+#endif
 #ifdef UNIV_DEBUG
 /*********************************************************************//**
 Checks if some other transaction has a lock request in the queue.
@@ -1489,6 +1507,27 @@
 }
 #endif /* UNIV_DEBUG */
 
+#ifdef WITH_WSREP
+static void 
+wsrep_kill_victim(trx_t *trx, lock_t *lock) {
+	int bf_this  = wsrep_thd_is_brute_force(trx->mysql_thd);
+	int bf_other = 
+		wsrep_thd_is_brute_force(lock->trx->mysql_thd);
+	if ((bf_this && !bf_other) ||
+		(bf_this && bf_other && wsrep_trx_order_before(
+			trx->mysql_thd, lock->trx->mysql_thd))) {
+          
+		if (lock->trx->que_state == TRX_QUE_LOCK_WAIT) {
+			if (wsrep_debug)
+				fprintf(stderr, "WSREP: BF victim waiting\n");
+			/* cannot release lock, until our lock
+			is in the queue*/
+		} else if (lock->trx != trx) {
+			wsrep_innobase_kill_one_trx(trx, lock->trx, TRUE);
+		}
+	}
+}
+#endif
 /*********************************************************************//**
 Checks if some other transaction has a conflicting explicit lock request
 in the queue, so that we have to wait.
@@ -1518,6 +1557,9 @@
 			do {
 				if (lock_rec_has_to_wait(trx, mode, lock,
 							 TRUE)) {
+#ifdef WITH_WSREP
+					wsrep_kill_victim(trx, lock);
+#endif
 					return(lock);
 				}
 
@@ -1528,6 +1570,9 @@
 			do {
 				if (lock_rec_has_to_wait(trx, mode, lock,
 							 FALSE)) {
+#ifdef WITH_WSREP
+					wsrep_kill_victim(trx, lock);
+#endif
 					return(lock);
 				}
 
@@ -1660,6 +1705,9 @@
 lock_t*
 lock_rec_create(
 /*============*/
+#ifdef WITH_WSREP
+	lock_t*			c_lock,   /* conflicting lock */
+#endif
 	ulint			type_mode,/*!< in: lock mode and wait
 					flag, type is ignored and
 					replaced by LOCK_REC */
@@ -1705,6 +1753,11 @@
 	lock->trx = trx;
 
 	lock->type_mode = (type_mode & ~LOCK_TYPE_MASK) | LOCK_REC;
+#ifdef WITH_WSREP
+	if (wsrep_thd_is_brute_force(trx->mysql_thd)) {
+		lock->type_mode |= WSREP_BF;
+	}
+#endif /* WITH_WSREP */
 	lock->index = index;
 
 	lock->un_member.rec_lock.space = space;
@@ -1719,8 +1772,56 @@
 	/* Set the bit corresponding to rec */
 	lock_rec_set_nth_bit(lock, heap_no);
 
+#ifdef WITH_WSREP
+	if (c_lock && wsrep_thd_is_brute_force(trx->mysql_thd)) {
+        	lock_t *hash = c_lock->hash;
+		lock_t *prev = NULL;
+
+		while (hash &&
+		  wsrep_thd_is_brute_force(hash->trx->mysql_thd) &&
+		  wsrep_trx_order_before(hash->trx->mysql_thd, trx->mysql_thd)){
+			prev = hash;
+			hash = hash->hash;
+		}
+		lock->hash = hash;
+		if (prev) {
+			prev->hash = lock;
+		} else {
+			c_lock->hash = lock;
+		}
+		/*
+		 * delayed conflict resolution '...kill_one_trx' was not called,
+		 * if victim was waiting for some other lock
+		 */
+		if (c_lock && c_lock->trx->que_state == TRX_QUE_LOCK_WAIT) {
+			c_lock->trx->was_chosen_as_deadlock_victim = TRUE;
+			trx->que_state = TRX_QUE_LOCK_WAIT;
+			lock_set_lock_and_trx_wait(lock, trx);
+
+			lock_cancel_waiting_and_release(c_lock->trx->wait_lock);
+
+			/* trx might not wait for c_lock, but some other lock */
+			if (wsrep_debug && c_lock->trx->wait_lock != c_lock) {
+				fprintf(stderr, "WSREP: c_lock != wait lock\n");
+			}
+			if (c_lock->trx->wait_lock == c_lock) {
+				lock_reset_lock_and_trx_wait(lock);
+			}
+
+			if (wsrep_debug)
+				fprintf(stderr, "WSREP: c_lock canceled %lu\n", 
+				(ulong) ut_dulint_get_low(c_lock->trx->id));
+			/* have to bail out here to avoid lock_set_lock... */
+			return(lock);
+		}
+	} else {
+		HASH_INSERT(lock_t, hash, lock_sys->rec_hash,
+			    lock_rec_fold(space, page_no), lock);
+	}
+#else
 	HASH_INSERT(lock_t, hash, lock_sys->rec_hash,
 		    lock_rec_fold(space, page_no), lock);
+#endif
 	if (UNIV_UNLIKELY(type_mode & LOCK_WAIT)) {
 
 		lock_set_lock_and_trx_wait(lock, trx);
@@ -1740,6 +1841,9 @@
 enum db_err
 lock_rec_enqueue_waiting(
 /*=====================*/
+#ifdef WITH_WSREP
+	lock_t*			c_lock,   /* conflicting lock */
+#endif
 	ulint			type_mode,/*!< in: lock mode this
 					transaction is requesting:
 					LOCK_S or LOCK_X, possibly
@@ -1790,8 +1894,16 @@
 	}
 
 	/* Enqueue the lock request that will wait to be granted */
+#ifdef WITH_WSREP
+	if (trx->was_chosen_as_deadlock_victim) {
+		return(DB_DEADLOCK);
+        }
+	lock = lock_rec_create(c_lock, type_mode | LOCK_WAIT, 
+			       block, heap_no, index, trx);
+#else
 	lock = lock_rec_create(type_mode | LOCK_WAIT,
 			       block, heap_no, index, trx);
+#endif
 
 	/* Check if a deadlock occurs: if yes, remove the lock request and
 	return an error code */
@@ -1869,6 +1981,12 @@
 		lock_t*		other_lock
 			= lock_rec_other_has_expl_req(mode, 0, LOCK_WAIT,
 						      block, heap_no, trx);
+#ifdef WITH_WSREP
+		/* this can potentionally assert with wsrep */
+		if (other_lock) {
+			fprintf(stderr, "WSREP: assert should be ignored here");
+		}
+#endif
 		ut_a(!other_lock);
 	}
 #endif /* UNIV_DEBUG */
@@ -1922,7 +2040,11 @@
 	}
 
 somebody_waits:
+#ifdef WITH_WSREP
+	return(lock_rec_create(NULL, type_mode, block, heap_no, index, trx));
+#else
 	return(lock_rec_create(type_mode, block, heap_no, index, trx));
+#endif
 }
 
 /** Record locking request status */
@@ -1980,7 +2102,11 @@
 
 	if (lock == NULL) {
 		if (!impl) {
+#ifdef WITH_WSREP
+			lock_rec_create(NULL, mode, block, heap_no, index, trx);
+#else
 			lock_rec_create(mode, block, heap_no, index, trx);
+#endif
 		}
 
 		return(LOCK_REC_SUCCESS_CREATED);
@@ -2036,6 +2162,9 @@
 	que_thr_t*		thr)	/*!< in: query thread */
 {
 	trx_t*	trx;
+#ifdef WITH_WSREP
+	lock_t *c_lock;
+#endif
 
 	ut_ad(mutex_own(&kernel_mutex));
 	ut_ad((LOCK_MODE_MASK & mode) != LOCK_S
@@ -2054,14 +2183,24 @@
 		/* The trx already has a strong enough lock on rec: do
 		nothing */
 
+#ifdef WITH_WSREP
+	} else if ((c_lock = lock_rec_other_has_conflicting(
+		mode, block, heap_no, trx))) {
+#else
 	} else if (lock_rec_other_has_conflicting(mode, block, heap_no, trx)) {
+#endif
 
 		/* If another transaction has a non-gap conflicting request in
 		the queue, as this transaction does not have a lock strong
 		enough already granted on the record, we have to wait. */
 
+#ifdef WITH_WSREP
+		return(lock_rec_enqueue_waiting(c_lock,mode, block, heap_no,
+						index, thr));
+#else
 		return(lock_rec_enqueue_waiting(mode, block, heap_no,
 						index, thr));
+#endif
 	} else if (!impl) {
 		/* Set the requested lock on the record */
 
@@ -2109,6 +2248,11 @@
 	      || mode - (LOCK_MODE_MASK & mode) == LOCK_REC_NOT_GAP
 	      || mode - (LOCK_MODE_MASK & mode) == 0);
 
+#ifdef WITH_WSREP
+	if (wsrep_thd_is_brute_force(thr_get_trx(thr)->mysql_thd)) {
+		mode |= WSREP_BF;
+	}
+#endif
 	/* We try a simplified and faster subroutine for the most
 	common cases */
 	switch (lock_rec_lock_fast(impl, mode, block, heap_no, index, thr)) {
@@ -3485,6 +3629,34 @@
 					      stderr);
 				}
 #endif /* UNIV_DEBUG */
+#ifdef WITH_WSREP
+				if (wsrep_debug)
+					fputs("WSREP: Deadlock detected\n", ef);
+				if (wsrep_thd_is_brute_force(start->mysql_thd) &&
+				    wsrep_thd_is_brute_force(
+				        wait_lock->trx->mysql_thd) &&
+				    (start != wait_lock->trx)) {
+
+					if (wsrep_trx_order_before(
+					    start->mysql_thd, 
+                                            wait_lock->trx->mysql_thd)) {
+
+						wait_lock->trx->was_chosen_as_deadlock_victim = TRUE;
+						lock_cancel_waiting_and_release(wait_lock);
+						return(LOCK_VICTIM_IS_OTHER);
+					} else {
+						return(LOCK_VICTIM_IS_START);
+					}
+                                }
+#endif
+				if (too_far) {
+
+					fputs("TOO DEEP OR LONG SEARCH"
+					      " IN THE LOCK TABLE"
+					      " WAITS-FOR GRAPH\n", ef);
+
+					return(LOCK_VICTIM_IS_START);
+				}
 
 				if (trx_weight_cmp(wait_lock->trx,
 						   start) >= 0) {
@@ -3493,8 +3665,21 @@
 					choose 'start' as the victim and roll
 					back it */
 
+#ifdef WITH_WSREP
+					if (!wsrep_thd_is_brute_force(
+					    start->mysql_thd)) {
+						return(LOCK_VICTIM_IS_START);
+					}
+#else
 					return(LOCK_VICTIM_IS_START);
+#endif
 				}
+#ifdef WITH_WSREP
+				if (wsrep_thd_is_brute_force(
+				    wait_lock->trx->mysql_thd)) {
+					return(LOCK_VICTIM_IS_START);
+				}
+#endif
 
 				lock_deadlock_found = TRUE;
 
@@ -3579,6 +3764,9 @@
 lock_t*
 lock_table_create(
 /*==============*/
+#ifdef WITH_WSREP
+	lock_t*		c_lock, /* conflicting lock */
+#endif
 	dict_table_t*	table,	/*!< in: database table in dictionary cache */
 	ulint		type_mode,/*!< in: lock mode possibly ORed with
 				LOCK_WAIT */
@@ -3614,7 +3802,25 @@
 
 	lock->un_member.tab_lock.table = table;
 
-	UT_LIST_ADD_LAST(un_member.tab_lock.locks, table->locks, lock);
+#ifdef WITH_WSREP
+	if (c_lock && wsrep_thd_is_brute_force(trx->mysql_thd)) {
+        	UT_LIST_INSERT_AFTER(
+		    un_member.tab_lock.locks, table->locks, c_lock, lock);
+        } else {
+        	UT_LIST_ADD_LAST(un_member.tab_lock.locks, table->locks, lock);
+        }
+
+	if (c_lock && c_lock->trx->que_state == TRX_QUE_LOCK_WAIT) {
+		if (wsrep_debug)
+			fprintf(stderr, "WSREP: table c_lock in wait: %lu\n", 
+			(ulong) ut_dulint_get_low(lock->trx->id));
+		c_lock->trx->was_chosen_as_deadlock_victim = TRUE;
+		lock_cancel_waiting_and_release(c_lock);
+	}
+
+#else
+  	UT_LIST_ADD_LAST(un_member.tab_lock.locks, table->locks, lock);
+#endif
 
 	if (UNIV_UNLIKELY(type_mode & LOCK_WAIT)) {
 
@@ -3760,6 +3966,9 @@
 ulint
 lock_table_enqueue_waiting(
 /*=======================*/
+#ifdef WITH_WSREP
+	lock_t*		c_lock, /* conflicting lock */
+#endif
 	ulint		mode,	/*!< in: lock mode this transaction is
 				requesting */
 	dict_table_t*	table,	/*!< in: table */
@@ -3800,7 +4009,14 @@
 
 	/* Enqueue the lock request that will wait to be granted */
 
+#ifdef WITH_WSREP
+	if (trx->was_chosen_as_deadlock_victim) {
+		return(DB_DEADLOCK);
+	}
+	lock = lock_table_create(c_lock, table, mode | LOCK_WAIT, trx);
+#else
 	lock = lock_table_create(table, mode | LOCK_WAIT, trx);
+#endif
 
 	/* Check if a deadlock occurs: if yes, remove the lock request and
 	return an error code */
@@ -3858,7 +4074,32 @@
 		    && (!lock_mode_compatible(lock_get_mode(lock), mode))
 		    && (wait || !(lock_get_wait(lock)))) {
 
+#ifdef WITH_WSREP
+			int bf_this  = wsrep_thd_is_brute_force(trx->mysql_thd);
+			int bf_other = wsrep_thd_is_brute_force(
+			    lock->trx->mysql_thd);
+			if ((bf_this && !bf_other) ||
+			    (bf_this && bf_other &&
+			     wsrep_trx_order_before(
+				trx->mysql_thd,	lock->trx->mysql_thd)
+			    )
+			) {
+				if (lock->trx->que_state == TRX_QUE_LOCK_WAIT) {
+					if (wsrep_debug) fprintf(stderr, 
+						"WSREP: BF victim  waiting");
+					return(lock);
+				} else {
+                                  if (bf_this && bf_other)
+					wsrep_innobase_kill_one_trx(
+						trx, lock->trx, TRUE);
+					return(lock);
+				}
+			} else {
+				return(lock);
+			}
+#else
 			return(lock);
+#endif
 		}
 
 		lock = UT_LIST_GET_PREV(un_member.tab_lock.locks, lock);
@@ -3881,6 +4122,9 @@
 	enum lock_mode	mode,	/*!< in: lock mode */
 	que_thr_t*	thr)	/*!< in: query thread */
 {
+#ifdef WITH_WSREP
+	lock_t *c_lock;
+#endif
 	trx_t*	trx;
 	ulint	err;
 
@@ -3909,19 +4153,31 @@
 	/* We have to check if the new lock is compatible with any locks
 	other transactions have in the table lock queue. */
 
+#ifdef WITH_WSREP
+	if ((c_lock = lock_table_other_has_incompatible(trx, LOCK_WAIT, table, mode))) {
+#else
 	if (lock_table_other_has_incompatible(trx, LOCK_WAIT, table, mode)) {
+#endif
 
 		/* Another trx has a request on the table in an incompatible
 		mode: this trx may have to wait */
 
+#ifdef WITH_WSREP
+		err = lock_table_enqueue_waiting(c_lock, mode | flags, table, thr);
+#else
 		err = lock_table_enqueue_waiting(mode | flags, table, thr);
+#endif
 
 		lock_mutex_exit_kernel();
 
 		return(err);
 	}
 
+#ifdef WITH_WSREP
+	lock_table_create(c_lock, table, mode | flags, trx);
+#else
 	lock_table_create(table, mode | flags, trx);
+#endif
 
 	ut_a(!flags || mode == LOCK_S || mode == LOCK_X);
 
@@ -4168,7 +4424,6 @@
 	(lock_get_mode(lock) == LOCK_S \
 	 || lock_get_mode(lock) == LOCK_X)
 
-
 /*********************************************************************//**
 Removes locks of a transaction on a table to be dropped.
 If remove_also_table_sx_locks is TRUE then table-level S and X locks are
@@ -5085,6 +5340,9 @@
 	lock_t*		lock;
 	ulint		err;
 	ulint		next_rec_heap_no;
+#ifdef WITH_WSREP
+	lock_t *c_lock;
+#endif
 
 	ut_ad(block->frame == page_align(rec));
 
@@ -5137,15 +5395,28 @@
 	had to wait for their insert. Both had waiting gap type lock requests
 	on the successor, which produced an unnecessary deadlock. */
 
+#ifdef WITH_WSREP
+	if ((c_lock = lock_rec_other_has_conflicting(
+		    LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION | WSREP_BF,
+		    block, next_rec_heap_no, trx))) {
+#else
 	if (lock_rec_other_has_conflicting(
 		    LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION,
 		    block, next_rec_heap_no, trx)) {
+#endif
 
 		/* Note that we may get DB_SUCCESS also here! */
+#ifdef WITH_WSREP
+		err = lock_rec_enqueue_waiting(c_lock, LOCK_X | LOCK_GAP
+					       | LOCK_INSERT_INTENTION,
+					       block, next_rec_heap_no,
+					       index, thr);
+#else
 		err = lock_rec_enqueue_waiting(LOCK_X | LOCK_GAP
 					       | LOCK_INSERT_INTENTION,
 					       block, next_rec_heap_no,
 					       index, thr);
+#endif
 	} else {
 		err = DB_SUCCESS;
 	}

=== modified file 'storage/innodb_plugin/os/os0file.c'
--- old/storage/innodb_plugin/os/os0file.c	2010-10-28 05:10:28 +0000
+++ new/storage/innodb_plugin/os/os0file.c	2011-05-23 11:17:44 +0000
@@ -71,6 +71,12 @@
 /* We do not call os_file_flush in every os_file_write. */
 #endif /* UNIV_DO_FLUSH */
 
+#ifdef WITH_INNODB_DISALLOW_WRITES
+#define WAIT_ALLOW_WRITES() os_event_wait(srv_allow_writes_event)
+#else
+#define WAIT_ALLOW_WRITES() do { } while (0)
+#endif /* WITH_INNODB_DISALLOW_WRITES */
+
 #ifdef UNIV_HOTBACKUP
 # define os_aio_use_native_aio	FALSE
 #else /* UNIV_HOTBACKUP */
@@ -583,6 +589,7 @@
 os_file_create_tmpfile(void)
 /*========================*/
 {
+	WAIT_ALLOW_WRITES();
 #ifdef __NETWARE__
 	FILE*	file	= tmpfile();
 #else /* __NETWARE__ */
@@ -893,6 +900,7 @@
 	ibool		fail_if_exists)	/*!< in: if TRUE, pre-existing directory
 					is treated as an error. */
 {
+	WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	BOOL	rcode;
 
@@ -944,6 +952,8 @@
 				OS_FILE_READ_WRITE */
 	ibool*		success)/*!< out: TRUE if succeed, FALSE if error */
 {
+	if (create_mode != OS_FILE_OPEN && create_mode != OS_FILE_OPEN_RAW)
+		WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	os_file_t	file;
 	DWORD		create_flag;
@@ -1084,6 +1094,8 @@
 				used by a backup program reading the file */
 	ibool*		success)/*!< out: TRUE if succeed, FALSE if error */
 {
+	if (create_mode != OS_FILE_OPEN && create_mode != OS_FILE_OPEN_RAW)
+		WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	os_file_t	file;
 	DWORD		create_flag;
@@ -1249,6 +1261,8 @@
 	ulint		type,	/*!< in: OS_DATA_FILE or OS_LOG_FILE */
 	ibool*		success)/*!< out: TRUE if succeed, FALSE if error */
 {
+	if (create_mode != OS_FILE_OPEN && create_mode != OS_FILE_OPEN_RAW)
+		WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	os_file_t	file;
 	DWORD		share_mode	= FILE_SHARE_READ;
@@ -1485,6 +1499,7 @@
 /*=====================*/
 	const char*	name)	/*!< in: file path as a null-terminated string */
 {
+	WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	BOOL	ret;
 	ulint	count	= 0;
@@ -1547,6 +1562,7 @@
 /*===========*/
 	const char*	name)	/*!< in: file path as a null-terminated string */
 {
+	WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	BOOL	ret;
 	ulint	count	= 0;
@@ -1613,6 +1629,7 @@
 				string */
 	const char*	newpath)/*!< in: new file path */
 {
+	WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	BOOL	ret;
 
@@ -1885,6 +1902,7 @@
 /*============*/
 	FILE*		file)	/*!< in: file to be truncated */
 {
+	WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	HANDLE h = (HANDLE) _get_osfhandle(fileno(file));
 	return(SetEndOfFile(h));
@@ -1951,6 +1969,7 @@
 /*==========*/
 	os_file_t	file)	/*!< in, own: handle to a file */
 {
+	WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	BOOL	ret;
 
@@ -2528,6 +2547,7 @@
 				offset */
 	ulint		n)	/*!< in: number of bytes to write */
 {
+	WAIT_ALLOW_WRITES();
 #ifdef __WIN__
 	BOOL		ret;
 	DWORD		len;

=== modified file 'storage/innodb_plugin/plug.in'
--- old/storage/innodb_plugin/plug.in	2011-01-07 14:52:44 +0000
+++ new/storage/innodb_plugin/plug.in	2011-07-03 18:34:57 +0000
@@ -56,6 +56,13 @@
   esac
   AC_SUBST(INNODB_DYNAMIC_CFLAGS)
 
+  AC_ARG_WITH([innodb-disallow-writes],
+	AS_HELP_STRING([--with-innodb-disallow-writes],
+		       [Allow stopping InnoDB disk writes]),
+	[INNODB_DEFS="$INNODB_DEFS -DWITH_INNODB_DISALLOW_WRITES"],
+	[])
+  AC_SUBST(INNODB_DEFS)
+
   AC_MSG_CHECKING(whether GCC atomic builtins are available)
   # either define HAVE_IB_GCC_ATOMIC_BUILTINS or not
   AC_TRY_RUN(

=== modified file 'storage/innodb_plugin/rem/rem0rec.c'
--- old/storage/innodb_plugin/rem/rem0rec.c	2011-06-16 11:22:12 +0000
+++ new/storage/innodb_plugin/rem/rem0rec.c	2012-01-08 11:21:35 +0000
@@ -31,6 +31,9 @@
 
 #include "mtr0mtr.h"
 #include "mtr0log.h"
+#ifdef WITH_WSREP
+#include <ha_prototypes.h>
+#endif /* WITH_WSREP */
 
 /*			PHYSICAL RECORD (OLD STYLE)
 			===========================
@@ -1772,3 +1775,70 @@
 	}
 }
 #endif /* !UNIV_HOTBACKUP */
+#ifdef WITH_WSREP
+int
+wsrep_rec_get_primary_key(
+	byte 		*buf,     /* out: extracted key */
+	ulint 		*buf_len, /* in/out: length of buf */
+	const rec_t*	rec,	  /* in: physical record */
+	dict_index_t*	index)	  /* in: record descriptor */
+{
+	const byte*	data;
+	ulint		len;
+	ulint		key_len = 0;
+	ulint		i;
+	uint            key_parts = dict_index_get_n_unique_in_tree(index);
+	ut_ad(index);
+	mem_heap_t*	heap	= NULL;
+	ulint		offsets_[REC_OFFS_NORMAL_SIZE];
+	*offsets_ = (sizeof offsets_) / sizeof *offsets_;
+
+	rec_get_offsets(rec, index, offsets_, ULINT_UNDEFINED, &heap);
+	if (UNIV_LIKELY_NULL(heap)) {
+		mem_heap_free(heap);
+	}
+
+	ut_ad(rec_offs_validate(rec, NULL, offsets_));
+
+	ut_ad(rec);
+
+	for (i = 0; i < key_parts; i++) {
+		dict_field_t*	  field = dict_index_get_nth_field(index, i);
+		const dict_col_t* col = dict_field_get_col(field);
+
+		data = rec_get_nth_field(rec, offsets_, i, &len);
+		if (key_len + len > ((col->prtype & DATA_NOT_NULL) ?   
+				     *buf_len : *buf_len - 1)) {
+			fprintf (stderr, 
+				 "WSREP: FK key len exceeded %lu %lu %lu\n", 
+				 key_len, len, *buf_len);
+			goto err_out;
+		}
+
+		if (len == UNIV_SQL_NULL) {
+			ut_a(!(col->prtype & DATA_NOT_NULL));
+			*buf++ = 1;
+			key_len++;
+		} else {
+			if (!(col->prtype & DATA_NOT_NULL)) {
+				*buf++ = 0;
+				key_len++;
+			}
+			memcpy(buf, data, len);
+			wsrep_innobase_mysql_sort(
+				(int)(col->prtype & DATA_MYSQL_TYPE_MASK),
+				(uint)dtype_get_charset_coll(col->prtype),
+				buf, len);
+			key_len += len;
+			buf 	+= len;
+		}
+	}
+
+	rec_validate(rec, offsets_);
+	*buf_len = key_len;
+	return DB_SUCCESS;
+
+ err_out:
+	return DB_ERROR;
+}
+#endif // WITH_WSREP

=== modified file 'storage/innodb_plugin/row/row0ins.c'
--- old/storage/innodb_plugin/row/row0ins.c	2012-02-17 09:42:04 +0000
+++ new/storage/innodb_plugin/row/row0ins.c	2012-04-19 19:26:55 +0000
@@ -771,6 +771,13 @@
 	innobase_invalidate_query_cache(thr_get_trx(thr), buf, len);
 	mem_free(buf);
 }
+#ifdef WITH_WSREP
+ulint wsrep_append_foreign_key(trx_t *trx,  
+			       dict_foreign_t*	foreign,
+			       const rec_t*	clust_rec,
+			       dict_index_t*	clust_index,
+			       ibool		shared);
+#endif /* WITH_WSREP */
 
 /*********************************************************************//**
 Perform referential actions or checks when a parent row is deleted or updated
@@ -1087,6 +1094,16 @@
 	err = row_update_cascade_for_mysql(thr, cascade,
 					   foreign->foreign_table);
 
+#ifdef WITH_WSREP
+	if (err == DB_SUCCESS) {
+		err = wsrep_append_foreign_key(
+			thr_get_trx(thr),
+			foreign,
+			clust_rec, 
+			clust_index,
+			FALSE);
+	}
+#endif /* WITH_WSREP */
 	if (foreign->foreign_table->n_foreign_key_checks_running == 0) {
 		fprintf(stderr,
 			"InnoDB: error: table %s has the counter 0"
@@ -1416,7 +1433,14 @@
 
 				if (check_ref) {
 					err = DB_SUCCESS;
-
+#ifdef WITH_WSREP
+					err = wsrep_append_foreign_key(
+						thr_get_trx(thr),
+						foreign,
+						rec, 
+						check_index,
+						TRUE);
+#endif /* WITH_WSREP */
 					goto end_scan;
 				} else if (foreign->type != 0) {
 					/* There is an ON UPDATE or ON DELETE
@@ -1668,6 +1692,9 @@
 	dtuple_t*	entry,	/*!< in: index entry */
 	que_thr_t*	thr)	/*!< in: query thread */
 {
+#ifdef WITH_WSREP
+	trx_t*		trx = thr_get_trx(thr);
+#endif
 	ulint		n_unique;
 	ulint		i;
 	int		cmp;
@@ -1720,9 +1747,13 @@
 
 		offsets = rec_get_offsets(rec, index, offsets,
 					  ULINT_UNDEFINED, &heap);
-
+#ifdef WITH_WSREP
+		/* slave applier must not get duplicate error */
+		if (allow_duplicates ||
+			wsrep_thd_is_brute_force(trx->mysql_thd)) {
+#else
 		if (allow_duplicates) {
-
+#endif
 			/* If the SQL-query will update or replace
 			duplicate key we will take X-lock for
 			duplicates ( REPLACE, LOAD DATAFILE REPLACE,
@@ -1839,8 +1870,13 @@
 			sure that in roll-forward we get the same duplicate
 			errors as in original execution */
 
+#ifdef WITH_WSREP
+			if (trx->duplicates ||
+				(wsrep_thd_is_brute_force(trx->mysql_thd))) {
+#else
 			if (trx->duplicates) {
 
+#endif
 				/* If the SQL-query will update or replace
 				duplicate key we will take X-lock for
 				duplicates ( REPLACE, LOAD DATAFILE REPLACE,
@@ -1883,7 +1919,12 @@
 			offsets = rec_get_offsets(rec, cursor->index, offsets,
 						  ULINT_UNDEFINED, &heap);
 
+#ifdef WITH_WSREP
+			if (trx->duplicates ||
+				(wsrep_thd_is_brute_force(trx->mysql_thd))) {
+#else
 			if (trx->duplicates) {
+#endif
 
 				/* If the SQL-query will update or replace
 				duplicate key we will take X-lock for

=== modified file 'storage/innodb_plugin/srv/srv0srv.c'
--- old/storage/innodb_plugin/srv/srv0srv.c	2011-07-19 14:37:37 +0000
+++ new/storage/innodb_plugin/srv/srv0srv.c	2012-02-15 21:11:51 +0000
@@ -86,6 +86,10 @@
 #include "trx0i_s.h"
 #include "os0sync.h" /* for HAVE_ATOMIC_BUILTINS */
 
+#ifdef WITH_WSREP
+extern int wsrep_debug;
+extern int wsrep_trx_is_aborting(void *thd_ptr);
+#endif
 /* This is set to TRUE if the MySQL user has set it in MySQL; currently
 affects only FOREIGN KEY definition parsing */
 UNIV_INTERN ibool	srv_lower_case_table_names	= FALSE;
@@ -181,6 +185,10 @@
 with mutex_enter(), which will wait until it gets the mutex. */
 #define MUTEX_NOWAIT(mutex_skipped)	((mutex_skipped) < MAX_MUTEX_NOWAIT)
 
+#ifdef WITH_INNODB_DISALLOW_WRITES
+UNIV_INTERN os_event_t	srv_allow_writes_event;
+#endif /* WITH_INNODB_DISALLOW_WRITES */
+
 /** The sort order table of the MySQL latin1_swedish_ci character set
 collation */
 UNIV_INTERN const byte*	srv_latin1_ordering;
@@ -340,6 +348,9 @@
 							free to proceed; but
 							reserved may still be
 							TRUE at that point */
+#ifdef WITH_WSREP
+	void				*thd;		/*!< to see priority */
+#endif
 	UT_LIST_NODE_T(srv_conc_slot_t)	srv_conc_queue;	/*!< queue node */
 };
 
@@ -999,8 +1010,20 @@
 		conc_slot->reserved = FALSE;
 		conc_slot->event = os_event_create(NULL);
 		ut_a(conc_slot->event);
+#ifdef WITH_WSREP
+		conc_slot->thd = NULL;
+#endif /* WITH_WSREP */
 	}
 
+#ifdef WITH_INNODB_DISALLOW_WRITES
+	/* Writes have to be enabled on init or else we hang. Thus, we
+	always set the event here regardless of innobase_disallow_writes.
+	That flag will always be 0 at this point because it isn't settable
+	via my.cnf or command line arg. */
+	srv_allow_writes_event = os_event_create(NULL);
+	os_event_set(srv_allow_writes_event);
+#endif /* WITH_INNODB_DISALLOW_WRITES */
+
 	/* Initialize some INFORMATION SCHEMA internal structures */
 	trx_i_s_cache_init(trx_i_s_cache);
 }
@@ -1083,6 +1106,16 @@
 		return;
 	}
 
+#ifdef WITH_WSREP
+	if (wsrep_thd_is_brute_force(trx->mysql_thd)) {
+		srv_conc_force_enter_innodb(trx);
+		return;
+	}
+	if (wsrep_trx_is_aborting(trx->mysql_thd)) {
+		srv_conc_force_enter_innodb(trx);
+		return;
+	}
+#endif
 	os_fast_mutex_lock(&srv_conc_mutex);
 retry:
 	if (trx->declared_to_be_inside_innodb) {
@@ -1175,6 +1208,9 @@
 	/* Add to the queue */
 	slot->reserved = TRUE;
 	slot->wait_ended = FALSE;
+#ifdef WITH_WSREP
+	slot->thd = trx->mysql_thd;
+#endif
 
 	UT_LIST_ADD_LAST(srv_conc_queue, srv_conc_queue, slot);
 
@@ -1201,7 +1237,9 @@
 	incremented the thread counter on behalf of this thread */
 
 	slot->reserved = FALSE;
-
+#ifdef WITH_WSREP
+	slot->thd = NULL;
+#endif
 	UT_LIST_REMOVE(srv_conc_queue, srv_conc_queue, slot);
 
 	trx->declared_to_be_inside_innodb = TRUE;
@@ -1267,6 +1305,9 @@
 	trx->n_tickets_to_enter_innodb = 0;
 
 	if (srv_conc_n_threads < (lint)srv_thread_concurrency) {
+#ifdef WITH_WSREP
+		srv_conc_slot_t*  wsrep_slot;
+#endif
 		/* Look for a slot where a thread is waiting and no other
 		thread has yet released the thread */
 
@@ -1275,7 +1316,19 @@
 		while (slot && slot->wait_ended == TRUE) {
 			slot = UT_LIST_GET_NEXT(srv_conc_queue, slot);
 		}
-
+#ifdef WITH_WSREP
+		/* look for aborting trx, they must be released asap */
+		wsrep_slot= slot;
+		while (wsrep_slot && (wsrep_slot->wait_ended == TRUE || 
+		    !wsrep_trx_is_aborting(wsrep_slot->thd))) {
+			wsrep_slot = UT_LIST_GET_NEXT(srv_conc_queue, wsrep_slot);
+		}
+		if (wsrep_slot) {
+			slot = wsrep_slot;
+			if (wsrep_debug)
+			    fprintf(stderr, "WSREP: releasing aborting thd\n");
+		}
+#endif
 		if (slot != NULL) {
 			slot->wait_ended = TRUE;
 
@@ -2185,8 +2238,18 @@
 				granted: in that case do nothing */
 
 				if (trx->wait_lock) {
+#ifdef WITH_WSREP
+					if (wsrep_thd_is_brute_force(
+					  (thr_get_trx(slot->thr))->mysql_thd)){
+					  if (wsrep_debug) fprintf(stderr, 
+						"WSREP: BF lock wait long\n");
+					} else {
+#endif
 					lock_cancel_waiting_and_release(
 						trx->wait_lock);
+#ifdef WITH_WSREP
+					}
+#endif
 				}
 			}
 		}
@@ -2296,7 +2359,20 @@
 
 	if (sync_array_print_long_waits(&waiter, &sema)
 	    && sema == old_sema && os_thread_eq(waiter, old_waiter)) {
+#if defined(WITH_WSREP) && defined(WITH_INNODB_DISALLOW_WRITES)
+	  if (srv_allow_writes_event->is_set) {
+#endif /* WITH_WSREP */
 		fatal_cnt++;
+#if defined(WITH_WSREP) && defined(WITH_INNODB_DISALLOW_WRITES)
+	  } else {
+		fprintf(stderr,
+			"WSREP: avoiding InnoDB self crash due to long "
+			"semaphore wait of  > %lu seconds\n"
+			"Server is processing SST donor operation, "
+			"fatal_cnt now: %lu",
+			(ulong) srv_fatal_semaphore_wait_threshold, fatal_cnt);
+	  }
+#endif /* WITH_WSREP */
 		if (fatal_cnt > 10) {
 
 			fprintf(stderr,

=== modified file 'storage/innodb_plugin/trx/trx0roll.c'
--- old/storage/innodb_plugin/trx/trx0roll.c	2011-01-31 07:56:51 +0000
+++ new/storage/innodb_plugin/trx/trx0roll.c	2011-07-03 19:20:30 +0000
@@ -148,6 +148,11 @@
 
 	trx->op_info = "";
 
+#ifdef WITH_WSREP
+	if (trx->was_chosen_as_deadlock_victim) {
+		trx->was_chosen_as_deadlock_victim = FALSE;
+	}
+#endif
 	return(err);
 }
 
@@ -1127,6 +1132,11 @@
 		srv_que_task_enqueue_low(thr);
 		/*		srv_que_task_enqueue_low(thr2); */
 	}
+#ifdef WITH_WSREP
+	if (trx->was_chosen_as_deadlock_victim) {
+		trx->was_chosen_as_deadlock_victim = FALSE;
+	}
+#endif
 }
 
 /****************************************************************//**

=== modified file 'storage/innodb_plugin/trx/trx0trx.c'
--- old/storage/innodb_plugin/trx/trx0trx.c	2012-02-10 03:09:12 +0000
+++ new/storage/innodb_plugin/trx/trx0trx.c	2012-04-19 19:26:55 +0000
@@ -1007,6 +1007,11 @@
 	ut_ad(UT_LIST_GET_LEN(trx->wait_thrs) == 0);
 	ut_ad(UT_LIST_GET_LEN(trx->trx_locks) == 0);
 
+#ifdef WITH_WSREP
+	if (trx->was_chosen_as_deadlock_victim) {
+		trx->was_chosen_as_deadlock_victim = FALSE;
+	}
+#endif
 	UT_LIST_REMOVE(trx_list, trx_sys->trx_list, trx);
 
 	trx->error_state = DB_SUCCESS;

=== modified file 'support-files/Makefile.am'
--- old/support-files/Makefile.am	2011-06-30 15:37:13 +0000
+++ new/support-files/Makefile.am	2012-05-18 12:02:37 +0000
@@ -53,6 +53,10 @@
 			binary-configure \
 			ndb-config-2-node.ini
 
+if ENABLE_WSREP
+pkgsupp_DATA += wsrep.cnf wsrep_notify
+endif
+
 pkgsupp_SCRIPTS =	mysql.server \
 			mysqld_multi.server
 
@@ -126,6 +130,10 @@
 	  -e 's!@''PERL_DBI_VERSION''@!@PERL_DBI_VERSION@!' \
 	  -e 's!@''PERL_DBD_VERSION''@!@PERL_DBD_VERSION@!' \
 	  -e 's!@''PERL_DATA_DUMPER''@!@PERL_DATA_DUMPER@!' \
+	  -e 's!@''WSREP_API''@!@WSREP_API@!g' \
+	  -e 's!@''WSREP_PATCH''@!@WSREP_PATCH@!g' \
+	  -e 's!@''WSREP_VER''@!@WSREP_VER@!g' \
+	  -e 's!@''WSREP_REV''@!@WSREP_REV@!g' \
 	$< > $@-t
 	@MV@ $@-t $@
 

=== modified file 'support-files/mysql.spec.sh'
--- old/support-files/mysql.spec.sh	2011-10-04 13:58:19 +0000
+++ new/support-files/mysql.spec.sh	2012-05-18 12:02:37 +0000
@@ -102,6 +102,13 @@
 %{?_with_cluster:%define CLUSTER_BUILD 1}
 %{!?_with_cluster:%define CLUSTER_BUILD 0}
 
+# ----------------------------------------------------------------------
+# use "rpmbuild --with wsrep" or "rpm --define '_with_wsrep 1'" (for RPM 3.x)
+# to build with wsrep support (off by default)
+# ----------------------------------------------------------------------
+%{?_with_wsrep:%define WSREP_BUILD 1}
+%{!?_with_wsrep:%define WSREP_BUILD 0}
+
 ##############################################################################
 # Product definitions - set for a "community" package
 ##############################################################################
@@ -119,7 +126,20 @@
 %define NORMAL_TEST_MODE test-bt
 %define DEBUG_TEST_MODE test-bt-debug
 
-%define release 1.glibc23
+#%define release 1.glibc23
+%define release 1.rhel5
+
+%if %{WSREP_BUILD}
+%define server_suffix  -wsrep
+%define package_suffix -wsrep
+%define EMBEDDED_BUILD 0
+%define PARTITION_BUILD 0
+%define WITH_INNODB_PLUGIN 1
+%define wsrep_version @WSREP_API@.@WSREP_PATCH@
+%undefine mysql_version
+%define mysql_version @VERSION@_wsrep_%{wsrep_version}
+#%define wsrep_comment %{ndbug_comment}, wsrep_%{wsrep_version}.r$WSREP_REV
+%endif
 
 %define mysql_license GPL
 %define src_dir mysql-%{mysql_version}
@@ -131,15 +151,21 @@
 Name:		MySQL
 Summary:	MySQL: a very fast and reliable SQL database server
 Group:		Applications/Databases
+%if %{WSREP_BUILD}
+Version:        @MYSQL_U_SCORE_VERSION@_%{wsrep_version}
+%else
 Version:	@MYSQL_U_SCORE_VERSION@
+%endif
 Release:	%{release}
 License:	Copyright (c) 2000, @MYSQL_COPYRIGHT_YEAR@, %{mysql_vendor}. All rights reserved. Under %{mysql_license} license as shown in the Description field.
-Source:		http://www.mysql.com/Downloads/MySQL-@MYSQL_BASE_VERSION@/%{src_dir}.tar.gz
-URL:		http://www.mysql.com/
-Packager:	%{mysql_vendor} Product Engineering Team <build@mysql.com>
+#Source:		http://www.mysql.com/Downloads/MySQL-@MYSQL_BASE_VERSION@/%{src_dir}.tar.gz
+#URL:		http://www.mysql.com/
+Source:		%{src_dir}.tar.gz
+URL:		http://www.codership.com
+Packager:	Codership Oy
 Vendor:		%{mysql_vendor}
 Provides:	msqlormysql MySQL-server mysql
-BuildRequires: ncurses-devel
+BuildRequires:  ncurses-devel
 Obsoletes:	mysql
 
 # Think about what you use here since the first step is to
@@ -167,7 +193,7 @@
 # Sub package definition
 ##############################################################################
 
-%package server
+%package server%{server_suffix}
 Summary:	MySQL: a very fast and reliable SQL database server
 Group:		Applications/Databases
 Requires:	coreutils grep procps /usr/sbin/useradd /usr/sbin/groupadd /sbin/chkconfig
@@ -176,7 +202,7 @@
 Obsoletes:	MySQL-server-classic MySQL-server-community MySQL-server-enterprise
 Obsoletes:	MySQL-server-advanced MySQL-server-advanced-gpl MySQL-server-enterprise-gpl
 
-%description server
+%description server%{server_suffix}
 The MySQL(TM) software delivers a very fast, multi-threaded, multi-user,
 and robust SQL (Structured Query Language) database server. MySQL Server
 is intended for mission-critical, heavy-load production systems as well
@@ -194,8 +220,12 @@
 
 This package includes the MySQL server binary
 %if %{INNODB_BUILD}
+%if %{WSREP_BUILD}
+(configured including InnoDB and wsrep replication)
+%else
 (configured including InnoDB)
 %endif
+%endif
 as well as related utilities to run and administer a MySQL server.
 
 If you want to access and work with the database, you have to install
@@ -343,7 +373,6 @@
 client/server version.
 
 %{see_base}
-
 %endif
 
 ##############################################################################
@@ -450,10 +479,18 @@
 %else
 		--without-plugin-partition \
 %endif
-		--with-plugin-csv \
+%if %{WSREP_BUILD}
+		--with-wsrep \
+		--with-innodb-disallow-writes \
+		--without-plugin-archive \
+		--without-plugin-blackhole \
+		--without-plugin-federated \
+%else
 		--with-plugin-archive \
 		--with-plugin-blackhole \
 		--with-plugin-federated \
+%endif
+		--with-plugin-csv \
 		--without-plugin-daemon_example \
 		--without-plugin-ftexample \
 %if %{EMBEDDED_BUILD}
@@ -466,6 +503,7 @@
 		"
  make
 }
+#		--with-comment=\"%{wsrep_comment}\" \
 # end of function definition "BuildMySQL"
 
 # Use our own copy of glibc
@@ -517,6 +555,7 @@
 BuildMySQL 
 )
 
+%if !%{WSREP_BUILD}
 # We might want to save the config log file
 if test -n "$MYSQL_DEBUGCONFLOG_DEST"
 then
@@ -524,6 +563,7 @@
 fi
 
 (cd mysql-debug-%{mysql_version} ; make test-bt-debug)
+%endif
 
 ##############################################################################
 #
@@ -537,6 +577,7 @@
 CXXFLAGS="$CXXFLAGS" \
 BuildMySQL 
 )
+%if !%{WSREP_BUILD}
 # We might want to save the config log file
 if test -n "$MYSQL_CONFLOG_DEST"
 then
@@ -544,6 +585,7 @@
 fi
 
 (cd mysql-release-%{mysql_version} ; make test-bt)
+%endif
 
 ##############################################################################
 
@@ -615,18 +657,25 @@
 # Create a symlink "rcmysql", pointing to the init.script. SuSE users
 # will appreciate that, as all services usually offer this.
 ln -s %{_sysconfdir}/init.d/mysql $RBR%{_sbindir}/rcmysql
+%if %{WSREP_BUILD}
+install -d $RBR%{_bindir}
+ln -s wsrep_sst_rsync $RBR%{_bindir}/wsrep_sst_rsync_wan
+%endif
 
 # Touch the place where the my.cnf config file and mysqlmanager.passwd
 # (MySQL Instance Manager password file) might be located
 # Just to make sure it's in the file list and marked as a config file
 touch $RBR%{_sysconfdir}/my.cnf
 touch $RBR%{_sysconfdir}/mysqlmanager.passwd
+%if %{WSREP_BUILD}
+touch $RBR%{_sysconfdir}/wsrep.cnf
+%endif
 
 ##############################################################################
 #  Post processing actions, i.e. when installed
 ##############################################################################
 
-%pre server
+%pre server%{server_suffix}
 # This is the code running at the beginning of a RPM upgrade action,
 # before replacing the old files with the new ones.
 
@@ -788,7 +837,7 @@
 	sleep 5
 fi
 
-%post server
+%post server%{server_suffix}
 # This is the code running at the end of a RPM install or upgrade action,
 # after the (new) files have been written.
 
@@ -915,7 +964,7 @@
 if test ! -d $mysql_clusterdir; then mkdir -m 755 $mysql_clusterdir; fi
 %endif
 
-%preun server
+%preun server%{server_suffix}
 if [ $1 = 0 ] ; then
 	# Stop MySQL before uninstalling it
 	if [ -x %{_sysconfdir}/init.d/mysql ] ; then
@@ -944,7 +993,7 @@
 #  Files section
 ##############################################################################
 
-%files server
+%files server%{server_suffix}
 %defattr(-,root,root,0755)
 
 %doc mysql-release-%{mysql_version}/COPYING mysql-release-%{mysql_version}/README
@@ -952,6 +1001,11 @@
 %if %{CLUSTER_BUILD}
 %doc mysql-release-%{mysql_version}/support-files/ndb-*.ini
 %endif
+%if %{WSREP_BUILD}
+%doc mysql-release-%{mysql_version}/support-files/wsrep.cnf
+%doc mysql-release-%{mysql_version}/support-files/wsrep_notify
+%doc mysql-release-%{mysql_version}/Docs/README-wsrep
+%endif
 
 %doc %attr(644, root, root) %{_infodir}/mysql.info*
 
@@ -989,6 +1043,9 @@
 
 %ghost %config(noreplace,missingok) %{_sysconfdir}/my.cnf
 %ghost %config(noreplace,missingok) %{_sysconfdir}/mysqlmanager.passwd
+%if %{WSREP_BUILD}
+%ghost %config(noreplace,missingok) %{_sysconfdir}/wsrep.cnf
+%endif
 
 %if %{INNODB_BUILD}
 %attr(755, root, root) %{_bindir}/innochecksum
@@ -1017,6 +1074,11 @@
 %attr(755, root, root) %{_bindir}/replace
 %attr(755, root, root) %{_bindir}/resolve_stack_dump
 %attr(755, root, root) %{_bindir}/resolveip
+%if %{WSREP_BUILD}
+%attr(755, root, root) %{_bindir}/wsrep_sst_mysqldump
+%attr(755, root, root) %{_bindir}/wsrep_sst_rsync
+%attr(755, root, root) %{_bindir}/wsrep_sst_rsync_wan
+%endif
 
 %attr(755, root, root) %{_sbindir}/mysqld
 %attr(755, root, root) %{_sbindir}/mysqld-debug
@@ -1284,6 +1346,11 @@
 
 - Update variable used for mysql-test suite location to match source.
 
+* Mon Jun 15 2009 Alex Yurchenko <alexey.yurchenko@codership.com>
+
+- Added option to build server RPM with wsrep support. That required
+  ifdefing out all embedded stuff. Use "rpmbuild --with wsrep" for it.
+
 * Fri Nov 07 2008 Joerg Bruehe <joerg@mysql.com>
 
 - Correct yesterday's fix, so that it also works for the last flag,

=== added file 'support-files/wsrep.cnf'
--- old/support-files/wsrep.cnf	1970-01-01 00:00:00 +0000
+++ new/support-files/wsrep.cnf	2012-01-15 05:44:01 +0000
@@ -0,0 +1,119 @@
+# This file contains wsrep-related mysqld options. It should be included
+# in the main MySQL configuration file.
+#
+# Options that need to be customized:
+#  - wsrep_provider
+#  - wsrep_cluster_address
+#  - wsrep_sst_auth
+# The rest of defaults should work out of the box.
+
+##
+## mysqld options _MANDATORY_ for correct opration of the cluster
+##
+[mysqld]
+
+# (This must be substituted by wsrep_format)
+binlog_format=ROW
+
+# Currently only InnoDB storage engine is supported
+default-storage-engine=innodb
+
+# to avoid issues with 'bulk mode inserts' using autoinc
+innodb_autoinc_lock_mode=2
+
+# This is a must for paralell applying
+innodb_locks_unsafe_for_binlog=1
+
+# Query Cache is not supported with wsrep
+query_cache_size=0
+query_cache_type=0
+
+# Override bind-address
+# In some systems bind-address defaults to 127.0.0.1, and with mysqldump SST
+# it will have (most likely) disastrous consequences on donor node
+bind-address=0.0.0.0
+
+##
+## WSREP options
+##
+
+# Full path to wsrep provider library or 'none'
+wsrep_provider=none
+
+# Provider specific configuration options
+#wsrep_provider_options=
+
+# Logical cluster name. Should be the same for all nodes.
+wsrep_cluster_name="my_wsrep_cluster"
+
+# Group communication system handle
+#wsrep_cluster_address="dummy://"
+
+# Human-readable node name (non-unique). Hostname by default.
+#wsrep_node_name=
+
+# Base replication <address|hostname>[:port] of the node.
+# The values supplied will be used as defaults for state transfer receiving,
+# listening ports and so on. Default: address of the first network interface.
+#wsrep_node_address=
+
+# Address for incoming client connections. Autodetect by default.
+#wsrep_node_incoming_address=
+
+# How many threads will process writesets from other nodes
+wsrep_slave_threads=1
+
+# DBUG options for wsrep provider
+#wsrep_dbug_option
+
+# Generate fake primary keys for non-PK tables (required for multi-master
+# and parallel applying operation)
+wsrep_certify_nonPK=1
+
+# Maximum number of rows in write set
+wsrep_max_ws_rows=131072
+
+# Maximum size of write set
+wsrep_max_ws_size=1073741824
+
+# to enable debug level logging, set this to 1
+wsrep_debug=0
+
+# convert locking sessions into transactions
+wsrep_convert_LOCK_to_trx=0
+
+# how many times to retry deadlocked autocommits
+wsrep_retry_autocommit=1
+
+# change auto_increment_increment and auto_increment_offset automatically
+wsrep_auto_increment_control=1
+
+# retry autoinc insert, which failed for duplicate key error
+wsrep_drupal_282555_workaround=0
+
+# Command to call when node status or cluster membership changes.
+# Will be passed all or some of the following options:
+# --status  - new status of this node
+# --uuid    - UUID of the cluster
+# --primary - whether the component is primary or not ("yes"/"no")
+# --members - comma-separated list of members
+# --index   - index of this node in the list
+wsrep_notify_cmd=
+
+##
+## WSREP State Transfer options
+##
+
+# State Snapshot Transfer method
+wsrep_sst_method=mysqldump
+
+# Address on THIS node to receive SST at. DON'T SET IT TO DONOR ADDRESS!!!
+# (SST method dependent. Defaults to the first IP of the first interface)
+#wsrep_sst_receive_address=
+
+# SST authentication string. This will be used to send SST to joining nodes.
+# Depends on SST method. For mysqldump method it is root:<root password>
+wsrep_sst_auth=root:
+
+# Desired SST donor name.
+#wsrep_sst_donor=

=== added file 'support-files/wsrep_notify'
--- old/support-files/wsrep_notify	1970-01-01 00:00:00 +0000
+++ new/support-files/wsrep_notify	2012-05-18 12:02:37 +0000
@@ -0,0 +1,102 @@
+#!/bin/sh -eu
+
+# This is a simple example of wsrep notification script (wsrep_notify_cmd).
+# It will create 'wsrep' schema and two tables in it: 'membeship' and 'status'
+# and fill them on every membership or node status change.
+#
+# Edit parameters below to specify the address and login to server.
+
+USER=root
+PSWD=rootpass
+HOST=127.0.0.1
+PORT=3306
+
+SCHEMA="wsrep"
+MEMB_TABLE="$SCHEMA.membership"
+STATUS_TABLE="$SCHEMA.status"
+
+BEGIN="
+SET wsrep_on=0;
+DROP SCHEMA IF EXISTS $SCHEMA; CREATE SCHEMA $SCHEMA;
+CREATE TABLE $MEMB_TABLE (
+    idx  INT UNIQUE PRIMARY KEY,
+    uuid CHAR(40) UNIQUE, /* node UUID */
+    name VARCHAR(32),     /* node name */
+    addr VARCHAR(256)     /* node address */
+) ENGINE=MEMORY;
+CREATE TABLE $STATUS_TABLE (
+    size   INT,      /* component size   */
+    idx    INT,      /* this node index  */
+    status CHAR(16), /* this node status */
+    uuid   CHAR(40), /* cluster UUID */
+    prim   BOOLEAN   /* if component is primary */
+) ENGINE=MEMORY;
+BEGIN;
+DELETE FROM $MEMB_TABLE;
+DELETE FROM $STATUS_TABLE;
+"
+END="COMMIT;"
+
+configuration_change()
+{
+    echo "$BEGIN;"
+
+    local idx=0
+
+    for NODE in $(echo $MEMBERS | sed s/,/\ /g)
+    do
+        echo "INSERT INTO $MEMB_TABLE VALUES ( $idx, "
+        # Don't forget to properly quote string values
+        echo "'$NODE'" | sed  s/\\//\',\'/g
+        echo ");"
+        idx=$(( $idx + 1 ))
+    done
+
+    echo "INSERT INTO $STATUS_TABLE VALUES($idx, $INDEX, '$STATUS', '$CLUSTER_UUID', $PRIMARY);"
+
+    echo "$END"
+}
+
+status_update()
+{
+    echo "SET wsrep_on=0; BEGIN; UPDATE $STATUS_TABLE SET status='$STATUS'; COMMIT;"
+}
+
+COM=status_update # not a configuration change by default
+
+while [ $# -gt 0 ]
+do
+    case $1 in
+    --status)
+        STATUS=$2
+        shift
+        ;;
+    --uuid)
+        CLUSTER_UUID=$2
+        shift
+        ;;
+    --primary)
+        [ "$2" = "yes" ] && PRIMARY="1" || PRIMARY="0"
+        COM=configuration_change
+        shift
+        ;;
+    --index)
+        INDEX=$2
+        shift
+        ;;
+    --members)
+        MEMBERS=$2
+        shift
+        ;;
+    esac
+    shift
+done
+
+# Undefined means node is shutting down
+if [ "$STATUS" != "Undefined" ]
+then
+    $COM | mysql -B -u$USER -p$PSWD -h$HOST -P$PORT
+fi
+
+exit 0
+#

=== added directory 'wsrep'
=== added file 'wsrep/Makefile.am'
--- old/wsrep/Makefile.am	1970-01-01 00:00:00 +0000
+++ new/wsrep/Makefile.am	2012-01-23 11:57:02 +0000
@@ -0,0 +1,2 @@
+noinst_LIBRARIES = libwsrep.a
+libwsrep_a_SOURCES = wsrep_api.h wsrep_loader.c wsrep_dummy.c wsrep_uuid.c

=== added file 'wsrep/wsrep_api.h'
--- old/wsrep/wsrep_api.h	1970-01-01 00:00:00 +0000
+++ new/wsrep/wsrep_api.h	2012-01-27 18:54:43 +0000
@@ -0,0 +1,875 @@
+/* Copyright (C) 2009-2011 Codership Oy <info@codership.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef WSREP_H
+#define WSREP_H
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <time.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*!
+ *  wsrep replication API
+ */
+
+#define WSREP_INTERFACE_VERSION "23"
+
+/*!
+ *  Certain provider capabilities application may need to know
+ */
+#define WSREP_CAP_MULTI_MASTER          ( 1ULL << 0 )
+#define WSREP_CAP_CERTIFICATION         ( 1ULL << 1 )
+#define WSREP_CAP_PARALLEL_APPLYING     ( 1ULL << 2 )
+#define WSREP_CAP_TRX_REPLAY            ( 1ULL << 3 )
+#define WSREP_CAP_ISOLATION             ( 1ULL << 4 )
+#define WSREP_CAP_PAUSE                 ( 1ULL << 5 )
+#define WSREP_CAP_CAUSAL_READS          ( 1ULL << 6 )
+#define WSREP_CAP_CAUSAL_TRX            ( 1ULL << 7 )
+#define WSREP_CAP_WRITE_SET_INCREMENTS  ( 1ULL << 8 )
+#define WSREP_CAP_SESSION_LOCKS         ( 1ULL << 9 )
+#define WSREP_CAP_DISTRIBUTED_LOCKS     ( 1ULL << 10 )
+#define WSREP_CAP_CONSISTENCY_CHECK     ( 1ULL << 11 )
+
+/*!
+ *  Write set replication flags
+ */
+#define WSREP_FLAG_PA_SAFE              ( 1ULL << 0 )
+
+/* Empty backend spec */
+#define WSREP_NONE "none"
+
+typedef uint64_t wsrep_trx_id_t;  //!< application transaction ID
+typedef uint64_t wsrep_conn_id_t; //!< application connection ID
+typedef int64_t  wsrep_seqno_t;   //!< sequence number of a writeset, etc.
+
+/*! undefined seqno */
+#define WSREP_SEQNO_UNDEFINED (-1)
+
+/*! wsrep status codes */
+typedef enum wsrep_status {
+    WSREP_OK        = 0,   //!< success
+    WSREP_WARNING,         //!< minor warning, error logged
+    WSREP_TRX_MISSING,     //!< transaction is not known by wsrep
+    WSREP_TRX_FAIL,        //!< transaction aborted, server can continue
+    WSREP_BF_ABORT,        //!< trx was victim of brute force abort
+    WSREP_CONN_FAIL,       //!< error in client connection, must abort
+    WSREP_NODE_FAIL,       //!< error in node state, wsrep must reinit
+    WSREP_FATAL,           //!< fatal error, server must abort
+    WSREP_NOT_IMPLEMENTED  //!< feature not implemented
+} wsrep_status_t;
+
+/*!
+ * @brief log severity levels, passed as first argument to log handler
+ */
+typedef enum wsrep_log_level
+{
+    WSREP_LOG_FATAL, //!< Unrecoverable error, application must quit.
+    WSREP_LOG_ERROR, //!< Operation failed, must be repeated.
+    WSREP_LOG_WARN,  //!< Unexpected condition, but no operational failure.
+    WSREP_LOG_INFO,  //!< Informational message.
+    WSREP_LOG_DEBUG  //!< Debug message. Shows only of compiled with debug.
+} wsrep_log_level_t;
+
+/*!
+ * @brief error log handler
+ *
+ *        All messages from wsrep library are directed to this
+ *        handler, if present.
+ *
+ * @param level   log level
+ * @param message log message
+ */
+typedef void (*wsrep_log_cb_t)(wsrep_log_level_t, const char *);
+
+/*!
+ * UUID type - for all unique IDs
+ */
+typedef struct wsrep_uuid {
+    uint8_t uuid[16];
+} wsrep_uuid_t;
+
+/*! Undefined UUID */
+static const wsrep_uuid_t WSREP_UUID_UNDEFINED = {{0,}};
+
+/*!
+ * Scan UUID from string
+ * @return length of UUID string representation or negative error code
+ */
+extern ssize_t
+wsrep_uuid_scan (const char* str, size_t str_len, wsrep_uuid_t* uuid);
+
+/*!
+ * Print UUID to string
+ * @return length of UUID string representation or negative error code
+ */
+extern ssize_t
+wsrep_uuid_print (const wsrep_uuid_t* uuid, char* str, size_t str_len);
+
+#define WSREP_MEMBER_NAME_LEN 32  //!< maximum logical member name length
+#define WSREP_INCOMING_LEN    256 //!< max Domain Name length + 0x00
+
+/*!
+ * member status
+ */
+typedef enum wsrep_member_status {
+    WSREP_MEMBER_UNDEFINED, //!< undefined state
+    WSREP_MEMBER_JOINER,    //!< incomplete state, requested state transfer
+    WSREP_MEMBER_DONOR,     //!< complete state, donates state transfer
+    WSREP_MEMBER_JOINED,    //!< complete state
+    WSREP_MEMBER_SYNCED,    //!< complete state, synchronized with group
+    WSREP_MEMBER_ERROR,     //!< this and above is provider-specific error code
+    WSREP_MEMBER_MAX
+} wsrep_member_status_t;
+
+/*!
+ * static information about a group member (some fields are tentative yet)
+ */
+typedef struct wsrep_member_info {
+    wsrep_uuid_t id;                           //!< group-wide unique member ID
+    char         name[WSREP_MEMBER_NAME_LEN];  //!< human-readable name
+    char         incoming[WSREP_INCOMING_LEN]; //!< address for client requests
+} wsrep_member_info_t;
+
+/*!
+ * group status
+ */
+typedef enum wsrep_view_status {
+    WSREP_VIEW_PRIMARY,      //!< primary group configuration (quorum present)
+    WSREP_VIEW_NON_PRIMARY,  //!< non-primary group configuration (quorum lost)
+    WSREP_VIEW_DISCONNECTED, //!< not connected to group, retrying.
+    WSREP_VIEW_MAX
+} wsrep_view_status_t;
+
+/*!
+ * view of the group
+ */
+typedef struct wsrep_view_info {
+    wsrep_uuid_t        uuid;      //!< global state UUID
+    wsrep_seqno_t       seqno;     //!< global state seqno
+    wsrep_seqno_t       view;      //!< global view number
+    wsrep_view_status_t status;    //!< view status
+    bool                state_gap; //!< gap between global and local states
+    int                 my_idx;    //!< index of this member in the view
+    int                 memb_num;  //!< number of members in the view
+    int                 proto_ver; //!< application protocol agreed on in the view
+    wsrep_member_info_t members[1]; //!< array of member information
+} wsrep_view_info_t;
+
+/*!
+ * Magic string to tell provider to engage into trivial (empty) state transfer.
+ * No data will be passed, but the node shall be considered JOINED.
+ * Should be passed in sst_req parameter of wsrep_view_cb_t.
+ */
+#define WSREP_STATE_TRANSFER_TRIVIAL "trivial"
+
+/*!
+ * Magic string to tell provider not to engage in state transfer at all.
+ * The member will stay in WSREP_MEMBER_UNDEFINED state but will keep on
+ * receiving all writesets.
+ * Should be passed in sst_req parameter of wsrep_view_cb_t.
+ */
+#define WSREP_STATE_TRANSFER_NONE "none"
+
+/*!
+ * @brief group view handler
+ *
+ * This handler is called in total order corresponding to the group
+ * configuration change. It is to provide a vital information about
+ * new group view. If view info indicates existence of discontinuity
+ * between group and member states, state transfer request message
+ * should be filled in by the callback implementation.
+ *
+ * @note Currently it is assumed that sst_req is allocated using
+ *       malloc()/calloc()/realloc() and it will be freed by
+ *       wsrep implementation.
+ *
+ * @param app_ctx     application context
+ * @param recv_ctx    receiver context
+ * @param view        new view on the group
+ * @param state       current state
+ * @param state_len   lenght of current state
+ * @param sst_req     location to store SST request
+ * @param sst_req_len location to store SST request length or error code
+ *                    value of 0 means no SST.
+ */
+typedef void (*wsrep_view_cb_t) (void*                    app_ctx,
+                                 void*                    recv_ctx,
+                                 const wsrep_view_info_t* view,
+                                 const char*              state,
+                                 size_t                   state_len,
+                                 void**                   sst_req,
+                                 ssize_t*                 sst_req_len);
+
+/*!
+ * @brief apply callback
+ *
+ * This handler is called from wsrep library to apply replicated write set
+ * Must support brute force applying for multi-master operation
+ *
+ * @param recv_ctx receiver context pointer provided by the application
+ * @param data     data buffer containing the write set
+ * @param size     data buffer size
+ * @param seqno    global seqno part of the write set to be applied
+ *
+ * @return success code:
+ * @retval WSREP_OK
+ * @retval WSREP_NOT_IMPLEMENTED appl. does not support the write set format
+ * @retval WSREP_ERROR failed to apply the write set
+ */
+typedef enum wsrep_status (*wsrep_apply_cb_t)   (void*               recv_ctx,
+                                                 const void*         data,
+                                                 size_t              size,
+                                                 wsrep_seqno_t       seqno);
+
+/*!
+ * @brief commit callback
+ *
+ * This handler is called to commit the changes made by apply callback.
+ *
+ * @param recv_ctx receiver context pointer provided by the application
+ * @param seqno    global seqno part of the write set to be committed
+ * @param commit   true - commit writeset, false - rollback writeset
+ *
+ * @return success code:
+ * @retval WSREP_OK
+ * @retval WSREP_ERROR call failed
+ */
+typedef enum wsrep_status (*wsrep_commit_cb_t)  (void*         recv_ctx,
+                                                 wsrep_seqno_t seqno,
+                                                 bool          commit);
+
+/*!
+ * @brief a callback to donate state snapshot
+ *
+ * This handler is called from wsrep library when it needs this node
+ * to deliver state to a new cluster member.
+ * No state changes will be committed for the duration of this call.
+ * Wsrep implementation may provide internal state to be transmitted
+ * to new cluster member for initial state.
+ *
+ * @param app_ctx   application context
+ * @param recv_ctx  receiver context
+ * @param msg       state transfer request message
+ * @param msg_len   state transfer request message length
+ * @param uuid      current state uuid on this node
+ * @param seqno     current state seqno on this node
+ * @param state     current wsrep internal state buffer
+ * @param state_len current wsrep internal state buffer len
+ * @param bypass    bypass snapshot transfer, only transfer uuid:seqno pair
+ * @return 0 for success or negative error code
+ */
+typedef int (*wsrep_sst_donate_cb_t) (void*               app_ctx,
+                                      void*               recv_ctx,
+                                      const void*         msg,
+                                      size_t              msg_len,
+                                      const wsrep_uuid_t* uuid,
+                                      wsrep_seqno_t       seqno,
+                                      const char*         state,
+                                      size_t              state_len,
+                                      bool                bypass);
+
+/*!
+ * @brief a callback to signal application that wsrep state is synced
+ *        with cluster
+ *
+ * This callback is called after wsrep library has got in sync with
+ * rest of the cluster.
+ *
+ * @param app_ctx application context
+ */
+typedef void (*wsrep_synced_cb_t)(void* app_ctx);
+
+
+/*!
+ * Initialization parameters for wsrep, used as arguments for wsrep_init()
+ */
+struct wsrep_init_args
+{
+    void* app_ctx;             //!< Application context for callbacks
+
+    /* Configuration parameters */
+    const char* node_name;     //!< Symbolic name of this node (e.g. hostname)
+    const char* node_address;  //!< Address to be used by wsrep provider
+    const char* node_incoming; //!< Address for incoming client connections
+    const char* data_dir;      //!< Directory where wsrep files are kept if any
+    const char* options;       //!< Provider-specific configuration string
+    int         proto_ver;     //!< Max supported application protocol version
+
+    /* Application initial state information. */
+    const wsrep_uuid_t* state_uuid;  //!< Application state sequence UUID
+    wsrep_seqno_t       state_seqno; //!< Applicaiton state sequence number
+    const char*         state;       //!< Initial state for wsrep implementation
+    size_t              state_len;   //!< Length of state buffer
+
+    /* Application callbacks */
+    wsrep_log_cb_t        logger_cb;       //!< logging handler
+    wsrep_view_cb_t       view_handler_cb; //!< group view change handler
+
+    /* applier callbacks */
+    wsrep_apply_cb_t      apply_cb;        //!< apply  callback
+    wsrep_commit_cb_t     commit_cb;       //!< commit callback
+
+    /* state snapshot transfer callbacks */
+    wsrep_sst_donate_cb_t sst_donate_cb;   //!< starting to donate
+    wsrep_synced_cb_t     synced_cb;       //!< synced with group
+};
+
+/*! Type of the stats variable value in struct wsrep_status_var */
+typedef enum wsrep_var_type
+{
+    WSREP_VAR_STRING, //!< pointer to null-terminated string
+    WSREP_VAR_INT64,  //!< int64_t
+    WSREP_VAR_DOUBLE  //!< double
+}
+wsrep_var_type_t;
+
+/*! Generalized stats variable representation */
+struct wsrep_stats_var
+{
+    const char*      name;     //!< variable name
+    wsrep_var_type_t type;     //!< variable value type
+    union {
+        int64_t     _int64;
+        double      _double;
+        const char* _string;
+    } value;                   //!< variable value
+};
+
+
+/*! Key part structure */
+typedef struct wsrep_key_part_
+{
+    const void* buf;     /*!< Buffer containing key part data */
+    size_t      buf_len; /*!< Length of buffer */
+} wsrep_key_part_t;
+
+/*! Key struct used to pass certification keys for transaction handling calls.
+ *  A key consists of zero or more key parts. */
+typedef struct wsrep_key_
+{
+    const wsrep_key_part_t* key_parts;     /*!< Array of key parts        */
+    size_t                  key_parts_len; /*!< Length of key parts array */
+} wsrep_key_t;
+
+/*! Transaction handle struct passed for wsrep transaction handling calls */
+typedef struct wsrep_trx_handle_
+{
+    wsrep_trx_id_t trx_id; //!< transaction ID
+    void*          opaque; //!< opaque provider transaction context data
+} wsrep_trx_handle_t;
+
+/*!
+ * @brief Helper method to reset trx handle state when trx id changes
+ *
+ * Instead of passing wsrep_trx_handle_t directly for wsrep calls,
+ * wrapping handle with this call offloads bookkeeping from
+ * application.
+ */
+static inline wsrep_trx_handle_t* wsrep_trx_handle_for_id(
+    wsrep_trx_handle_t* trx_handle,
+    wsrep_trx_id_t      trx_id)
+{
+    if (trx_handle->trx_id != trx_id)
+    {
+        trx_handle->trx_id = trx_id;
+        trx_handle->opaque = NULL;
+    }
+    return trx_handle;
+}
+
+
+typedef struct wsrep_ wsrep_t;
+/*!
+ * wsrep interface for dynamically loadable libraries
+ */
+struct wsrep_ {
+
+    const char *version; //!< interface version string
+
+  /*!
+   * @brief Initializes wsrep provider
+   *
+   * @param wsrep this wsrep handle
+   * @param args  wsrep initialization parameters
+   */
+    wsrep_status_t (*init)   (wsrep_t*                      wsrep,
+                              const struct wsrep_init_args* args);
+
+  /*!
+   * @brief Returns provider capabilities flag bitmap
+   *
+   * @param wsrep this wsrep handle
+   */
+    uint64_t (*capabilities) (wsrep_t* wsrep);
+
+  /*!
+   * @brief Passes provider-specific configuration string to provider.
+   *
+   * @param wsrep this wsrep handle
+   * @param conf  configuration string
+   *
+   * @retval WSREP_OK      configuration string was parsed successfully
+   * @retval WSREP_WARNING could't not parse conf string, no action taken
+   */
+    wsrep_status_t (*options_set) (wsrep_t* wsrep, const char* conf);
+
+  /*!
+   * @brief Returns provider-specific string with current configuration values.
+   *
+   * @param wsrep this wsrep handle
+   *
+   * @return a dynamically allocated string with current configuration
+   *         parameter values
+   */
+    char*          (*options_get) (wsrep_t* wsrep);
+
+  /*!
+   * @brief Opens connection to cluster
+   *
+   * Returns when either node is ready to operate as a part of the clsuter
+   * or fails to reach operating status.
+   *
+   * @param wsrep        this wsrep handle
+   * @param cluster_name unique symbolic cluster name
+   * @param cluster_url  URL-like cluster address (backend://address)
+   * @param state_donor  name of the node to be asked for state transfer.
+   */
+    wsrep_status_t (*connect) (wsrep_t*    wsrep,
+                               const char* cluster_name,
+                               const char* cluster_url,
+                               const char* state_donor);
+
+  /*!
+   * @brief Closes connection to cluster.
+   *
+   * If state_uuid and/or state_seqno is not NULL, will store final state
+   * in there.
+   *
+   * @param wsrep this  wsrep handler
+   */
+    wsrep_status_t (*disconnect)(wsrep_t* wsrep);
+
+  /*!
+   * @brief start receiving replication events
+   *
+   * This function never returns
+   *
+   * @param wsrep this wsrep handle
+   * @param recv_ctx receiver context
+   */
+    wsrep_status_t (*recv)(wsrep_t* wsrep, void* recv_ctx);
+
+  /*!
+   * @brief Replicates/logs result of transaction to other nodes and allocates
+   * required resources.
+   *
+   * Must be called before transaction commit. Returns success code, which
+   * caller must check.
+   * In case of WSREP_OK, starts commit critical section, transaction can
+   * commit. Otherwise transaction must rollback.
+   *
+   * @param wsrep      this wsrep handle
+   * @param trx_handle transaction which is committing
+   * @param conn_id    connection ID
+   * @param app_data   application specific applying data
+   * @param data_len   the size of the applying data
+   * @param flags      fine tuning the replication WSREP_FLAG_*
+   * @param seqno      seqno part of the global transaction ID
+   *
+   * @retval WSREP_OK         cluster-wide commit succeeded
+   * @retval WSREP_TRX_FAIL   must rollback transaction
+   * @retval WSREP_CONN_FAIL  must close client connection
+   * @retval WSREP_NODE_FAIL  must close all connections and reinit
+   */
+    wsrep_status_t (*pre_commit)(wsrep_t*            wsrep,
+                                 wsrep_conn_id_t     conn_id,
+                                 wsrep_trx_handle_t* trx_handle,
+                                 const void*         app_data,
+                                 size_t              data_len,
+                                 uint64_t            flags,
+                                 wsrep_seqno_t*      seqno);
+
+  /*!
+   * @brief Releases resources after transaction commit.
+   *
+   * Ends commit critical section.
+   *
+   * @param wsrep      this wsrep handle
+   * @param trx_handle transaction which is committing
+   * @retval WSREP_OK  post_commit succeeded
+   */
+    wsrep_status_t (*post_commit) (wsrep_t*            wsrep,
+                                   wsrep_trx_handle_t* trx_handle);
+
+  /*!
+   * @brief Releases resources after transaction rollback.
+   *
+   * @param wsrep      this wsrep handle
+   * @param trx_handle transaction which is committing
+   * @retval WSREP_OK  post_rollback succeeded
+   */
+    wsrep_status_t (*post_rollback)(wsrep_t*            wsrep,
+                                    wsrep_trx_handle_t* trx_handle);
+
+  /*!
+   * @brief Replay trx as a slave write set
+   *
+   * If local trx has been aborted by brute force, and it has already
+   * replicated before this abort, we must try if we can apply it as
+   * slave trx. Note that slave nodes see only trx write sets and certification
+   * test based on write set content can be different to DBMS lock conflicts.
+   *
+   * @param wsrep      this wsrep handle
+   * @param trx_handle transaction which is committing
+   * @param trx_ctx    transaction context
+   *
+   * @retval WSREP_OK         cluster commit succeeded
+   * @retval WSREP_TRX_FAIL   must rollback transaction
+   * @retval WSREP_BF_ABORT   brute force abort happened after trx replicated
+   *                          must rollback transaction and try to replay
+   * @retval WSREP_CONN_FAIL  must close client connection
+   * @retval WSREP_NODE_FAIL  must close all connections and reinit
+   */
+    wsrep_status_t (*replay_trx)(wsrep_t*            wsrep,
+                                 wsrep_trx_handle_t* trx_handle,
+                                 void*               trx_ctx);
+
+  /*!
+   * @brief Abort pre_commit() call of another thread.
+   *
+   * It is possible, that some high-priority transaction needs to abort
+   * another transaction which is in pre_commit() call waiting for resources.
+   *
+   * The kill routine checks that abort is not attmpted against a transaction
+   * which is front of the caller (in total order).
+   *
+   * @param wsrep      this wsrep handle
+   * @param bf_seqno   seqno of brute force trx, running this cancel
+   * @param victim_trx transaction to be aborted, and which is committing
+   *
+   * @retval WSREP_OK         abort secceded
+   * @retval WSREP_WARNING    abort failed
+   */
+    wsrep_status_t (*abort_pre_commit)(wsrep_t*       wsrep,
+                                       wsrep_seqno_t  bf_seqno,
+                                       wsrep_trx_id_t victim_trx);
+
+  /*!
+   * @brief Appends a query in transaction's write set
+   *
+   * @param wsrep      this wsrep handle
+   * @param trx_handle transaction handle
+   * @param query      SQL statement string
+   * @param timeval    time to use for time functions
+   * @param randseed   seed for rand
+   */
+    wsrep_status_t (*append_query)(wsrep_t*            wsrep,
+                                   wsrep_trx_handle_t* trx_handle,
+                                   const char*         query,
+                                   time_t              timeval,
+                                   uint32_t            randseed);
+
+  /*!
+   * @brief Appends a row reference in transaction's write set
+   *
+   * @param wsrep       this wsrep handle
+   * @param trx_handle  transaction handle
+   * @param key         array of keys
+   * @param key_len     length of the array of keys
+   * @param shared      boolean denoting if key corresponds to shared resource
+   */
+    wsrep_status_t (*append_key)(wsrep_t*            wsrep,
+                                 wsrep_trx_handle_t* trx_handle,
+                                 const wsrep_key_t*  key,
+                                 size_t              key_len,
+                                 bool                shared);
+   /*!
+    * @brief Appends data in transaction's write set
+    *
+    * This method can be called any time before commit and it
+    * appends data block into transaction's write set.
+    *
+    * @param wsrep      this wsrep handle
+    * @param trx_handle transaction handle
+    * @param data data  buffer
+    * @param data_len   data buffer length
+    */
+    wsrep_status_t (*append_data)(wsrep_t*            wsrep,
+                                  wsrep_trx_handle_t* trx_handle,
+                                  const void*         data,
+                                  size_t              data_len);
+
+
+  /*!
+   * @brief Get causal ordering for read operation
+   *
+   * This call will block until causal ordering with all possible
+   * preceding writes in the cluster is guaranteed. If pointer to
+   * seqno is non-null, the call stores the global transaction ID
+   * of the last transaction which is guaranteed to be ordered
+   * causally before this call.
+   *
+   * @param wsrep this wsrep handle
+   * @param seqno location to store global transaction ID
+   */
+    wsrep_status_t (*causal_read)(wsrep_t* wsrep, wsrep_seqno_t* seqno);
+
+  /*!
+   * @brief Clears allocated connection context.
+   *
+   * Whenever a new connection ID is passed to wsrep provider through
+   * any of the API calls, a connection context is allocated for this
+   * connection. This call is to explicitly notify provider fo connection
+   * closing.
+   *
+   * @param wsrep       this wsrep handle
+   * @param conn_id     connection ID
+   * @param query       the 'set database' query
+   * @param query_len   length of query (does not end with 0)
+   */
+    wsrep_status_t (*free_connection)(wsrep_t*        wsrep,
+                                      wsrep_conn_id_t conn_id);
+
+  /*!
+   * @brief Replicates a query and starts "total order isolation" section.
+   *
+   * Replicates the query and returns success code, which
+   * caller must check. Total order isolation continues
+   * until to_execute_end() is called.
+   *
+   * @param wsrep       this wsrep handle
+   * @param conn_id     connection ID
+   * @param key         array of keys
+   * @param key_len     lenght of the array of keys
+   * @param query       query to be executed
+   * @param query_len   length of the query string
+   * @param seqno       seqno part of the action ID
+   *
+   * @retval WSREP_OK         cluster commit succeeded
+   * @retval WSREP_CONN_FAIL  must close client connection
+   * @retval WSREP_NODE_FAIL  must close all connections and reinit
+   */
+    wsrep_status_t (*to_execute_start)(wsrep_t*           wsrep,
+                                       wsrep_conn_id_t    conn_id,
+                                       const wsrep_key_t* key,
+                                       size_t             key_len,
+                                       const void*        query,
+                                       size_t             query_len,
+                                       wsrep_seqno_t*     seqno);
+
+  /*!
+   * @brief Ends the total order isolation section.
+   *
+   * Marks the end of total order isolation. TO locks are freed
+   * and other transactions are free to commit from this point on.
+   *
+   * @param wsrep this wsrep handle
+   * @param conn_id connection ID
+   *
+   * @retval WSREP_OK         cluster commit succeeded
+   * @retval WSREP_CONN_FAIL  must close client connection
+   * @retval WSREP_NODE_FAIL  must close all connections and reinit
+   */
+    wsrep_status_t (*to_execute_end)(wsrep_t* wsrep, wsrep_conn_id_t conn_id);
+
+  /*!
+   * @brief Signals to wsrep provider that state snapshot has been sent to
+   *        joiner.
+   *
+   * @param wsrep  this wsrep handle
+   * @param uuid   sequence UUID (group UUID)
+   * @param seqno  sequence number or negative error code of the operation
+   */
+    wsrep_status_t (*sst_sent)(wsrep_t*            wsrep,
+                               const wsrep_uuid_t* uuid,
+                               wsrep_seqno_t       seqno);
+
+  /*!
+   * @brief Signals to wsrep provider that new state snapshot has been received.
+   *        May deadlock if called from sst_prepare_cb.
+   *
+   * @param wsrep     this wsrep handle
+   * @param uuid      sequence UUID (group UUID)
+   * @param seqno     sequence number or negative error code of the operation
+   * @param state     initial state provided by SST donor
+   * @param state_len length of state buffer
+   */
+    wsrep_status_t (*sst_received)(wsrep_t*            wsrep,
+                                   const wsrep_uuid_t* uuid,
+                                   wsrep_seqno_t       seqno,
+                                   const char*         state,
+                                   size_t              state_len);
+
+
+  /*!
+   * @brief Generate request for consistent snapshot.
+   *
+   * If successfull, this call will generate internally SST request
+   * which in turn triggers calling SST donate callback on the nodes
+   * specified in donor_spec. If donor_spec is null, callback is
+   * called only locally. This call will block until sst_sent is called
+   * from callback.
+   *
+   * @param wsrep   this wsrep handle
+   * @param msg     context message for SST donate callback
+   * @param msg_len length of context message
+   * @param donor_spec list of snapshot donors
+   */
+    wsrep_status_t (*snapshot)(wsrep_t*    wsrep,
+                               const void* msg,
+                               size_t      msg_len,
+                               const char* donor_spec);
+
+  /*!
+   * @brief Returns an array fo status variables.
+   *        Array is terminated by Null variable name.
+   *
+   * @param wsrep this wsrep handle
+   * @return array of struct wsrep_status_var.
+   */
+    struct wsrep_stats_var* (*stats_get) (wsrep_t* wsrep);
+
+  /*!
+   * @brief Release resources that might be associated with the array.
+   *
+   * @param wsrep this wsrep handle.
+   */
+    void (*stats_free) (wsrep_t* wsrep, struct wsrep_stats_var* var_array);
+
+  /*!
+   * @brief Pauses writeset applying/committing.
+   *
+   * @return global sequence number of the paused state or negative error code.
+   */
+    wsrep_seqno_t (*pause) (wsrep_t* wsrep);
+
+  /*!
+   * @brief Resumes writeset applying/committing.
+   */
+    wsrep_status_t (*resume) (wsrep_t* wsrep);
+
+  /*!
+   * @brief Desynchronize from cluster
+   *
+   * Effectively turns off flow control for this node, allowing it
+   * to fall behind the cluster.
+   */
+    wsrep_status_t (*desync) (wsrep_t* wsrep);
+
+  /*!
+   * @brief Request to resynchronize with cluster.
+   *
+   * Effectively turns on flow control. Asynchronous - actual synchronization
+   * event to be deliverred via sync_cb.
+   */
+    wsrep_status_t (*resync) (wsrep_t* wsrep);
+
+  /*!
+   * @brief Acquire global named lock
+   *
+   * @param wsrep wsrep provider handle
+   * @param name  lock name
+   * @param owner 64-bit owner ID
+   * @param tout  timeout in nanoseconds.
+   *              0 - return immediately, -1 wait forever.
+   * @return wsrep status or negative error code
+   * @retval -EDEADLK lock was already acquired by this thread
+   * @retval -EBUSY   lock was busy
+   */
+    wsrep_status_t (*lock) (wsrep_t* wsrep, const char* name, int64_t owner,
+                            int64_t tout);
+
+  /*!
+   * @brief Release global named lock
+   *
+   * @param wsrep wsrep provider handle
+   * @param name  lock name
+   * @param owner 64-bit owner ID
+   * @return wsrep status or negative error code
+   * @retval -EPERM lock does not belong to this owner
+   */
+    wsrep_status_t (*unlock) (wsrep_t* wsrep, const char* name, int64_t owner);
+
+  /*!
+   * @brief Check if global named lock is locked
+   *
+   * @param wsrep wsrep provider handle
+   * @param name  lock name
+   * @param owner if not NULL will contain 64-bit owner ID
+   * @param node  if not NULL will contain owner's node UUID
+   * @return true if lock is locked
+   */
+    bool (*is_locked) (wsrep_t* wsrep, const char* name, int64_t* conn,
+                       wsrep_uuid_t* node);
+
+  /*!
+   * wsrep provider name
+   */
+    const char* provider_name;
+
+  /*!
+   * wsrep provider version
+   */
+    const char* provider_version;
+
+  /*!
+   * wsrep provider vendor name
+   */
+    const char* provider_vendor;
+
+  /*!
+   * @brief Frees allocated resources before unloading the library.
+   * @param wsrep this wsrep handle
+   */
+    void (*free)(wsrep_t* wsrep);
+
+    void *dlh;    //!< reserved for future use
+    void *ctx;    //!< reserved for implemetation private context
+};
+
+typedef int (*wsrep_loader_fun)(wsrep_t*);
+
+/*!
+ *
+ * @brief Loads wsrep library
+ *
+ * @param spec   path to wsrep library. If NULL or WSREP_NONE initialises dummy
+ *               pass-through implementation.
+ * @param hptr   wsrep handle
+ * @param log_cb callback to handle loader messages. Otherwise writes to stderr.
+ *
+ * @return zero on success, errno on failure
+ */
+int wsrep_load(const char* spec, wsrep_t** hptr, wsrep_log_cb_t log_cb);
+
+/*!
+ * @brief Unloads wsrep library and frees associated resources
+ *
+ * @param hptr wsrep handler pointer
+ */
+void wsrep_unload(wsrep_t* hptr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* WSREP_H */

=== added file 'wsrep/wsrep_dummy.c'
--- old/wsrep/wsrep_dummy.c	1970-01-01 00:00:00 +0000
+++ new/wsrep/wsrep_dummy.c	2012-01-27 18:54:43 +0000
@@ -0,0 +1,368 @@
+/* Copyright (C) 2009-2010 Codership Oy <info@codersihp.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*! @file Dummy wsrep API implementation. */
+
+#include <errno.h>
+
+#include "wsrep_api.h"
+
+/*! Dummy backend context. */
+typedef struct wsrep_dummy
+{
+    wsrep_log_cb_t log_fn;
+} wsrep_dummy_t;
+
+/* Get pointer to wsrep_dummy context from wsrep_t pointer */
+#define WSREP_DUMMY(_p) ((wsrep_dummy_t *) (_p)->ctx)
+
+/* Trace function usage a-la DBUG */
+#define WSREP_DBUG_ENTER(_w) do {                                       \
+        if (WSREP_DUMMY(_w)) {                                          \
+            if (WSREP_DUMMY(_w)->log_fn)                                \
+                WSREP_DUMMY(_w)->log_fn(WSREP_LOG_DEBUG, __FUNCTION__); \
+        }                                                               \
+    } while (0)
+
+
+static void dummy_free(wsrep_t *w)
+{
+    WSREP_DBUG_ENTER(w);
+    free(w->ctx);
+    w->ctx = NULL;
+}
+
+static wsrep_status_t dummy_init (wsrep_t* w,
+                                  const struct wsrep_init_args* args)
+{
+    WSREP_DUMMY(w)->log_fn = args->logger_cb;
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static uint64_t dummy_capabilities (wsrep_t* w __attribute__((unused)))
+{
+    return 0;
+}
+
+static wsrep_status_t dummy_options_set(
+    wsrep_t* w,
+    const char* conf __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static char* dummy_options_get (wsrep_t* w)
+{
+    WSREP_DBUG_ENTER(w);
+    return NULL;
+}
+
+static wsrep_status_t dummy_connect(
+    wsrep_t* w,
+    const char* name  __attribute__((unused)),
+    const char* url   __attribute__((unused)),
+    const char* donor __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_disconnect(wsrep_t* w)
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_recv(wsrep_t* w,
+                                 void*    recv_ctx __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_pre_commit(
+    wsrep_t* w,
+    const wsrep_conn_id_t  conn_id    __attribute__((unused)),
+    wsrep_trx_handle_t*    trx_handle __attribute__((unused)),
+    const void*            query      __attribute__((unused)),
+    const size_t           query_len  __attribute__((unused)),
+    uint64_t               flags      __attribute__((unused)),
+    wsrep_seqno_t*         seqno      __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_post_commit(
+    wsrep_t* w,
+    wsrep_trx_handle_t* trx_handle __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_post_rollback(
+    wsrep_t* w,
+    wsrep_trx_handle_t* trx_handle __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_replay_trx(
+    wsrep_t* w,
+    wsrep_trx_handle_t* trx_handle __attribute__((unused)),
+    void*               trx_ctx    __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_abort_pre_commit(
+    wsrep_t* w,
+    const wsrep_seqno_t  bf_seqno __attribute__((unused)),
+    const wsrep_trx_id_t trx_id   __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_append_query(
+    wsrep_t* w,
+    wsrep_trx_handle_t* trx_handle __attribute__((unused)),
+    const char*         query      __attribute__((unused)),
+    const time_t        timeval    __attribute__((unused)),
+    const uint32_t      randseed   __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_append_row_key(
+    wsrep_t* w,
+    wsrep_trx_handle_t*  trx_handle  __attribute__((unused)),
+    const wsrep_key_t*   key         __attribute__((unused)),
+    const size_t         key_len     __attribute__((unused)),
+    const bool           shared      __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_append_data(
+    wsrep_t* w,
+    wsrep_trx_handle_t* trx_handle __attribute__((unused)),
+    const void*         data       __attribute__((unused)),
+    size_t              data_len   __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_causal_read(
+    wsrep_t* w,
+    wsrep_seqno_t* seqno __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_free_connection(
+    wsrep_t* w,
+    const wsrep_conn_id_t  conn_id   __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_to_execute_start(
+    wsrep_t* w,
+    const wsrep_conn_id_t  conn_id   __attribute__((unused)),
+    const wsrep_key_t*     key       __attribute__((unused)),
+    const size_t           key_len   __attribute__((unused)),
+    const void*            query     __attribute__((unused)),
+    const size_t           query_len __attribute__((unused)),
+    wsrep_seqno_t*         seqno     __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_to_execute_end(
+    wsrep_t* w,
+    const wsrep_conn_id_t  conn_id   __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_sst_sent(
+    wsrep_t* w,
+    const wsrep_uuid_t* uuid   __attribute__((unused)),
+    wsrep_seqno_t       seqno  __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_sst_received(
+    wsrep_t* w,
+    const wsrep_uuid_t* uuid      __attribute__((unused)),
+    const wsrep_seqno_t seqno     __attribute__((unused)),
+    const char*         state     __attribute__((unused)),
+    const size_t        state_len __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_snapshot(
+    wsrep_t* w,
+    const void*  msg        __attribute__((unused)),
+    const size_t msg_len    __attribute__((unused)),
+    const char*  donor_spec __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static struct wsrep_stats_var dummy_stats[] = {
+    { NULL, WSREP_VAR_STRING, { 0 } }
+};
+
+static struct wsrep_stats_var* dummy_stats_get (wsrep_t* w)
+{
+    WSREP_DBUG_ENTER(w);
+    return dummy_stats;
+}
+
+static void dummy_stats_free (
+    wsrep_t* w,
+    struct wsrep_stats_var* stats __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+}
+
+static wsrep_seqno_t dummy_pause (wsrep_t* w)
+{
+    WSREP_DBUG_ENTER(w);
+    return -ENOSYS;
+}
+
+static wsrep_status_t dummy_resume (wsrep_t* w)
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_desync (wsrep_t* w)
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_NOT_IMPLEMENTED;
+}
+
+static wsrep_status_t dummy_resync (wsrep_t* w)
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static wsrep_status_t dummy_lock (wsrep_t* w,
+                                  const char* s __attribute__((unused)),
+                                  int64_t     o __attribute__((unused)),
+                                  int64_t     t __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_NOT_IMPLEMENTED;
+}
+
+static wsrep_status_t dummy_unlock (wsrep_t* w,
+                                    const char* s __attribute__((unused)),
+                                    int64_t     o __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return WSREP_OK;
+}
+
+static bool dummy_is_locked (wsrep_t* w,
+                             const char*   s __attribute__((unused)),
+                             int64_t*      o __attribute__((unused)),
+                             wsrep_uuid_t* t __attribute__((unused)))
+{
+    WSREP_DBUG_ENTER(w);
+    return false;
+}
+
+static wsrep_t dummy_iface = {
+    WSREP_INTERFACE_VERSION,
+    &dummy_init,
+    &dummy_capabilities,
+    &dummy_options_set,
+    &dummy_options_get,
+    &dummy_connect,
+    &dummy_disconnect,
+    &dummy_recv,
+    &dummy_pre_commit,
+    &dummy_post_commit,
+    &dummy_post_rollback,
+    &dummy_replay_trx,
+    &dummy_abort_pre_commit,
+    &dummy_append_query,
+    &dummy_append_row_key,
+    &dummy_append_data,
+    &dummy_causal_read,
+    &dummy_free_connection,
+    &dummy_to_execute_start,
+    &dummy_to_execute_end,
+    &dummy_sst_sent,
+    &dummy_sst_received,
+    &dummy_snapshot,
+    &dummy_stats_get,
+    &dummy_stats_free,
+    &dummy_pause,
+    &dummy_resume,
+    &dummy_desync,
+    &dummy_resync,
+    &dummy_lock,
+    &dummy_unlock,
+    &dummy_is_locked,
+    WSREP_NONE,
+    WSREP_INTERFACE_VERSION,
+    "Codership Oy <info@codership.com>",
+    &dummy_free,
+    NULL,
+    NULL
+};
+
+int wsrep_dummy_loader(wsrep_t* w)
+{
+    if (!w)
+        return EINVAL;
+
+    *w = dummy_iface;
+
+    // allocate private context
+    if (!(w->ctx = malloc(sizeof(wsrep_dummy_t))))
+        return ENOMEM;
+
+    // initialize private context
+    WSREP_DUMMY(w)->log_fn = NULL;
+
+    return 0;
+}
+

=== added file 'wsrep/wsrep_loader.c'
--- old/wsrep/wsrep_loader.c	1970-01-01 00:00:00 +0000
+++ new/wsrep/wsrep_loader.c	2011-10-09 00:27:23 +0000
@@ -0,0 +1,199 @@
+/* Copyright (C) 2009-2011 Codership Oy <info@codersihp.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*! @file wsrep implementation loader */
+
+#include <dlfcn.h>
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "wsrep_api.h"
+
+// Logging stuff for the loader
+static const char* log_levels[] = {"FATAL", "ERROR", "WARN", "INFO", "DEBUG"};
+
+static void default_logger (wsrep_log_level_t lvl, const char* msg)
+{
+    fprintf (stderr, "wsrep loader: [%s] %s\n", log_levels[lvl], msg);
+}
+
+static wsrep_log_cb_t logger = default_logger;
+
+/**************************************************************************
+ * Library loader
+ **************************************************************************/
+
+static int verify(const wsrep_t *wh, const char *iface_ver)
+{
+    const size_t msg_len = 128;
+    char msg[msg_len];
+
+#define VERIFY(_p) if (!(_p)) {                                       \
+        snprintf(msg, msg_len, "wsrep_load(): verify(): %s\n", # _p); \
+        logger (WSREP_LOG_ERROR, msg);                                \
+        return EINVAL;                                                \
+    }
+
+    VERIFY(wh);
+    VERIFY(wh->version);
+
+    if (strcmp(wh->version, iface_ver)) {
+        snprintf (msg, msg_len,
+                  "provider interface version mismatch: need '%s', found '%s'",
+                  iface_ver, wh->version);
+        logger (WSREP_LOG_ERROR, msg);
+        return EINVAL;
+    }
+
+    VERIFY(wh->init);
+    VERIFY(wh->options_set);
+    VERIFY(wh->options_get);
+    VERIFY(wh->connect);
+    VERIFY(wh->disconnect);
+    VERIFY(wh->recv);
+    VERIFY(wh->pre_commit);
+    VERIFY(wh->post_commit);
+    VERIFY(wh->post_rollback);
+    VERIFY(wh->replay_trx);
+    VERIFY(wh->abort_pre_commit);
+    VERIFY(wh->append_query);
+    VERIFY(wh->append_key);
+    VERIFY(wh->free_connection);
+    VERIFY(wh->to_execute_start);
+    VERIFY(wh->to_execute_end);
+    VERIFY(wh->sst_sent);
+    VERIFY(wh->sst_received);
+    VERIFY(wh->stats_get);
+    VERIFY(wh->stats_free);
+    VERIFY(wh->pause);
+    VERIFY(wh->resume);
+    VERIFY(wh->desync);
+    VERIFY(wh->resync);
+    VERIFY(wh->lock);
+    VERIFY(wh->unlock);
+    VERIFY(wh->is_locked);
+    VERIFY(wh->provider_name);
+    VERIFY(wh->provider_version);
+    VERIFY(wh->provider_vendor);
+    VERIFY(wh->free);
+    return 0;
+}
+
+
+static wsrep_loader_fun wsrep_dlf(void *dlh, const char *sym)
+{
+    union {
+        wsrep_loader_fun dlfun;
+        void *obj;
+    } alias;
+    alias.obj = dlsym(dlh, sym);
+    return alias.dlfun;
+}
+
+extern int wsrep_dummy_loader(wsrep_t *w);
+
+int wsrep_load(const char *spec, wsrep_t **hptr, wsrep_log_cb_t log_cb)
+{
+    int ret = 0;
+    void *dlh = NULL;
+    wsrep_loader_fun dlfun;
+    const size_t msg_len = 1024;
+    char msg[msg_len + 1];
+    msg[msg_len] = 0;
+
+    if (NULL != log_cb)
+        logger = log_cb;
+
+    if (!(spec && hptr))
+        return EINVAL;
+
+    snprintf (msg, msg_len,
+              "wsrep_load(): loading provider library '%s'", spec);
+    logger (WSREP_LOG_INFO, msg);
+
+    if (!(*hptr = malloc(sizeof(wsrep_t)))) {
+        logger (WSREP_LOG_FATAL, "wsrep_load(): out of memory");
+        return ENOMEM;
+    }
+
+    if (!spec || strcmp(spec, WSREP_NONE) == 0) {
+        if ((ret = wsrep_dummy_loader(*hptr)) != 0) {
+            free (*hptr);
+            *hptr = NULL;
+        }
+        return ret;
+    }
+
+    if (!(dlh = dlopen(spec, RTLD_NOW | RTLD_LOCAL))) {
+        snprintf(msg, msg_len, "wsrep_load(): dlopen(): %s", dlerror());
+        logger (WSREP_LOG_ERROR, msg);
+        ret = EINVAL;
+        goto out;
+    }
+
+    if (!(dlfun = wsrep_dlf(dlh, "wsrep_loader"))) {
+        ret = EINVAL;
+        goto out;
+    }
+
+    if ((ret = (*dlfun)(*hptr)) != 0) {
+        snprintf(msg, msg_len, "wsrep_load(): loader failed: %s",
+                 strerror(ret));
+        logger (WSREP_LOG_ERROR, msg);
+        goto out;
+    }
+
+    if ((ret = verify(*hptr, WSREP_INTERFACE_VERSION)) != 0) {
+        snprintf (msg, msg_len,
+                  "wsrep_load(): interface version mismatch: my version %s, "
+                  "provider version %s", WSREP_INTERFACE_VERSION,
+                  (*hptr)->version);
+        logger (WSREP_LOG_ERROR, msg);
+        goto out;
+    }
+
+    (*hptr)->dlh = dlh;
+
+out:
+    if (ret != 0) {
+        if (dlh) dlclose(dlh);
+        free(*hptr);
+        *hptr = NULL;
+    } else {
+        snprintf (msg, msg_len,
+                  "wsrep_load(): %s %s by %s loaded succesfully.",
+                  (*hptr)->provider_name, (*hptr)->provider_version,
+                  (*hptr)->provider_vendor);
+        logger (WSREP_LOG_INFO, msg);
+    }
+
+    return ret;
+}
+
+void wsrep_unload(wsrep_t *hptr)
+{
+    if (!hptr) {
+        logger (WSREP_LOG_WARN, "wsrep_unload(): null pointer.");
+    } else {
+        if (hptr->free)
+            hptr->free(hptr);
+        if (hptr->dlh)
+            dlclose(hptr->dlh);
+        free(hptr);
+    }
+}
+

=== added file 'wsrep/wsrep_uuid.c'
--- old/wsrep/wsrep_uuid.c	1970-01-01 00:00:00 +0000
+++ new/wsrep/wsrep_uuid.c	2010-05-19 18:17:46 +0000
@@ -0,0 +1,78 @@
+/* Copyright (C) 2009 Codership Oy <info@codersihp.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 of the License.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*! @file Helper functions to deal with history UUID string representations */
+
+#include <errno.h>
+#include <ctype.h>
+#include <stdio.h>
+
+#include "wsrep_api.h"
+
+/*!
+ * Read UUID from string
+ * @return length of UUID string representation or -EINVAL in case of error
+ */
+ssize_t
+wsrep_uuid_scan (const char* str, size_t str_len, wsrep_uuid_t* uuid)
+{
+    size_t uuid_len = 0;
+    size_t uuid_offt = 0;
+
+    while (uuid_len + 1 < str_len) {
+        if ((4  == uuid_offt || 6 == uuid_offt || 8 == uuid_offt ||
+             10 == uuid_offt) && str[uuid_len] == '-') {
+            // skip dashes after 4th, 6th, 8th and 10th positions
+            uuid_len += 1;
+            continue;
+        }
+        if (isxdigit(str[uuid_len]) && isxdigit(str[uuid_len + 1])) {
+            // got hex digit
+            sscanf (str + uuid_len, "%2hhx", uuid->uuid + uuid_offt);
+            uuid_len  += 2;
+            uuid_offt += 1;
+            if (sizeof (uuid->uuid) == uuid_offt)
+                return uuid_len;
+        }
+        else {
+            break;
+        }
+    }
+
+    *uuid = WSREP_UUID_UNDEFINED;
+    return -EINVAL;
+}
+
+/*!
+ * Write UUID to string
+ * @return length of UUID string representation or -EMSGSIZE if string is too
+ *         short
+ */
+ssize_t
+wsrep_uuid_print (const wsrep_uuid_t* uuid, char* str, size_t str_len)
+{
+    if (str_len > 36) {
+        const unsigned char* u = uuid->uuid;
+        return snprintf(str, str_len, "%02x%02x%02x%02x-%02x%02x-%02x%02x-"
+                        "%02x%02x-%02x%02x%02x%02x%02x%02x",
+                        u[ 0], u[ 1], u[ 2], u[ 3], u[ 4], u[ 5], u[ 6], u[ 7],
+                        u[ 8], u[ 9], u[10], u[11], u[12], u[13], u[14], u[15]);
+    }
+    else {
+        return -EMSGSIZE;
+    }
+}
+

