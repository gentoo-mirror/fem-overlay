user nginx nginx;
worker_processes 1;

error_log /var/log/nginx/error_log info;

events {
	worker_connections 1024;
	use epoll;
}

http {
	include /etc/nginx/mime.types;
	default_type application/octet-stream;

	log_format main
		'$remote_addr - $remote_user [$time_local] '
		'"$request" $status $bytes_sent '
		'"$http_referer" "$http_user_agent" '
		'"$gzip_ratio"';

	client_header_timeout 10m;
	client_body_timeout 10m;
	send_timeout 10m;

	connection_pool_size 256;
	client_header_buffer_size 1k;
	large_client_header_buffers 4 2k;
	request_pool_size 4k;

	gzip on;
	gzip_min_length 1100;
	gzip_buffers 4 8k;
	gzip_types text/plain;

	output_buffers 1 32k;
	postpone_output 1460;

	sendfile on;
	tcp_nopush on;
	tcp_nodelay on;

	keepalive_timeout 75 20;

	ignore_invalid_headers on;

	index index.html;

	server {
		listen 127.0.0.1;
		server_name localhost;

		access_log /var/log/nginx/localhost.access_log main;
		error_log /var/log/nginx/localhost.error_log info;

		root /var/www/localhost/htdocs;
	}

	# SSL example
	#server {
	#	listen 127.0.0.1:443;
	#	server_name localhost;

	#	ssl on;
	#	ssl_certificate /etc/ssl/nginx/nginx.pem;
	#	ssl_certificate_key /etc/ssl/nginx/nginx.key;

	#	access_log /var/log/nginx/localhost.ssl_access_log main;
	#	error_log /var/log/nginx/localhost.ssl_error_log info;

	#	root /var/www/localhost/htdocs;
	#}
}

#rtmp {
#    https://github.com/arut/nginx-rtmp-module
#    server {

#        listen 1935;

#        chunk_size 4000;

#        # TV mode: one publisher, many subscribers
#        application mytv {

#            # enable live streaming
#            live on;

#            # record first 1K of stream
#            record all;
#            record_path /tmp/av;
#            record_max_size 1K;

#            # append current timestamp to each flv
#            record_unique on;

#            # publish only from localhost
#            allow publish 127.0.0.1;
#            deny publish all;

#            #allow play all;
#        }

#        # Transcoding (ffmpeg needed)
#        application big {
#            live on;

#            # On every pusblished stream run this command (ffmpeg)
#            # with substitutions: $app/${app}, $name/${name} for application & stream name.
#            #
#            # This ffmpeg call receives stream from this application &
#            # reduces the resolution down to 32x32. The stream is the published to
#            # 'small' application (see below) under the same name.
#            #
#            # ffmpeg can do anything with the stream like video/audio
#            # transcoding, resizing, altering container/codec params etc
#            #
#            # Multiple exec lines can be specified.

#            exec /usr/bin/ffmpeg -re -i rtmp://localhost:1935/$app/$name -vcodec flv -acodec copy -s 32x32 -f flv rtmp://localhost:1935/small/${name};
#        }

#        application small {
#            live on;
#            # Video with reduced resolution comes here from ffmpeg
#        }

#        application mypush {
#            live on;

#            # Every stream published here
#            # is automatically pushed to 
#            # these two machines
#            push rtmp1.example.com;
#            push rtmp2.example.com:1934;
#        }

#        application mypull {
#            live on;

#            # Pull all streams from remote machine
#            # and play locally
#            pull rtmp://rtmp3.example.com pageUrl=www.example.com/index.html;
#        }

#        # video on demand
#        application vod {
#            play /var/flvs;
#        }

#        application vod2 {
#            play /var/mp4s;
#        }

#        # Many publishers, many subscribers
#        # no checks, no recording
#        application videochat {

#            live on;

#            # The following notifications receive all 
#            # the session variables as well as 
#            # particular call arguments in HTTP POST
#            # request

#            # Make HTTP request & use HTTP retcode
#            # to decide whether to allow publishing
#            # from this connection or not
#            on_publish http://localhost:8080/publish;

#            # Same with playing
#            on_play http://localhost:8080/play;

#            # Publish/play end (repeats on disconnect)
#            on_done http://localhost:8080/done;

#            # All above mentioned notifications receive
#            # standard connect() arguments as well as 
#            # play/publish ones. If any arguments are sent
#            # with GET-style syntax to play & publish
#            # these are also included.
#            # Example URL:
#            #   rtmp://localhost/myapp/mystream?a=b&c=d

#            # record 10 video keyframes (no audio) every 2 minutes
#            record keyframes;
#            record_path /tmp/vc;
#            record_max_frames 10;
#            record_interval 2m;

#            # Async notify about an flv recorded
#            on_record_done http://localhost:8080/record_done;

#        }


#        # HLS

#        # HLS requires libavformat & should be configured as a separate
#        # NGINX module in addition to nginx-rtmp-module:
#        # ./configure ... --add-module=/path/to/nginx-rtmp-module/hls ...

#        # For HLS to work please create a directory in tmpfs (/tmp/app here)
#        # for the fragments. The directory contents is served via HTTP (see
#        # http{} section in config)
#        #
#        # Incoming stream must be in H264/AAC/MP3. For iPhones use baseline H264
#        # profile (see ffmpeg example).
#        # This example creates RTMP stream from movie ready for HLS:
#        #
#        # ffmpeg -loglevel verbose -re -i movie.avi  -vcodec libx264 
#        #    -vprofile baseline -acodec libmp3lame -ar 44100 -ac 1 
#        #    -f flv rtmp://localhost:1935/hls/movie
#        #
#        # If you need to transcode live stream use 'exec' feature.
#        #
#        application hls {
#            hls on;
#            hls_path /tmp/app;
#            hls_fragment 5s;
#        }

#    }
#}

## HTTP can be used for accessing RTMP stats
#http {

#    server {

#        listen      8080;

#        # This URL provides RTMP statistics in XML
#        location /stat {
#            rtmp_stat all;

#            # Use this stylesheet to view XML as web page
#            # in browser
#            rtmp_stat_stylesheet stat.xsl;
#        }

#        location /stat.xsl {
#            # XML stylesheet to view RTMP stats.
#            # Copy stat.xsl wherever you want
#            # and put the full directory path here
#            root /path/to/stat.xsl/;
#        }

#        location /hls {
#            # Serve HLS fragments
#            alias /tmp/app;
#        }

#    }
#}



## Multi-worker streaming
#rtmp_auto_push on;

#rtmp {

#    server {

#        listen 1935;

#        chunk_size 4000;

#        # TV mode: one publisher, many subscribers
#        application mytv {
#            live on;
#        }
#    }
#}
